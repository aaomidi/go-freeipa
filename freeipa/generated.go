// Code generated by `github.com/tehwalris/go-freeipa/gen` - DO NOT EDIT.

package freeipa;

import (
  "time"
	"encoding/json"
  "fmt"
)

var apiVersion = "2.237"

type request struct {
  Method string `json:"method"`
  Params []interface{} `json:"params"`
}


/*
Create new ACI.
*/
func (c *Client) AciAdd(
  reqArgs *AciAddArgs,
  optArgs *AciAddOptionalArgs, // can be nil
) (*AciAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciAddKwParams{
    AciAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_add",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciAddArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  }

type AciAddOptionalArgs struct {
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *string `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *string `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *string `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *string `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *bool `json:"selfaci,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix *string `json:"aciprefix,omitempty"`
  
    /*

Test the ACI syntax but don't write anything
    */
    Test *bool `json:"test,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciAddKwParams struct {
  *AciAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AciAddResult `json:"result"`
}

type AciAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Aci `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AciAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciAddResult%v", string(b))
}

/*
Delete ACI.
*/
func (c *Client) AciDel(
  reqArgs *AciDelArgs,
  optArgs *AciDelOptionalArgs, // can be nil
) (*AciDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciDelKwParams{
    AciDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_del",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, reqArgs.Aciprefix, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciDelArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix string `json:"aciprefix,omitempty"`
  }

type AciDelOptionalArgs struct {
  }

type aciDelKwParams struct {
  *AciDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AciDelResult `json:"result"`
}

type AciDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AciDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciDelResult%v", string(b))
}

/*
Search for ACIs.

    Returns a list of ACIs

    EXAMPLES:

     To find all ACIs that apply directly to members of the group ipausers:
       ipa aci-find --memberof=ipausers

     To find all ACIs that grant add access:
       ipa aci-find --permissions=add

    Note that the find command only looks for the given text in the set of
    ACIs, it does not evaluate the ACIs to see if something would apply.
    For example, searching on memberof=ipausers will find all ACIs that
    have ipausers as a memberof. There may be other ACIs that apply to
    members of that group indirectly.
*/
func (c *Client) AciFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AciFindArgs,
  optArgs *AciFindOptionalArgs, // can be nil
) (*AciFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciFindKwParams{
    AciFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciFindArgs struct {
  }

type AciFindOptionalArgs struct {
  
    /*
ACI name

    */
    Aciname *string `json:"aciname,omitempty"`
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *string `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *string `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *string `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *string `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *bool `json:"selfaci,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix *string `json:"aciprefix,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciFindKwParams struct {
  *AciFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AciFindResult `json:"result"`
}

type AciFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Aci `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *AciFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciFindResult%v", string(b))
}

/*
Modify ACI.
*/
func (c *Client) AciMod(
  reqArgs *AciModArgs,
  optArgs *AciModOptionalArgs, // can be nil
) (*AciModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciModKwParams{
    AciModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciModArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  }

type AciModOptionalArgs struct {
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *string `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *string `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *string `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *string `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *bool `json:"selfaci,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix *string `json:"aciprefix,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciModKwParams struct {
  *AciModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciModResponse struct {
	Error  *Error      `json:"error"`
	Result *AciModResult `json:"result"`
}

type AciModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Aci `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AciModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciModResult%v", string(b))
}

/*
Rename an ACI.
*/
func (c *Client) AciRename(
  reqArgs *AciRenameArgs,
  optArgs *AciRenameOptionalArgs, // can be nil
) (*AciRenameResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciRenameKwParams{
    AciRenameOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_rename",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciRenameResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciRenameArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  }

type AciRenameOptionalArgs struct {
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *string `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *string `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *string `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *string `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *bool `json:"selfaci,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix *string `json:"aciprefix,omitempty"`
  
    /*

New ACI name
    */
    Newname *string `json:"newname,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciRenameKwParams struct {
  *AciRenameOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciRenameResponse struct {
	Error  *Error      `json:"error"`
	Result *AciRenameResult `json:"result"`
}

type AciRenameResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AciRenameResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciRenameResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciRenameResult%v", string(b))
}

/*
Display a single ACI given an ACI name.
*/
func (c *Client) AciShow(
  reqArgs *AciShowArgs,
  optArgs *AciShowOptionalArgs, // can be nil
) (*AciShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciShowKwParams{
    AciShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_show",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, reqArgs.Aciprefix, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciShowArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix string `json:"aciprefix,omitempty"`
  }

type AciShowOptionalArgs struct {
  
    /*
Location of the ACI

    */
    Location *string `json:"location,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciShowKwParams struct {
  *AciShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AciShowResult `json:"result"`
}

type AciShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Aci `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AciShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciShowResult%v", string(b))
}

/*
Determine whether ipa-adtrust-install has been run on this system
*/
func (c *Client) AdtrustIsEnabled(
  reqArgs *AdtrustIsEnabledArgs,
  optArgs *AdtrustIsEnabledOptionalArgs, // can be nil
) (*AdtrustIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := adtrustIsEnabledKwParams{
    AdtrustIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "adtrust_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res adtrustIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AdtrustIsEnabledArgs struct {
  }

type AdtrustIsEnabledOptionalArgs struct {
  }

type adtrustIsEnabledKwParams struct {
  *AdtrustIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type adtrustIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *AdtrustIsEnabledResult `json:"result"`
}

type AdtrustIsEnabledResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *AdtrustIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AdtrustIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AdtrustIsEnabledResult%v", string(b))
}

/*
Add an automember rule.
*/
func (c *Client) AutomemberAdd(
  reqArgs *AutomemberAddArgs,
  optArgs *AutomemberAddOptionalArgs, // can be nil
) (*AutomemberAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberAddKwParams{
    AutomemberAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberAddArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomemberAddOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberAddKwParams struct {
  *AutomemberAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberAddResult `json:"result"`
}

type AutomemberAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automember `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomemberAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberAddResult%v", string(b))
}

/*
Add conditions to an automember rule.
*/
func (c *Client) AutomemberAddCondition(
  reqArgs *AutomemberAddConditionArgs,
  optArgs *AutomemberAddConditionOptionalArgs, // can be nil
) (*AutomemberAddConditionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberAddConditionKwParams{
    AutomemberAddConditionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_add_condition",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberAddConditionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberAddConditionArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomemberAddConditionOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Inclusive Regex
Inclusive Regex
    */
    Automemberinclusiveregex *[]string `json:"automemberinclusiveregex,omitempty"`
  
    /*
Exclusive Regex
Exclusive Regex
    */
    Automemberexclusiveregex *[]string `json:"automemberexclusiveregex,omitempty"`
  
    /*
Attribute Key
Attribute to filter via regex. For example fqdn for a host, or manager for a user
    */
    Key *string `json:"key,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberAddConditionKwParams struct {
  *AutomemberAddConditionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberAddConditionResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberAddConditionResult `json:"result"`
}

type AutomemberAddConditionResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  
    /*
Conditions that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of conditions added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *AutomemberAddConditionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberAddConditionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberAddConditionResult%v", string(b))
}

/*
Remove default (fallback) group for all unmatched entries.
*/
func (c *Client) AutomemberDefaultGroupRemove(
  reqArgs *AutomemberDefaultGroupRemoveArgs,
  optArgs *AutomemberDefaultGroupRemoveOptionalArgs, // can be nil
) (*AutomemberDefaultGroupRemoveResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberDefaultGroupRemoveKwParams{
    AutomemberDefaultGroupRemoveOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_default_group_remove",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberDefaultGroupRemoveResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberDefaultGroupRemoveArgs struct {
  }

type AutomemberDefaultGroupRemoveOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberDefaultGroupRemoveKwParams struct {
  *AutomemberDefaultGroupRemoveOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberDefaultGroupRemoveResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberDefaultGroupRemoveResult `json:"result"`
}

type AutomemberDefaultGroupRemoveResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomemberDefaultGroupRemoveResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDefaultGroupRemoveResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDefaultGroupRemoveResult%v", string(b))
}

/*
Set default (fallback) group for all unmatched entries.
*/
func (c *Client) AutomemberDefaultGroupSet(
  reqArgs *AutomemberDefaultGroupSetArgs,
  optArgs *AutomemberDefaultGroupSetOptionalArgs, // can be nil
) (*AutomemberDefaultGroupSetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberDefaultGroupSetKwParams{
    AutomemberDefaultGroupSetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_default_group_set",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberDefaultGroupSetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberDefaultGroupSetArgs struct {
  }

type AutomemberDefaultGroupSetOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Default (fallback) Group
Default (fallback) group for entries to land
    */
    Automemberdefaultgroup *string `json:"automemberdefaultgroup,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberDefaultGroupSetKwParams struct {
  *AutomemberDefaultGroupSetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberDefaultGroupSetResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberDefaultGroupSetResult `json:"result"`
}

type AutomemberDefaultGroupSetResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomemberDefaultGroupSetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDefaultGroupSetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDefaultGroupSetResult%v", string(b))
}

/*
Display information about the default (fallback) automember groups.
*/
func (c *Client) AutomemberDefaultGroupShow(
  reqArgs *AutomemberDefaultGroupShowArgs,
  optArgs *AutomemberDefaultGroupShowOptionalArgs, // can be nil
) (*AutomemberDefaultGroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberDefaultGroupShowKwParams{
    AutomemberDefaultGroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_default_group_show",
    Params: []interface{}{
      []interface{}{reqArgs.Type, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberDefaultGroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberDefaultGroupShowArgs struct {
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberDefaultGroupShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberDefaultGroupShowKwParams struct {
  *AutomemberDefaultGroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberDefaultGroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberDefaultGroupShowResult `json:"result"`
}

type AutomemberDefaultGroupShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result AutomemberDefaultGroup `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomemberDefaultGroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDefaultGroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDefaultGroupShowResult%v", string(b))
}

/*
Delete an automember rule.
*/
func (c *Client) AutomemberDel(
  reqArgs *AutomemberDelArgs,
  optArgs *AutomemberDelOptionalArgs, // can be nil
) (*AutomemberDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberDelKwParams{
    AutomemberDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Type, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberDelArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn []string `json:"cn,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberDelOptionalArgs struct {
  }

type automemberDelKwParams struct {
  *AutomemberDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberDelResult `json:"result"`
}

type AutomemberDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Automember `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomemberDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDelResult%v", string(b))
}

/*
Search for automember rules.
*/
func (c *Client) AutomemberFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomemberFindArgs,
  optArgs *AutomemberFindOptionalArgs, // can be nil
) (*AutomemberFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberFindKwParams{
    AutomemberFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberFindArgs struct {
  }

type AutomemberFindOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("automember-rule")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type automemberFindKwParams struct {
  *AutomemberFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberFindResult `json:"result"`
}

type AutomemberFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Automember `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *AutomemberFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberFindResult%v", string(b))
}

/*
Search for orphan automember rules. The command might need to be run as
    a privileged user user to get all orphan rules.
*/
func (c *Client) AutomemberFindOrphans(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomemberFindOrphansArgs,
  optArgs *AutomemberFindOrphansOptionalArgs, // can be nil
) (*AutomemberFindOrphansResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberFindOrphansKwParams{
    AutomemberFindOrphansOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_find_orphans",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberFindOrphansResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberFindOrphansArgs struct {
  }

type AutomemberFindOrphansOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*

Remove orphan automember rules
    */
    Remove *bool `json:"remove,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("automember-rule")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type automemberFindOrphansKwParams struct {
  *AutomemberFindOrphansOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberFindOrphansResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberFindOrphansResult `json:"result"`
}

type AutomemberFindOrphansResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []interface{} `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *AutomemberFindOrphansResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberFindOrphansResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberFindOrphansResult%v", string(b))
}

/*
Modify an automember rule.
*/
func (c *Client) AutomemberMod(
  reqArgs *AutomemberModArgs,
  optArgs *AutomemberModOptionalArgs, // can be nil
) (*AutomemberModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberModKwParams{
    AutomemberModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberModArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomemberModOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberModKwParams struct {
  *AutomemberModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberModResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberModResult `json:"result"`
}

type AutomemberModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automember `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomemberModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberModResult%v", string(b))
}

/*
Rebuild auto membership.
*/
func (c *Client) AutomemberRebuild(
  reqArgs *AutomemberRebuildArgs,
  optArgs *AutomemberRebuildOptionalArgs, // can be nil
) (*AutomemberRebuildResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberRebuildKwParams{
    AutomemberRebuildOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_rebuild",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberRebuildResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberRebuildArgs struct {
  }

type AutomemberRebuildOptionalArgs struct {
  
    /*
Rebuild membership for all members of a grouping
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*
Users
Rebuild membership for specified users
    */
    Users *[]string `json:"users,omitempty"`
  
    /*
Hosts
Rebuild membership for specified hosts
    */
    Hosts *[]string `json:"hosts,omitempty"`
  
    /*
No wait
Don't wait for rebuilding membership
    */
    NoWait *bool `json:"no_wait,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberRebuildKwParams struct {
  *AutomemberRebuildOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberRebuildResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberRebuildResult `json:"result"`
}

type AutomemberRebuildResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *AutomemberRebuildResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberRebuildResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberRebuildResult%v", string(b))
}

/*
Remove conditions from an automember rule.
*/
func (c *Client) AutomemberRemoveCondition(
  reqArgs *AutomemberRemoveConditionArgs,
  optArgs *AutomemberRemoveConditionOptionalArgs, // can be nil
) (*AutomemberRemoveConditionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberRemoveConditionKwParams{
    AutomemberRemoveConditionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_remove_condition",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberRemoveConditionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberRemoveConditionArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomemberRemoveConditionOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Inclusive Regex
Inclusive Regex
    */
    Automemberinclusiveregex *[]string `json:"automemberinclusiveregex,omitempty"`
  
    /*
Exclusive Regex
Exclusive Regex
    */
    Automemberexclusiveregex *[]string `json:"automemberexclusiveregex,omitempty"`
  
    /*
Attribute Key
Attribute to filter via regex. For example fqdn for a host, or manager for a user
    */
    Key *string `json:"key,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberRemoveConditionKwParams struct {
  *AutomemberRemoveConditionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberRemoveConditionResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberRemoveConditionResult `json:"result"`
}

type AutomemberRemoveConditionResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  
    /*
Conditions that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of conditions removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *AutomemberRemoveConditionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberRemoveConditionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberRemoveConditionResult%v", string(b))
}

/*
Display information about an automember rule.
*/
func (c *Client) AutomemberShow(
  reqArgs *AutomemberShowArgs,
  optArgs *AutomemberShowOptionalArgs, // can be nil
) (*AutomemberShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberShowKwParams{
    AutomemberShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Type, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberShowArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberShowKwParams struct {
  *AutomemberShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberShowResult `json:"result"`
}

type AutomemberShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automember `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomemberShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberShowResult%v", string(b))
}

/*
Create a new automount key.
*/
func (c *Client) AutomountkeyAdd(
  reqArgs *AutomountkeyAddArgs,
  optArgs *AutomountkeyAddOptionalArgs, // can be nil
) (*AutomountkeyAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyAddKwParams{
    AutomountkeyAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_add",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapautomountmapname, reqArgs.Automountkey, reqArgs.Automountinformation, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyAddArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  
    /*
Key
Automount key name.
    */
    Automountkey string `json:"automountkey,omitempty"`
  
    /*
Mount information

    */
    Automountinformation string `json:"automountinformation,omitempty"`
  }

type AutomountkeyAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountkeyAddKwParams struct {
  *AutomountkeyAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyAddResult `json:"result"`
}

type AutomountkeyAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automountkey `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountkeyAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyAddResult%v", string(b))
}

/*
Delete an automount key.
*/
func (c *Client) AutomountkeyDel(
  reqArgs *AutomountkeyDelArgs,
  optArgs *AutomountkeyDelOptionalArgs, // can be nil
) (*AutomountkeyDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyDelKwParams{
    AutomountkeyDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_del",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapautomountmapname, reqArgs.Automountkey, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyDelArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  
    /*
Key
Automount key name.
    */
    Automountkey string `json:"automountkey,omitempty"`
  }

type AutomountkeyDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Mount information

    */
    Automountinformation *string `json:"automountinformation,omitempty"`
  }

type automountkeyDelKwParams struct {
  *AutomountkeyDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyDelResult `json:"result"`
}

type AutomountkeyDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Automountkey `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountkeyDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyDelResult%v", string(b))
}

/*
Search for an automount key.
*/
func (c *Client) AutomountkeyFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomountkeyFindArgs,
  optArgs *AutomountkeyFindOptionalArgs, // can be nil
) (*AutomountkeyFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyFindKwParams{
    AutomountkeyFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_find",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapautomountmapname, criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyFindArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  }

type AutomountkeyFindOptionalArgs struct {
  
    /*
Key
Automount key name.
    */
    Automountkey *string `json:"automountkey,omitempty"`
  
    /*
Mount information

    */
    Automountinformation *string `json:"automountinformation,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountkeyFindKwParams struct {
  *AutomountkeyFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyFindResult `json:"result"`
}

type AutomountkeyFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Automountkey `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *AutomountkeyFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyFindResult%v", string(b))
}

/*
Modify an automount key.
*/
func (c *Client) AutomountkeyMod(
  reqArgs *AutomountkeyModArgs,
  optArgs *AutomountkeyModOptionalArgs, // can be nil
) (*AutomountkeyModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyModKwParams{
    AutomountkeyModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapautomountmapname, reqArgs.Automountkey, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyModArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  
    /*
Key
Automount key name.
    */
    Automountkey string `json:"automountkey,omitempty"`
  }

type AutomountkeyModOptionalArgs struct {
  
    /*
Mount information

    */
    Automountinformation *string `json:"automountinformation,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
New mount information

    */
    Newautomountinformation *string `json:"newautomountinformation,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the automount key object
    */
    Rename *string `json:"rename,omitempty"`
  }

type automountkeyModKwParams struct {
  *AutomountkeyModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyModResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyModResult `json:"result"`
}

type AutomountkeyModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automountkey `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountkeyModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyModResult%v", string(b))
}

/*
Display an automount key.
*/
func (c *Client) AutomountkeyShow(
  reqArgs *AutomountkeyShowArgs,
  optArgs *AutomountkeyShowOptionalArgs, // can be nil
) (*AutomountkeyShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyShowKwParams{
    AutomountkeyShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_show",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapautomountmapname, reqArgs.Automountkey, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyShowArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  
    /*
Key
Automount key name.
    */
    Automountkey string `json:"automountkey,omitempty"`
  }

type AutomountkeyShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Mount information

    */
    Automountinformation *string `json:"automountinformation,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountkeyShowKwParams struct {
  *AutomountkeyShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyShowResult `json:"result"`
}

type AutomountkeyShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automountkey `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountkeyShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyShowResult%v", string(b))
}

/*
Create a new automount location.
*/
func (c *Client) AutomountlocationAdd(
  reqArgs *AutomountlocationAddArgs,
  optArgs *AutomountlocationAddOptionalArgs, // can be nil
) (*AutomountlocationAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationAddKwParams{
    AutomountlocationAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationAddArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomountlocationAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountlocationAddKwParams struct {
  *AutomountlocationAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationAddResult `json:"result"`
}

type AutomountlocationAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automountlocation `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountlocationAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationAddResult%v", string(b))
}

/*
Delete an automount location.
*/
func (c *Client) AutomountlocationDel(
  reqArgs *AutomountlocationDelArgs,
  optArgs *AutomountlocationDelOptionalArgs, // can be nil
) (*AutomountlocationDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationDelKwParams{
    AutomountlocationDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationDelArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn []string `json:"cn,omitempty"`
  }

type AutomountlocationDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type automountlocationDelKwParams struct {
  *AutomountlocationDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationDelResult `json:"result"`
}

type AutomountlocationDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Automountlocation `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountlocationDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationDelResult%v", string(b))
}

/*
Search for an automount location.
*/
func (c *Client) AutomountlocationFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomountlocationFindArgs,
  optArgs *AutomountlocationFindOptionalArgs, // can be nil
) (*AutomountlocationFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationFindKwParams{
    AutomountlocationFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationFindArgs struct {
  }

type AutomountlocationFindOptionalArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("location")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type automountlocationFindKwParams struct {
  *AutomountlocationFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationFindResult `json:"result"`
}

type AutomountlocationFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Automountlocation `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *AutomountlocationFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationFindResult%v", string(b))
}

/*
Display an automount location.
*/
func (c *Client) AutomountlocationShow(
  reqArgs *AutomountlocationShowArgs,
  optArgs *AutomountlocationShowOptionalArgs, // can be nil
) (*AutomountlocationShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationShowKwParams{
    AutomountlocationShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationShowArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomountlocationShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountlocationShowKwParams struct {
  *AutomountlocationShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationShowResult `json:"result"`
}

type AutomountlocationShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automountlocation `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountlocationShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationShowResult%v", string(b))
}

/*
Generate automount files for a specific location.
*/
func (c *Client) AutomountlocationTofiles(
  reqArgs *AutomountlocationTofilesArgs,
  optArgs *AutomountlocationTofilesOptionalArgs, // can be nil
) (*AutomountlocationTofilesResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationTofilesKwParams{
    AutomountlocationTofilesOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_tofiles",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationTofilesResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationTofilesArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomountlocationTofilesOptionalArgs struct {
  }

type automountlocationTofilesKwParams struct {
  *AutomountlocationTofilesOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationTofilesResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationTofilesResult `json:"result"`
}

type AutomountlocationTofilesResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *AutomountlocationTofilesResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationTofilesResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationTofilesResult%v", string(b))
}

/*
Create a new automount map.
*/
func (c *Client) AutomountmapAdd(
  reqArgs *AutomountmapAddArgs,
  optArgs *AutomountmapAddOptionalArgs, // can be nil
) (*AutomountmapAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapAddKwParams{
    AutomountmapAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_add",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapAddArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname string `json:"automountmapname,omitempty"`
  }

type AutomountmapAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountmapAddKwParams struct {
  *AutomountmapAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapAddResult `json:"result"`
}

type AutomountmapAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automountmap `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountmapAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapAddResult%v", string(b))
}

/*
Create a new indirect mount point.
*/
func (c *Client) AutomountmapAddIndirect(
  reqArgs *AutomountmapAddIndirectArgs,
  optArgs *AutomountmapAddIndirectOptionalArgs, // can be nil
) (*AutomountmapAddIndirectResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapAddIndirectKwParams{
    AutomountmapAddIndirectOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_add_indirect",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapAddIndirectResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapAddIndirectArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname string `json:"automountmapname,omitempty"`
  }

type AutomountmapAddIndirectOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Mount point

    */
    Key *string `json:"key,omitempty"`
  
    /*
Parent map
Name of parent automount map (default: auto.master).
    */
    Parentmap *string `json:"parentmap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountmapAddIndirectKwParams struct {
  *AutomountmapAddIndirectOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapAddIndirectResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapAddIndirectResult `json:"result"`
}

type AutomountmapAddIndirectResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountmapAddIndirectResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapAddIndirectResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapAddIndirectResult%v", string(b))
}

/*
Delete an automount map.
*/
func (c *Client) AutomountmapDel(
  reqArgs *AutomountmapDelArgs,
  optArgs *AutomountmapDelOptionalArgs, // can be nil
) (*AutomountmapDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapDelKwParams{
    AutomountmapDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_del",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapDelArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname []string `json:"automountmapname,omitempty"`
  }

type AutomountmapDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type automountmapDelKwParams struct {
  *AutomountmapDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapDelResult `json:"result"`
}

type AutomountmapDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Automountmap `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountmapDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapDelResult%v", string(b))
}

/*
Search for an automount map.
*/
func (c *Client) AutomountmapFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomountmapFindArgs,
  optArgs *AutomountmapFindOptionalArgs, // can be nil
) (*AutomountmapFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapFindKwParams{
    AutomountmapFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_find",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapFindArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  }

type AutomountmapFindOptionalArgs struct {
  
    /*
Map
Automount map name.
    */
    Automountmapname *string `json:"automountmapname,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("map")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type automountmapFindKwParams struct {
  *AutomountmapFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapFindResult `json:"result"`
}

type AutomountmapFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Automountmap `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *AutomountmapFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapFindResult%v", string(b))
}

/*
Modify an automount map.
*/
func (c *Client) AutomountmapMod(
  reqArgs *AutomountmapModArgs,
  optArgs *AutomountmapModOptionalArgs, // can be nil
) (*AutomountmapModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapModKwParams{
    AutomountmapModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapModArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname string `json:"automountmapname,omitempty"`
  }

type AutomountmapModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountmapModKwParams struct {
  *AutomountmapModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapModResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapModResult `json:"result"`
}

type AutomountmapModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automountmap `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountmapModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapModResult%v", string(b))
}

/*
Display an automount map.
*/
func (c *Client) AutomountmapShow(
  reqArgs *AutomountmapShowArgs,
  optArgs *AutomountmapShowOptionalArgs, // can be nil
) (*AutomountmapShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapShowKwParams{
    AutomountmapShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_show",
    Params: []interface{}{
      []interface{}{reqArgs.Automountlocationcn, reqArgs.Automountmapname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapShowArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname string `json:"automountmapname,omitempty"`
  }

type AutomountmapShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountmapShowKwParams struct {
  *AutomountmapShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapShowResult `json:"result"`
}

type AutomountmapShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Automountmap `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *AutomountmapShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapShowResult%v", string(b))
}

/*
Create a CA.
*/
func (c *Client) CaAdd(
  reqArgs *CaAddArgs,
  optArgs *CaAddOptionalArgs, // can be nil
) (*CaAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caAddKwParams{
    CaAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaAddArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  }

type CaAddOptionalArgs struct {
  
    /*
Description
Description of the purpose of the CA
    */
    Description *string `json:"description,omitempty"`
  
    /*
Subject DN
Subject Distinguished Name
    */
    Ipacasubjectdn *string `json:"ipacasubjectdn,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Include certificate chain in output
    */
    Chain *bool `json:"chain,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type caAddKwParams struct {
  *CaAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caAddResponse struct {
	Error  *Error      `json:"error"`
	Result *CaAddResult `json:"result"`
}

type CaAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Ca `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaAddResult%v", string(b))
}

/*
Delete a CA.
*/
func (c *Client) CaDel(
  reqArgs *CaDelArgs,
  optArgs *CaDelOptionalArgs, // can be nil
) (*CaDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caDelKwParams{
    CaDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaDelArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn []string `json:"cn,omitempty"`
  }

type CaDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type caDelKwParams struct {
  *CaDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CaDelResult `json:"result"`
}

type CaDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Ca `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaDelResult%v", string(b))
}

/*
Disable a CA.
*/
func (c *Client) CaDisable(
  reqArgs *CaDisableArgs,
  optArgs *CaDisableOptionalArgs, // can be nil
) (*CaDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caDisableKwParams{
    CaDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaDisableArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  }

type CaDisableOptionalArgs struct {
  }

type caDisableKwParams struct {
  *CaDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *CaDisableResult `json:"result"`
}

type CaDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaDisableResult%v", string(b))
}

/*
Enable a CA.
*/
func (c *Client) CaEnable(
  reqArgs *CaEnableArgs,
  optArgs *CaEnableOptionalArgs, // can be nil
) (*CaEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caEnableKwParams{
    CaEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_enable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaEnableArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  }

type CaEnableOptionalArgs struct {
  }

type caEnableKwParams struct {
  *CaEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *CaEnableResult `json:"result"`
}

type CaEnableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaEnableResult%v", string(b))
}

/*
Search for CAs.
*/
func (c *Client) CaFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CaFindArgs,
  optArgs *CaFindOptionalArgs, // can be nil
) (*CaFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caFindKwParams{
    CaFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaFindArgs struct {
  }

type CaFindOptionalArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Description of the purpose of the CA
    */
    Description *string `json:"description,omitempty"`
  
    /*
Authority ID
Dogtag Authority ID
    */
    Ipacaid *string `json:"ipacaid,omitempty"`
  
    /*
Subject DN
Subject Distinguished Name
    */
    Ipacasubjectdn *string `json:"ipacasubjectdn,omitempty"`
  
    /*
Issuer DN
Issuer Distinguished Name
    */
    Ipacaissuerdn *string `json:"ipacaissuerdn,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type caFindKwParams struct {
  *CaFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CaFindResult `json:"result"`
}

type CaFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Ca `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *CaFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaFindResult%v", string(b))
}

/*
Checks if any of the servers has the CA service enabled.
*/
func (c *Client) CaIsEnabled(
  reqArgs *CaIsEnabledArgs,
  optArgs *CaIsEnabledOptionalArgs, // can be nil
) (*CaIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caIsEnabledKwParams{
    CaIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaIsEnabledArgs struct {
  }

type CaIsEnabledOptionalArgs struct {
  }

type caIsEnabledKwParams struct {
  *CaIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *CaIsEnabledResult `json:"result"`
}

type CaIsEnabledResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *CaIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaIsEnabledResult%v", string(b))
}

/*
Modify CA configuration.
*/
func (c *Client) CaMod(
  reqArgs *CaModArgs,
  optArgs *CaModOptionalArgs, // can be nil
) (*CaModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caModKwParams{
    CaModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaModArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  }

type CaModOptionalArgs struct {
  
    /*
Description
Description of the purpose of the CA
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the Certificate Authority object
    */
    Rename *string `json:"rename,omitempty"`
  }

type caModKwParams struct {
  *CaModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caModResponse struct {
	Error  *Error      `json:"error"`
	Result *CaModResult `json:"result"`
}

type CaModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Ca `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaModResult%v", string(b))
}

/*
Display the properties of a CA.
*/
func (c *Client) CaShow(
  reqArgs *CaShowArgs,
  optArgs *CaShowOptionalArgs, // can be nil
) (*CaShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caShowKwParams{
    CaShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaShowArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  }

type CaShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Include certificate chain in output
    */
    Chain *bool `json:"chain,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type caShowKwParams struct {
  *CaShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CaShowResult `json:"result"`
}

type CaShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Ca `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaShowResult%v", string(b))
}

/*
Create a new CA ACL.
*/
func (c *Client) CaaclAdd(
  reqArgs *CaaclAddArgs,
  optArgs *CaaclAddOptionalArgs, // can be nil
) (*CaaclAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddKwParams{
    CaaclAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
CA category
CA category the ACL applies to
    */
    Ipacacategory *string `json:"ipacacategory,omitempty"`
  
    /*
Profile category
Profile category the ACL applies to
    */
    Ipacertprofilecategory *string `json:"ipacertprofilecategory,omitempty"`
  
    /*
User category
User category the ACL applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the ACL applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Service category
Service category the ACL applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type caaclAddKwParams struct {
  *CaaclAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddResult `json:"result"`
}

type CaaclAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Caacl `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaaclAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddResult%v", string(b))
}

/*
Add CAs to a CA ACL.
*/
func (c *Client) CaaclAddCa(
  reqArgs *CaaclAddCaArgs,
  optArgs *CaaclAddCaOptionalArgs, // can be nil
) (*CaaclAddCaResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddCaKwParams{
    CaaclAddCaOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_ca",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddCaResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddCaArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddCaOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member Certificate Authority
Certificate Authorities to add
    */
    Ca *[]string `json:"ca,omitempty"`
  }

type caaclAddCaKwParams struct {
  *CaaclAddCaOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddCaResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddCaResult `json:"result"`
}

type CaaclAddCaResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclAddCaResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddCaResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddCaResult%v", string(b))
}

/*
Add target hosts and hostgroups to a CA ACL.
*/
func (c *Client) CaaclAddHost(
  reqArgs *CaaclAddHostArgs,
  optArgs *CaaclAddHostOptionalArgs, // can be nil
) (*CaaclAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddHostKwParams{
    CaaclAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_host",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddHostArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type caaclAddHostKwParams struct {
  *CaaclAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddHostResult `json:"result"`
}

type CaaclAddHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddHostResult%v", string(b))
}

/*
Add profiles to a CA ACL.
*/
func (c *Client) CaaclAddProfile(
  reqArgs *CaaclAddProfileArgs,
  optArgs *CaaclAddProfileOptionalArgs, // can be nil
) (*CaaclAddProfileResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddProfileKwParams{
    CaaclAddProfileOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_profile",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddProfileResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddProfileArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddProfileOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member Certificate Profile
Certificate Profiles to add
    */
    Certprofile *[]string `json:"certprofile,omitempty"`
  }

type caaclAddProfileKwParams struct {
  *CaaclAddProfileOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddProfileResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddProfileResult `json:"result"`
}

type CaaclAddProfileResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclAddProfileResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddProfileResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddProfileResult%v", string(b))
}

/*
Add services to a CA ACL.
*/
func (c *Client) CaaclAddService(
  reqArgs *CaaclAddServiceArgs,
  optArgs *CaaclAddServiceOptionalArgs, // can be nil
) (*CaaclAddServiceResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddServiceKwParams{
    CaaclAddServiceOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_service",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddServiceResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddServiceArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddServiceOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member service
services to add
    */
    Service *[]string `json:"service,omitempty"`
  }

type caaclAddServiceKwParams struct {
  *CaaclAddServiceOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddServiceResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddServiceResult `json:"result"`
}

type CaaclAddServiceResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclAddServiceResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddServiceResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddServiceResult%v", string(b))
}

/*
Add users and groups to a CA ACL.
*/
func (c *Client) CaaclAddUser(
  reqArgs *CaaclAddUserArgs,
  optArgs *CaaclAddUserOptionalArgs, // can be nil
) (*CaaclAddUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddUserKwParams{
    CaaclAddUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_user",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddUserArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type caaclAddUserKwParams struct {
  *CaaclAddUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddUserResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddUserResult `json:"result"`
}

type CaaclAddUserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclAddUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddUserResult%v", string(b))
}

/*
Delete a CA ACL.
*/
func (c *Client) CaaclDel(
  reqArgs *CaaclDelArgs,
  optArgs *CaaclDelOptionalArgs, // can be nil
) (*CaaclDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclDelKwParams{
    CaaclDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclDelArgs struct {
  
    /*
ACL name

    */
    Cn []string `json:"cn,omitempty"`
  }

type CaaclDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type caaclDelKwParams struct {
  *CaaclDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclDelResult `json:"result"`
}

type CaaclDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Caacl `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaaclDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclDelResult%v", string(b))
}

/*
Disable a CA ACL.
*/
func (c *Client) CaaclDisable(
  reqArgs *CaaclDisableArgs,
  optArgs *CaaclDisableOptionalArgs, // can be nil
) (*CaaclDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclDisableKwParams{
    CaaclDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclDisableArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclDisableOptionalArgs struct {
  }

type caaclDisableKwParams struct {
  *CaaclDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclDisableResult `json:"result"`
}

type CaaclDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaaclDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclDisableResult%v", string(b))
}

/*
Enable a CA ACL.
*/
func (c *Client) CaaclEnable(
  reqArgs *CaaclEnableArgs,
  optArgs *CaaclEnableOptionalArgs, // can be nil
) (*CaaclEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclEnableKwParams{
    CaaclEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_enable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclEnableArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclEnableOptionalArgs struct {
  }

type caaclEnableKwParams struct {
  *CaaclEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclEnableResult `json:"result"`
}

type CaaclEnableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaaclEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclEnableResult%v", string(b))
}

/*
Search for CA ACLs.
*/
func (c *Client) CaaclFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CaaclFindArgs,
  optArgs *CaaclFindOptionalArgs, // can be nil
) (*CaaclFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclFindKwParams{
    CaaclFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclFindArgs struct {
  }

type CaaclFindOptionalArgs struct {
  
    /*
ACL name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
CA category
CA category the ACL applies to
    */
    Ipacacategory *string `json:"ipacacategory,omitempty"`
  
    /*
Profile category
Profile category the ACL applies to
    */
    Ipacertprofilecategory *string `json:"ipacertprofilecategory,omitempty"`
  
    /*
User category
User category the ACL applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the ACL applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Service category
Service category the ACL applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type caaclFindKwParams struct {
  *CaaclFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclFindResult `json:"result"`
}

type CaaclFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Caacl `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *CaaclFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclFindResult%v", string(b))
}

/*
Modify a CA ACL.
*/
func (c *Client) CaaclMod(
  reqArgs *CaaclModArgs,
  optArgs *CaaclModOptionalArgs, // can be nil
) (*CaaclModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclModKwParams{
    CaaclModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclModArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
CA category
CA category the ACL applies to
    */
    Ipacacategory *string `json:"ipacacategory,omitempty"`
  
    /*
Profile category
Profile category the ACL applies to
    */
    Ipacertprofilecategory *string `json:"ipacertprofilecategory,omitempty"`
  
    /*
User category
User category the ACL applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the ACL applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Service category
Service category the ACL applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type caaclModKwParams struct {
  *CaaclModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclModResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclModResult `json:"result"`
}

type CaaclModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Caacl `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaaclModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclModResult%v", string(b))
}

/*
Remove CAs from a CA ACL.
*/
func (c *Client) CaaclRemoveCa(
  reqArgs *CaaclRemoveCaArgs,
  optArgs *CaaclRemoveCaOptionalArgs, // can be nil
) (*CaaclRemoveCaResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveCaKwParams{
    CaaclRemoveCaOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_ca",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveCaResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveCaArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveCaOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member Certificate Authority
Certificate Authorities to remove
    */
    Ca *[]string `json:"ca,omitempty"`
  }

type caaclRemoveCaKwParams struct {
  *CaaclRemoveCaOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveCaResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveCaResult `json:"result"`
}

type CaaclRemoveCaResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclRemoveCaResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveCaResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveCaResult%v", string(b))
}

/*
Remove target hosts and hostgroups from a CA ACL.
*/
func (c *Client) CaaclRemoveHost(
  reqArgs *CaaclRemoveHostArgs,
  optArgs *CaaclRemoveHostOptionalArgs, // can be nil
) (*CaaclRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveHostKwParams{
    CaaclRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_host",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveHostArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type caaclRemoveHostKwParams struct {
  *CaaclRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveHostResult `json:"result"`
}

type CaaclRemoveHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveHostResult%v", string(b))
}

/*
Remove profiles from a CA ACL.
*/
func (c *Client) CaaclRemoveProfile(
  reqArgs *CaaclRemoveProfileArgs,
  optArgs *CaaclRemoveProfileOptionalArgs, // can be nil
) (*CaaclRemoveProfileResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveProfileKwParams{
    CaaclRemoveProfileOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_profile",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveProfileResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveProfileArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveProfileOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member Certificate Profile
Certificate Profiles to remove
    */
    Certprofile *[]string `json:"certprofile,omitempty"`
  }

type caaclRemoveProfileKwParams struct {
  *CaaclRemoveProfileOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveProfileResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveProfileResult `json:"result"`
}

type CaaclRemoveProfileResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclRemoveProfileResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveProfileResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveProfileResult%v", string(b))
}

/*
Remove services from a CA ACL.
*/
func (c *Client) CaaclRemoveService(
  reqArgs *CaaclRemoveServiceArgs,
  optArgs *CaaclRemoveServiceOptionalArgs, // can be nil
) (*CaaclRemoveServiceResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveServiceKwParams{
    CaaclRemoveServiceOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_service",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveServiceResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveServiceArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveServiceOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member service
services to remove
    */
    Service *[]string `json:"service,omitempty"`
  }

type caaclRemoveServiceKwParams struct {
  *CaaclRemoveServiceOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveServiceResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveServiceResult `json:"result"`
}

type CaaclRemoveServiceResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclRemoveServiceResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveServiceResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveServiceResult%v", string(b))
}

/*
Remove users and groups from a CA ACL.
*/
func (c *Client) CaaclRemoveUser(
  reqArgs *CaaclRemoveUserArgs,
  optArgs *CaaclRemoveUserOptionalArgs, // can be nil
) (*CaaclRemoveUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveUserKwParams{
    CaaclRemoveUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_user",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveUserArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type caaclRemoveUserKwParams struct {
  *CaaclRemoveUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveUserResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveUserResult `json:"result"`
}

type CaaclRemoveUserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *CaaclRemoveUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveUserResult%v", string(b))
}

/*
Display the properties of a CA ACL.
*/
func (c *Client) CaaclShow(
  reqArgs *CaaclShowArgs,
  optArgs *CaaclShowOptionalArgs, // can be nil
) (*CaaclShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclShowKwParams{
    CaaclShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclShowArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type caaclShowKwParams struct {
  *CaaclShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclShowResult `json:"result"`
}

type CaaclShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Caacl `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CaaclShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclShowResult%v", string(b))
}

/*
Search for existing certificates.
*/
func (c *Client) CertFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CertFindArgs,
  optArgs *CertFindOptionalArgs, // can be nil
) (*CertFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certFindKwParams{
    CertFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertFindArgs struct {
  }

type CertFindOptionalArgs struct {
  
    /*
Certificate
Base-64 encoded certificate.
    */
    Certificate *interface{} `json:"certificate,omitempty"`
  
    /*
Issuer
Issuer DN
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Revocation reason
Reason for revoking the certificate (0-10). Type "ipa help cert" for revocation reason details. 
    */
    RevocationReason *int `json:"revocation_reason,omitempty"`
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*
Subject
Subject
    */
    Subject *string `json:"subject,omitempty"`
  
    /*

minimum serial number
    */
    MinSerialNumber *int `json:"min_serial_number,omitempty"`
  
    /*

maximum serial number
    */
    MaxSerialNumber *int `json:"max_serial_number,omitempty"`
  
    /*

match the common name exactly
    */
    Exactly *bool `json:"exactly,omitempty"`
  
    /*

Valid not after from this date (YYYY-mm-dd)
    */
    ValidnotafterFrom *time.Time `json:"validnotafter_from,omitempty"`
  
    /*

Valid not after to this date (YYYY-mm-dd)
    */
    ValidnotafterTo *time.Time `json:"validnotafter_to,omitempty"`
  
    /*

Valid not before from this date (YYYY-mm-dd)
    */
    ValidnotbeforeFrom *time.Time `json:"validnotbefore_from,omitempty"`
  
    /*

Valid not before to this date (YYYY-mm-dd)
    */
    ValidnotbeforeTo *time.Time `json:"validnotbefore_to,omitempty"`
  
    /*

Issued on from this date (YYYY-mm-dd)
    */
    IssuedonFrom *time.Time `json:"issuedon_from,omitempty"`
  
    /*

Issued on to this date (YYYY-mm-dd)
    */
    IssuedonTo *time.Time `json:"issuedon_to,omitempty"`
  
    /*

Revoked on from this date (YYYY-mm-dd)
    */
    RevokedonFrom *time.Time `json:"revokedon_from,omitempty"`
  
    /*

Revoked on to this date (YYYY-mm-dd)
    */
    RevokedonTo *time.Time `json:"revokedon_to,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("certificate")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
user
Search for certificates with these owner users.
    */
    User *[]string `json:"user,omitempty"`
  
    /*
user
Search for certificates without these owner users.
    */
    NoUser *[]string `json:"no_user,omitempty"`
  
    /*
host
Search for certificates with these owner hosts.
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
host
Search for certificates without these owner hosts.
    */
    NoHost *[]string `json:"no_host,omitempty"`
  
    /*
service
Search for certificates with these owner services.
    */
    Service *[]string `json:"service,omitempty"`
  
    /*
service
Search for certificates without these owner services.
    */
    NoService *[]string `json:"no_service,omitempty"`
  }

type certFindKwParams struct {
  *CertFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CertFindResult `json:"result"`
}

type CertFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Cert `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *CertFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertFindResult%v", string(b))
}

/*
Take a revoked certificate off hold.
*/
func (c *Client) CertRemoveHold(
  reqArgs *CertRemoveHoldArgs,
  optArgs *CertRemoveHoldOptionalArgs, // can be nil
) (*CertRemoveHoldResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certRemoveHoldKwParams{
    CertRemoveHoldOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_remove_hold",
    Params: []interface{}{
      []interface{}{reqArgs.SerialNumber, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certRemoveHoldResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertRemoveHoldArgs struct {
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber int `json:"serial_number,omitempty"`
  }

type CertRemoveHoldOptionalArgs struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  }

type certRemoveHoldKwParams struct {
  *CertRemoveHoldOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certRemoveHoldResponse struct {
	Error  *Error      `json:"error"`
	Result *CertRemoveHoldResult `json:"result"`
}

type CertRemoveHoldResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *CertRemoveHoldResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertRemoveHoldResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertRemoveHoldResult%v", string(b))
}

/*
Submit a certificate signing request.
*/
func (c *Client) CertRequest(
  reqArgs *CertRequestArgs,
  optArgs *CertRequestOptionalArgs, // can be nil
) (*CertRequestResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certRequestKwParams{
    CertRequestOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_request",
    Params: []interface{}{
      []interface{}{reqArgs.Csr, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certRequestResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertRequestArgs struct {
  
    /*
CSR

    */
    Csr string `json:"csr,omitempty"`
  }

type CertRequestOptionalArgs struct {
  
    /*


    */
    RequestType *string `json:"request_type,omitempty"`
  
    /*
Profile ID
Certificate Profile to use
    */
    ProfileID *string `json:"profile_id,omitempty"`
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*
Principal
Principal for this certificate (e.g. HTTP/test.example.com)
    */
    Principal *string `json:"principal,omitempty"`
  
    /*

automatically add the principal if it doesn't exist (service principals only)
    */
    Add *bool `json:"add,omitempty"`
  
    /*

Include certificate chain in output
    */
    Chain *bool `json:"chain,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certRequestKwParams struct {
  *CertRequestOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certRequestResponse struct {
	Error  *Error      `json:"error"`
	Result *CertRequestResult `json:"result"`
}

type CertRequestResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[int] `json:"value,omitempty"`
  }

func (t *CertRequestResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertRequestResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertRequestResult%v", string(b))
}

/*
Revoke a certificate.
*/
func (c *Client) CertRevoke(
  reqArgs *CertRevokeArgs,
  optArgs *CertRevokeOptionalArgs, // can be nil
) (*CertRevokeResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certRevokeKwParams{
    CertRevokeOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_revoke",
    Params: []interface{}{
      []interface{}{reqArgs.SerialNumber, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certRevokeResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertRevokeArgs struct {
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber int `json:"serial_number,omitempty"`
  }

type CertRevokeOptionalArgs struct {
  
    /*
Revocation reason
Reason for revoking the certificate (0-10). Type "ipa help cert" for revocation reason details. 
    */
    RevocationReason *int `json:"revocation_reason,omitempty"`
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  }

type certRevokeKwParams struct {
  *CertRevokeOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certRevokeResponse struct {
	Error  *Error      `json:"error"`
	Result *CertRevokeResult `json:"result"`
}

type CertRevokeResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *CertRevokeResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertRevokeResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertRevokeResult%v", string(b))
}

/*
Retrieve an existing certificate.
*/
func (c *Client) CertShow(
  reqArgs *CertShowArgs,
  optArgs *CertShowOptionalArgs, // can be nil
) (*CertShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certShowKwParams{
    CertShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_show",
    Params: []interface{}{
      []interface{}{reqArgs.SerialNumber, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertShowArgs struct {
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber int `json:"serial_number,omitempty"`
  }

type CertShowOptionalArgs struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*
Output filename
File to store the certificate in.
    */
    Out *string `json:"out,omitempty"`
  
    /*

Include certificate chain in output
    */
    Chain *bool `json:"chain,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type certShowKwParams struct {
  *CertShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CertShowResult `json:"result"`
}

type CertShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Cert `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[int] `json:"value,omitempty"`
  }

func (t *CertShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertShowResult%v", string(b))
}

/*
Check the status of a certificate signing request.
*/
func (c *Client) CertStatus(
  reqArgs *CertStatusArgs,
  optArgs *CertStatusOptionalArgs, // can be nil
) (*CertStatusResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certStatusKwParams{
    CertStatusOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_status",
    Params: []interface{}{
      []interface{}{reqArgs.RequestID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certStatusResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertStatusArgs struct {
  
    /*
Request id

    */
    RequestID int `json:"request_id,omitempty"`
  }

type CertStatusOptionalArgs struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certStatusKwParams struct {
  *CertStatusOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certStatusResponse struct {
	Error  *Error      `json:"error"`
	Result *CertStatusResult `json:"result"`
}

type CertStatusResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[int] `json:"value,omitempty"`
  }

func (t *CertStatusResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertStatusResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertStatusResult%v", string(b))
}

/*
Search for users matching the provided certificate.

    This command relies on SSSD to retrieve the list of matching users and
    may return cached data. For more information on purging SSSD cache,
    please refer to sss_cache documentation.
*/
func (c *Client) CertmapMatch(
  reqArgs *CertmapMatchArgs,
  optArgs *CertmapMatchOptionalArgs, // can be nil
) (*CertmapMatchResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapMatchKwParams{
    CertmapMatchOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmap_match",
    Params: []interface{}{
      []interface{}{reqArgs.Certificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapMatchResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapMatchArgs struct {
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate interface{} `json:"certificate,omitempty"`
  }

type CertmapMatchOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapMatchKwParams struct {
  *CertmapMatchOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapMatchResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapMatchResult `json:"result"`
}

type CertmapMatchResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []interface{} `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *CertmapMatchResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapMatchResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapMatchResult%v", string(b))
}

/*
Modify Certificate Identity Mapping configuration.
*/
func (c *Client) CertmapconfigMod(
  reqArgs *CertmapconfigModArgs,
  optArgs *CertmapconfigModOptionalArgs, // can be nil
) (*CertmapconfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapconfigModKwParams{
    CertmapconfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmapconfig_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapconfigModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapconfigModArgs struct {
  }

type CertmapconfigModOptionalArgs struct {
  
    /*
Prompt for the username
Prompt for the username when multiple identities are mapped to a certificate
    */
    Ipacertmappromptusername *bool `json:"ipacertmappromptusername,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapconfigModKwParams struct {
  *CertmapconfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapconfigModResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapconfigModResult `json:"result"`
}

type CertmapconfigModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Certmapconfig `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *CertmapconfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapconfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapconfigModResult%v", string(b))
}

/*
Show the current Certificate Identity Mapping configuration.
*/
func (c *Client) CertmapconfigShow(
  reqArgs *CertmapconfigShowArgs,
  optArgs *CertmapconfigShowOptionalArgs, // can be nil
) (*CertmapconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapconfigShowKwParams{
    CertmapconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmapconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapconfigShowArgs struct {
  }

type CertmapconfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapconfigShowKwParams struct {
  *CertmapconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapconfigShowResult `json:"result"`
}

type CertmapconfigShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Certmapconfig `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *CertmapconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapconfigShowResult%v", string(b))
}

/*
Create a new Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleAdd(
  reqArgs *CertmapruleAddArgs,
  optArgs *CertmapruleAddOptionalArgs, // can be nil
) (*CertmapruleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleAddKwParams{
    CertmapruleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleAddArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleAddOptionalArgs struct {
  
    /*
Description
Certificate Identity Mapping Rule description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Mapping rule
Rule used to map the certificate with a user entry
    */
    Ipacertmapmaprule *string `json:"ipacertmapmaprule,omitempty"`
  
    /*
Matching rule
Rule used to check if a certificate can be used for authentication
    */
    Ipacertmapmatchrule *string `json:"ipacertmapmatchrule,omitempty"`
  
    /*
Domain name
Domain where the user entry will be searched
    */
    Associateddomain *[]string `json:"associateddomain,omitempty"`
  
    /*
Priority
Priority of the rule (higher number means lower priority
    */
    Ipacertmappriority *int `json:"ipacertmappriority,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapruleAddKwParams struct {
  *CertmapruleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleAddResult `json:"result"`
}

type CertmapruleAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Certmaprule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertmapruleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleAddResult%v", string(b))
}

/*
Delete a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleDel(
  reqArgs *CertmapruleDelArgs,
  optArgs *CertmapruleDelOptionalArgs, // can be nil
) (*CertmapruleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleDelKwParams{
    CertmapruleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleDelArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn []string `json:"cn,omitempty"`
  }

type CertmapruleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type certmapruleDelKwParams struct {
  *CertmapruleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleDelResult `json:"result"`
}

type CertmapruleDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Certmaprule `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertmapruleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleDelResult%v", string(b))
}

/*
Disable a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleDisable(
  reqArgs *CertmapruleDisableArgs,
  optArgs *CertmapruleDisableOptionalArgs, // can be nil
) (*CertmapruleDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleDisableKwParams{
    CertmapruleDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleDisableArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleDisableOptionalArgs struct {
  }

type certmapruleDisableKwParams struct {
  *CertmapruleDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleDisableResult `json:"result"`
}

type CertmapruleDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertmapruleDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleDisableResult%v", string(b))
}

/*
Enable a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleEnable(
  reqArgs *CertmapruleEnableArgs,
  optArgs *CertmapruleEnableOptionalArgs, // can be nil
) (*CertmapruleEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleEnableKwParams{
    CertmapruleEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_enable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleEnableArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleEnableOptionalArgs struct {
  }

type certmapruleEnableKwParams struct {
  *CertmapruleEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleEnableResult `json:"result"`
}

type CertmapruleEnableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertmapruleEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleEnableResult%v", string(b))
}

/*
Search for Certificate Identity Mapping Rules.
*/
func (c *Client) CertmapruleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CertmapruleFindArgs,
  optArgs *CertmapruleFindOptionalArgs, // can be nil
) (*CertmapruleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleFindKwParams{
    CertmapruleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleFindArgs struct {
  }

type CertmapruleFindOptionalArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Certificate Identity Mapping Rule description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Mapping rule
Rule used to map the certificate with a user entry
    */
    Ipacertmapmaprule *string `json:"ipacertmapmaprule,omitempty"`
  
    /*
Matching rule
Rule used to check if a certificate can be used for authentication
    */
    Ipacertmapmatchrule *string `json:"ipacertmapmatchrule,omitempty"`
  
    /*
Domain name
Domain where the user entry will be searched
    */
    Associateddomain *[]string `json:"associateddomain,omitempty"`
  
    /*
Priority
Priority of the rule (higher number means lower priority
    */
    Ipacertmappriority *int `json:"ipacertmappriority,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("rulename")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type certmapruleFindKwParams struct {
  *CertmapruleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleFindResult `json:"result"`
}

type CertmapruleFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Certmaprule `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *CertmapruleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleFindResult%v", string(b))
}

/*
Modify a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleMod(
  reqArgs *CertmapruleModArgs,
  optArgs *CertmapruleModOptionalArgs, // can be nil
) (*CertmapruleModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleModKwParams{
    CertmapruleModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleModArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleModOptionalArgs struct {
  
    /*
Description
Certificate Identity Mapping Rule description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Mapping rule
Rule used to map the certificate with a user entry
    */
    Ipacertmapmaprule *string `json:"ipacertmapmaprule,omitempty"`
  
    /*
Matching rule
Rule used to check if a certificate can be used for authentication
    */
    Ipacertmapmatchrule *string `json:"ipacertmapmatchrule,omitempty"`
  
    /*
Domain name
Domain where the user entry will be searched
    */
    Associateddomain *[]string `json:"associateddomain,omitempty"`
  
    /*
Priority
Priority of the rule (higher number means lower priority
    */
    Ipacertmappriority *int `json:"ipacertmappriority,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapruleModKwParams struct {
  *CertmapruleModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleModResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleModResult `json:"result"`
}

type CertmapruleModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Certmaprule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertmapruleModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleModResult%v", string(b))
}

/*
Display information about a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleShow(
  reqArgs *CertmapruleShowArgs,
  optArgs *CertmapruleShowOptionalArgs, // can be nil
) (*CertmapruleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleShowKwParams{
    CertmapruleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleShowArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapruleShowKwParams struct {
  *CertmapruleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleShowResult `json:"result"`
}

type CertmapruleShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Certmaprule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertmapruleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleShowResult%v", string(b))
}

/*
Delete a Certificate Profile.
*/
func (c *Client) CertprofileDel(
  reqArgs *CertprofileDelArgs,
  optArgs *CertprofileDelOptionalArgs, // can be nil
) (*CertprofileDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileDelKwParams{
    CertprofileDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileDelArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn []string `json:"cn,omitempty"`
  }

type CertprofileDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type certprofileDelKwParams struct {
  *CertprofileDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileDelResult `json:"result"`
}

type CertprofileDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Certprofile `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertprofileDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileDelResult%v", string(b))
}

/*
Search for Certificate Profiles.
*/
func (c *Client) CertprofileFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CertprofileFindArgs,
  optArgs *CertprofileFindOptionalArgs, // can be nil
) (*CertprofileFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileFindKwParams{
    CertprofileFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileFindArgs struct {
  }

type CertprofileFindOptionalArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Profile description
Brief description of this profile
    */
    Description *string `json:"description,omitempty"`
  
    /*
Store issued certificates
Whether to store certs issued using this profile
    */
    Ipacertprofilestoreissued *bool `json:"ipacertprofilestoreissued,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("id")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type certprofileFindKwParams struct {
  *CertprofileFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileFindResult `json:"result"`
}

type CertprofileFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Certprofile `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *CertprofileFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileFindResult%v", string(b))
}

/*
Import a Certificate Profile.
*/
func (c *Client) CertprofileImport(
  reqArgs *CertprofileImportArgs,
  optArgs *CertprofileImportOptionalArgs, // can be nil
) (*CertprofileImportResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileImportKwParams{
    CertprofileImportOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_import",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Description, reqArgs.Ipacertprofilestoreissued, reqArgs.File, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileImportResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileImportArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Profile description
Brief description of this profile
    */
    Description string `json:"description,omitempty"`
  
    /*
Store issued certificates
Whether to store certs issued using this profile
    */
    Ipacertprofilestoreissued bool `json:"ipacertprofilestoreissued,omitempty"`
  
    /*
Filename of a raw profile. The XML format is not supported.

    */
    File string `json:"file,omitempty"`
  }

type CertprofileImportOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certprofileImportKwParams struct {
  *CertprofileImportOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileImportResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileImportResult `json:"result"`
}

type CertprofileImportResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertprofileImportResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileImportResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileImportResult%v", string(b))
}

/*
Modify Certificate Profile configuration.
*/
func (c *Client) CertprofileMod(
  reqArgs *CertprofileModArgs,
  optArgs *CertprofileModOptionalArgs, // can be nil
) (*CertprofileModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileModKwParams{
    CertprofileModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileModArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn string `json:"cn,omitempty"`
  }

type CertprofileModOptionalArgs struct {
  
    /*
Profile description
Brief description of this profile
    */
    Description *string `json:"description,omitempty"`
  
    /*
Store issued certificates
Whether to store certs issued using this profile
    */
    Ipacertprofilestoreissued *bool `json:"ipacertprofilestoreissued,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
File containing profile configuration

    */
    File *string `json:"file,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certprofileModKwParams struct {
  *CertprofileModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileModResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileModResult `json:"result"`
}

type CertprofileModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Certprofile `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertprofileModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileModResult%v", string(b))
}

/*
Display the properties of a Certificate Profile.
*/
func (c *Client) CertprofileShow(
  reqArgs *CertprofileShowArgs,
  optArgs *CertprofileShowOptionalArgs, // can be nil
) (*CertprofileShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileShowKwParams{
    CertprofileShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileShowArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn string `json:"cn,omitempty"`
  }

type CertprofileShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Write profile configuration to file
    */
    Out *string `json:"out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certprofileShowKwParams struct {
  *CertprofileShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileShowResult `json:"result"`
}

type CertprofileShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Certprofile `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CertprofileShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileShowResult%v", string(b))
}

/*
Search for classes.
*/
func (c *Client) ClassFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ClassFindArgs,
  optArgs *ClassFindOptionalArgs, // can be nil
) (*ClassFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := classFindKwParams{
    ClassFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "class_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res classFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ClassFindArgs struct {
  }

type ClassFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type classFindKwParams struct {
  *ClassFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type classFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ClassFindResult `json:"result"`
}

type ClassFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Class `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *ClassFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ClassFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ClassFindResult%v", string(b))
}

/*
Display information about a class.
*/
func (c *Client) ClassShow(
  reqArgs *ClassShowArgs,
  optArgs *ClassShowOptionalArgs, // can be nil
) (*ClassShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := classShowKwParams{
    ClassShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "class_show",
    Params: []interface{}{
      []interface{}{reqArgs.FullName, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res classShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ClassShowArgs struct {
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  }

type ClassShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type classShowKwParams struct {
  *ClassShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type classShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ClassShowResult `json:"result"`
}

type ClassShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Class `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ClassShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ClassShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ClassShowResult%v", string(b))
}

/*
Search for commands.
*/
func (c *Client) CommandFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CommandFindArgs,
  optArgs *CommandFindOptionalArgs, // can be nil
) (*CommandFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := commandFindKwParams{
    CommandFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "command_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res commandFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CommandFindArgs struct {
  }

type CommandFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type commandFindKwParams struct {
  *CommandFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type commandFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CommandFindResult `json:"result"`
}

type CommandFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Command `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *CommandFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CommandFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CommandFindResult%v", string(b))
}

/*
Display information about a command.
*/
func (c *Client) CommandShow(
  reqArgs *CommandShowArgs,
  optArgs *CommandShowOptionalArgs, // can be nil
) (*CommandShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := commandShowKwParams{
    CommandShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "command_show",
    Params: []interface{}{
      []interface{}{reqArgs.FullName, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res commandShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CommandShowArgs struct {
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  }

type CommandShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type commandShowKwParams struct {
  *CommandShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type commandShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CommandShowResult `json:"result"`
}

type CommandShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Command `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CommandShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CommandShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CommandShowResult%v", string(b))
}

/*
Determine whether Schema Compatibility plugin is configured to serve trusted domain users and groups
*/
func (c *Client) CompatIsEnabled(
  reqArgs *CompatIsEnabledArgs,
  optArgs *CompatIsEnabledOptionalArgs, // can be nil
) (*CompatIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := compatIsEnabledKwParams{
    CompatIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "compat_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res compatIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CompatIsEnabledArgs struct {
  }

type CompatIsEnabledOptionalArgs struct {
  }

type compatIsEnabledKwParams struct {
  *CompatIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type compatIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *CompatIsEnabledResult `json:"result"`
}

type CompatIsEnabledResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *CompatIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CompatIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CompatIsEnabledResult%v", string(b))
}

/*
Modify configuration options.
*/
func (c *Client) ConfigMod(
  reqArgs *ConfigModArgs,
  optArgs *ConfigModOptionalArgs, // can be nil
) (*ConfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := configModKwParams{
    ConfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "config_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res configModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ConfigModArgs struct {
  }

type ConfigModOptionalArgs struct {
  
    /*
Maximum username length

    */
    Ipamaxusernamelength *int `json:"ipamaxusernamelength,omitempty"`
  
    /*
Home directory base
Default location of home directories
    */
    Ipahomesrootdir *string `json:"ipahomesrootdir,omitempty"`
  
    /*
Default shell
Default shell for new users
    */
    Ipadefaultloginshell *string `json:"ipadefaultloginshell,omitempty"`
  
    /*
Default users group
Default group for new users
    */
    Ipadefaultprimarygroup *string `json:"ipadefaultprimarygroup,omitempty"`
  
    /*
Default e-mail domain
Default e-mail domain
    */
    Ipadefaultemaildomain *string `json:"ipadefaultemaildomain,omitempty"`
  
    /*
Search time limit
Maximum amount of time (seconds) for a search (-1 or 0 is unlimited)
    */
    Ipasearchtimelimit *int `json:"ipasearchtimelimit,omitempty"`
  
    /*
Search size limit
Maximum number of records to search (-1 or 0 is unlimited)
    */
    Ipasearchrecordslimit *int `json:"ipasearchrecordslimit,omitempty"`
  
    /*
User search fields
A comma-separated list of fields to search in when searching for users
    */
    Ipausersearchfields *string `json:"ipausersearchfields,omitempty"`
  
    /*
Group search fields
A comma-separated list of fields to search in when searching for groups
    */
    Ipagroupsearchfields *string `json:"ipagroupsearchfields,omitempty"`
  
    /*
Enable migration mode
Enable migration mode
    */
    Ipamigrationenabled *bool `json:"ipamigrationenabled,omitempty"`
  
    /*
Default group objectclasses
Default group objectclasses (comma-separated list)
    */
    Ipagroupobjectclasses *[]string `json:"ipagroupobjectclasses,omitempty"`
  
    /*
Default user objectclasses
Default user objectclasses (comma-separated list)
    */
    Ipauserobjectclasses *[]string `json:"ipauserobjectclasses,omitempty"`
  
    /*
Password Expiration Notification (days)
Number of days's notice of impending password expiration
    */
    Ipapwdexpadvnotify *int `json:"ipapwdexpadvnotify,omitempty"`
  
    /*
Password plugin features
Extra hashes to generate in password plug-in
    */
    Ipaconfigstring *[]string `json:"ipaconfigstring,omitempty"`
  
    /*
SELinux user map order
Order in increasing priority of SELinux users, delimited by $
    */
    Ipaselinuxusermaporder *string `json:"ipaselinuxusermaporder,omitempty"`
  
    /*
Default SELinux user
Default SELinux user when no match is found in SELinux map rule
    */
    Ipaselinuxusermapdefault *string `json:"ipaselinuxusermapdefault,omitempty"`
  
    /*
Default PAC types
Default types of PAC supported for services
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Default user authentication types
Default types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
IPA CA renewal master
Renewal master for IPA certificate authority
    */
    CaRenewalMasterServer *string `json:"ca_renewal_master_server,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *string `json:"ipadomainresolutionorder,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type configModKwParams struct {
  *ConfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type configModResponse struct {
	Error  *Error      `json:"error"`
	Result *ConfigModResult `json:"result"`
}

type ConfigModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Config `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *ConfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ConfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ConfigModResult%v", string(b))
}

/*
Show the current configuration.
*/
func (c *Client) ConfigShow(
  reqArgs *ConfigShowArgs,
  optArgs *ConfigShowOptionalArgs, // can be nil
) (*ConfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := configShowKwParams{
    ConfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "config_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res configShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ConfigShowArgs struct {
  }

type ConfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type configShowKwParams struct {
  *ConfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type configShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ConfigShowResult `json:"result"`
}

type ConfigShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Config `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *ConfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ConfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ConfigShowResult%v", string(b))
}

/*

*/
func (c *Client) CosentryAdd(
  reqArgs *CosentryAddArgs,
  optArgs *CosentryAddOptionalArgs, // can be nil
) (*CosentryAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryAddKwParams{
    CosentryAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Krbpwdpolicyreference, reqArgs.Cospriority, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryAddArgs struct {
  
    /*


    */
    Cn string `json:"cn,omitempty"`
  
    /*


    */
    Krbpwdpolicyreference string `json:"krbpwdpolicyreference,omitempty"`
  
    /*


    */
    Cospriority int `json:"cospriority,omitempty"`
  }

type CosentryAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type cosentryAddKwParams struct {
  *CosentryAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryAddResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryAddResult `json:"result"`
}

type CosentryAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Cosentry `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CosentryAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryAddResult%v", string(b))
}

/*

*/
func (c *Client) CosentryDel(
  reqArgs *CosentryDelArgs,
  optArgs *CosentryDelOptionalArgs, // can be nil
) (*CosentryDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryDelKwParams{
    CosentryDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryDelArgs struct {
  
    /*


    */
    Cn []string `json:"cn,omitempty"`
  }

type CosentryDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type cosentryDelKwParams struct {
  *CosentryDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryDelResult `json:"result"`
}

type CosentryDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Cosentry `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CosentryDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryDelResult%v", string(b))
}

/*

*/
func (c *Client) CosentryFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CosentryFindArgs,
  optArgs *CosentryFindOptionalArgs, // can be nil
) (*CosentryFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryFindKwParams{
    CosentryFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryFindArgs struct {
  }

type CosentryFindOptionalArgs struct {
  
    /*


    */
    Cn *string `json:"cn,omitempty"`
  
    /*


    */
    Krbpwdpolicyreference *string `json:"krbpwdpolicyreference,omitempty"`
  
    /*


    */
    Cospriority *int `json:"cospriority,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("cn")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type cosentryFindKwParams struct {
  *CosentryFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryFindResult `json:"result"`
}

type CosentryFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Cosentry `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *CosentryFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryFindResult%v", string(b))
}

/*

*/
func (c *Client) CosentryMod(
  reqArgs *CosentryModArgs,
  optArgs *CosentryModOptionalArgs, // can be nil
) (*CosentryModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryModKwParams{
    CosentryModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryModArgs struct {
  
    /*


    */
    Cn string `json:"cn,omitempty"`
  }

type CosentryModOptionalArgs struct {
  
    /*


    */
    Krbpwdpolicyreference *string `json:"krbpwdpolicyreference,omitempty"`
  
    /*


    */
    Cospriority *int `json:"cospriority,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type cosentryModKwParams struct {
  *CosentryModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryModResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryModResult `json:"result"`
}

type CosentryModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Cosentry `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CosentryModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryModResult%v", string(b))
}

/*

*/
func (c *Client) CosentryShow(
  reqArgs *CosentryShowArgs,
  optArgs *CosentryShowOptionalArgs, // can be nil
) (*CosentryShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryShowKwParams{
    CosentryShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryShowArgs struct {
  
    /*


    */
    Cn string `json:"cn,omitempty"`
  }

type CosentryShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type cosentryShowKwParams struct {
  *CosentryShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryShowResult `json:"result"`
}

type CosentryShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Cosentry `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *CosentryShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryShowResult%v", string(b))
}

/*
Add a new delegation.
*/
func (c *Client) DelegationAdd(
  reqArgs *DelegationAddArgs,
  optArgs *DelegationAddOptionalArgs, // can be nil
) (*DelegationAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationAddKwParams{
    DelegationAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_add",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationAddArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type DelegationAddOptionalArgs struct {
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the delegation applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Member user group
User group to apply delegation to
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type delegationAddKwParams struct {
  *DelegationAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationAddResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationAddResult `json:"result"`
}

type DelegationAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Delegation `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DelegationAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationAddResult%v", string(b))
}

/*
Delete a delegation.
*/
func (c *Client) DelegationDel(
  reqArgs *DelegationDelArgs,
  optArgs *DelegationDelOptionalArgs, // can be nil
) (*DelegationDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationDelKwParams{
    DelegationDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_del",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationDelArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type DelegationDelOptionalArgs struct {
  }

type delegationDelKwParams struct {
  *DelegationDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationDelResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationDelResult `json:"result"`
}

type DelegationDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DelegationDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationDelResult%v", string(b))
}

/*
Search for delegations.
*/
func (c *Client) DelegationFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DelegationFindArgs,
  optArgs *DelegationFindOptionalArgs, // can be nil
) (*DelegationFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationFindKwParams{
    DelegationFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationFindArgs struct {
  }

type DelegationFindOptionalArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname *string `json:"aciname,omitempty"`
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the delegation applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Member user group
User group to apply delegation to
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type delegationFindKwParams struct {
  *DelegationFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationFindResult `json:"result"`
}

type DelegationFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Delegation `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *DelegationFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationFindResult%v", string(b))
}

/*
Modify a delegation.
*/
func (c *Client) DelegationMod(
  reqArgs *DelegationModArgs,
  optArgs *DelegationModOptionalArgs, // can be nil
) (*DelegationModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationModKwParams{
    DelegationModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationModArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type DelegationModOptionalArgs struct {
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the delegation applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Member user group
User group to apply delegation to
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type delegationModKwParams struct {
  *DelegationModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationModResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationModResult `json:"result"`
}

type DelegationModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Delegation `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DelegationModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationModResult%v", string(b))
}

/*
Display information about a delegation.
*/
func (c *Client) DelegationShow(
  reqArgs *DelegationShowArgs,
  optArgs *DelegationShowOptionalArgs, // can be nil
) (*DelegationShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationShowKwParams{
    DelegationShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_show",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationShowArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type DelegationShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type delegationShowKwParams struct {
  *DelegationShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationShowResult `json:"result"`
}

type DelegationShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Delegation `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DelegationShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationShowResult%v", string(b))
}

/*
Checks if any of the servers has the DNS service enabled.
*/
func (c *Client) DNSIsEnabled(
  reqArgs *DNSIsEnabledArgs,
  optArgs *DNSIsEnabledOptionalArgs, // can be nil
) (*DNSIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsIsEnabledKwParams{
    DNSIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dns_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DNSIsEnabledArgs struct {
  }

type DNSIsEnabledOptionalArgs struct {
  }

type dnsIsEnabledKwParams struct {
  *DNSIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *DNSIsEnabledResult `json:"result"`
}

type DNSIsEnabledResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *DNSIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DNSIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DNSIsEnabledResult%v", string(b))
}

/*
Resolve a host name in DNS. (Deprecated)
*/
func (c *Client) DNSResolve(
  reqArgs *DNSResolveArgs,
  optArgs *DNSResolveOptionalArgs, // can be nil
) (*DNSResolveResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsResolveKwParams{
    DNSResolveOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dns_resolve",
    Params: []interface{}{
      []interface{}{reqArgs.Hostname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsResolveResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DNSResolveArgs struct {
  
    /*
Hostname (FQDN)

    */
    Hostname string `json:"hostname,omitempty"`
  }

type DNSResolveOptionalArgs struct {
  }

type dnsResolveKwParams struct {
  *DNSResolveOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsResolveResponse struct {
	Error  *Error      `json:"error"`
	Result *DNSResolveResult `json:"result"`
}

type DNSResolveResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DNSResolveResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DNSResolveResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DNSResolveResult%v", string(b))
}

/*
Update location and IPA server DNS records
*/
func (c *Client) DNSUpdateSystemRecords(
  reqArgs *DNSUpdateSystemRecordsArgs,
  optArgs *DNSUpdateSystemRecordsOptionalArgs, // can be nil
) (*DNSUpdateSystemRecordsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsUpdateSystemRecordsKwParams{
    DNSUpdateSystemRecordsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dns_update_system_records",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsUpdateSystemRecordsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DNSUpdateSystemRecordsArgs struct {
  }

type DNSUpdateSystemRecordsOptionalArgs struct {
  
    /*
Dry run
Do not update records only return expected records
    */
    DryRun *bool `json:"dry_run,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsUpdateSystemRecordsKwParams struct {
  *DNSUpdateSystemRecordsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsUpdateSystemRecordsResponse struct {
	Error  *Error      `json:"error"`
	Result *DNSUpdateSystemRecordsResult `json:"result"`
}

type DNSUpdateSystemRecordsResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Result of the command
    (required)
    */
    Value IPAPrim[bool] `json:"value,omitempty"`
  }

func (t *DNSUpdateSystemRecordsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DNSUpdateSystemRecordsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DNSUpdateSystemRecordsResult%v", string(b))
}

/*
Modify global DNS configuration.
*/
func (c *Client) DnsconfigMod(
  reqArgs *DnsconfigModArgs,
  optArgs *DnsconfigModOptionalArgs, // can be nil
) (*DnsconfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsconfigModKwParams{
    DnsconfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsconfig_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsconfigModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsconfigModArgs struct {
  }

type DnsconfigModOptionalArgs struct {
  
    /*
Global forwarders
Global forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Global forwarding policy. Set to "none" to disable any configured global forwarders.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Zone refresh interval
An interval between regular polls of the name server for new DNS zones
    */
    Idnszonerefresh *int `json:"idnszonerefresh,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsconfigModKwParams struct {
  *DnsconfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsconfigModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsconfigModResult `json:"result"`
}

type DnsconfigModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsconfig `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *DnsconfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsconfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsconfigModResult%v", string(b))
}

/*
Show the current global DNS configuration.
*/
func (c *Client) DnsconfigShow(
  reqArgs *DnsconfigShowArgs,
  optArgs *DnsconfigShowOptionalArgs, // can be nil
) (*DnsconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsconfigShowKwParams{
    DnsconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsconfigShowArgs struct {
  }

type DnsconfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsconfigShowKwParams struct {
  *DnsconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsconfigShowResult `json:"result"`
}

type DnsconfigShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsconfig `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *DnsconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsconfigShowResult%v", string(b))
}

/*
Create new DNS forward zone.
*/
func (c *Client) DnsforwardzoneAdd(
  reqArgs *DnsforwardzoneAddArgs,
  optArgs *DnsforwardzoneAddOptionalArgs, // can be nil
) (*DnsforwardzoneAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneAddKwParams{
    DnsforwardzoneAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_add",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneAddArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnsforwardzoneAddOptionalArgs struct {
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Force DNS zone creation even if it will overlap with an existing zone.
    */
    SkipOverlapCheck *bool `json:"skip_overlap_check,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsforwardzoneAddKwParams struct {
  *DnsforwardzoneAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneAddResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneAddResult `json:"result"`
}

type DnsforwardzoneAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsforwardzone `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnsforwardzoneAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneAddResult%v", string(b))
}

/*
Add a permission for per-forward zone access delegation.
*/
func (c *Client) DnsforwardzoneAddPermission(
  reqArgs *DnsforwardzoneAddPermissionArgs,
  optArgs *DnsforwardzoneAddPermissionOptionalArgs, // can be nil
) (*DnsforwardzoneAddPermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneAddPermissionKwParams{
    DnsforwardzoneAddPermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_add_permission",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneAddPermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneAddPermissionArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnsforwardzoneAddPermissionOptionalArgs struct {
  }

type dnsforwardzoneAddPermissionKwParams struct {
  *DnsforwardzoneAddPermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneAddPermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneAddPermissionResult `json:"result"`
}

type DnsforwardzoneAddPermissionResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
Permission value
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DnsforwardzoneAddPermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneAddPermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneAddPermissionResult%v", string(b))
}

/*
Delete DNS forward zone.
*/
func (c *Client) DnsforwardzoneDel(
  reqArgs *DnsforwardzoneDelArgs,
  optArgs *DnsforwardzoneDelOptionalArgs, // can be nil
) (*DnsforwardzoneDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneDelKwParams{
    DnsforwardzoneDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_del",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneDelArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname []string `json:"idnsname,omitempty"`
  }

type DnsforwardzoneDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type dnsforwardzoneDelKwParams struct {
  *DnsforwardzoneDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneDelResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneDelResult `json:"result"`
}

type DnsforwardzoneDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Dnsforwardzone `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []DNSName `json:"value,omitempty"`
  }

func (t *DnsforwardzoneDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneDelResult%v", string(b))
}

/*
Disable DNS Forward Zone.
*/
func (c *Client) DnsforwardzoneDisable(
  reqArgs *DnsforwardzoneDisableArgs,
  optArgs *DnsforwardzoneDisableOptionalArgs, // can be nil
) (*DnsforwardzoneDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneDisableKwParams{
    DnsforwardzoneDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneDisableArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnsforwardzoneDisableOptionalArgs struct {
  }

type dnsforwardzoneDisableKwParams struct {
  *DnsforwardzoneDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneDisableResult `json:"result"`
}

type DnsforwardzoneDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnsforwardzoneDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneDisableResult%v", string(b))
}

/*
Enable DNS Forward Zone.
*/
func (c *Client) DnsforwardzoneEnable(
  reqArgs *DnsforwardzoneEnableArgs,
  optArgs *DnsforwardzoneEnableOptionalArgs, // can be nil
) (*DnsforwardzoneEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneEnableKwParams{
    DnsforwardzoneEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_enable",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneEnableArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnsforwardzoneEnableOptionalArgs struct {
  }

type dnsforwardzoneEnableKwParams struct {
  *DnsforwardzoneEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneEnableResult `json:"result"`
}

type DnsforwardzoneEnableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnsforwardzoneEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneEnableResult%v", string(b))
}

/*
Search for DNS forward zones.
*/
func (c *Client) DnsforwardzoneFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DnsforwardzoneFindArgs,
  optArgs *DnsforwardzoneFindOptionalArgs, // can be nil
) (*DnsforwardzoneFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneFindKwParams{
    DnsforwardzoneFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneFindArgs struct {
  }

type DnsforwardzoneFindOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *string `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Active zone
Is zone active?
    */
    Idnszoneactive *bool `json:"idnszoneactive,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type dnsforwardzoneFindKwParams struct {
  *DnsforwardzoneFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneFindResult `json:"result"`
}

type DnsforwardzoneFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Dnsforwardzone `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *DnsforwardzoneFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneFindResult%v", string(b))
}

/*
Modify DNS forward zone.
*/
func (c *Client) DnsforwardzoneMod(
  reqArgs *DnsforwardzoneModArgs,
  optArgs *DnsforwardzoneModOptionalArgs, // can be nil
) (*DnsforwardzoneModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneModKwParams{
    DnsforwardzoneModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneModArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnsforwardzoneModOptionalArgs struct {
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsforwardzoneModKwParams struct {
  *DnsforwardzoneModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneModResult `json:"result"`
}

type DnsforwardzoneModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsforwardzone `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnsforwardzoneModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneModResult%v", string(b))
}

/*
Remove a permission for per-forward zone access delegation.
*/
func (c *Client) DnsforwardzoneRemovePermission(
  reqArgs *DnsforwardzoneRemovePermissionArgs,
  optArgs *DnsforwardzoneRemovePermissionOptionalArgs, // can be nil
) (*DnsforwardzoneRemovePermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneRemovePermissionKwParams{
    DnsforwardzoneRemovePermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_remove_permission",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneRemovePermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneRemovePermissionArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnsforwardzoneRemovePermissionOptionalArgs struct {
  }

type dnsforwardzoneRemovePermissionKwParams struct {
  *DnsforwardzoneRemovePermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneRemovePermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneRemovePermissionResult `json:"result"`
}

type DnsforwardzoneRemovePermissionResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
Permission value
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DnsforwardzoneRemovePermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneRemovePermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneRemovePermissionResult%v", string(b))
}

/*
Display information about a DNS forward zone.
*/
func (c *Client) DnsforwardzoneShow(
  reqArgs *DnsforwardzoneShowArgs,
  optArgs *DnsforwardzoneShowOptionalArgs, // can be nil
) (*DnsforwardzoneShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneShowKwParams{
    DnsforwardzoneShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_show",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneShowArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnsforwardzoneShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsforwardzoneShowKwParams struct {
  *DnsforwardzoneShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneShowResult `json:"result"`
}

type DnsforwardzoneShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsforwardzone `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnsforwardzoneShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneShowResult%v", string(b))
}

/*
Add new DNS resource record.
*/
func (c *Client) DnsrecordAdd(
  reqArgs *DnsrecordAddArgs,
  optArgs *DnsrecordAddOptionalArgs, // can be nil
) (*DnsrecordAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordAddKwParams{
    DnsrecordAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_add",
    Params: []interface{}{
      []interface{}{reqArgs.Dnszoneidnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordAddArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname string `json:"dnszoneidnsname,omitempty"`
  }

type DnsrecordAddOptionalArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname *string `json:"idnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]string `json:"arecord,omitempty"`
  
    /*
A IP Address

    */
    APartIPAddress *string `json:"a_part_ip_address,omitempty"`
  
    /*
A Create reverse
Create reverse record for this IP Address
    */
    AExtraCreateReverse *bool `json:"a_extra_create_reverse,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]string `json:"aaaarecord,omitempty"`
  
    /*
AAAA IP Address

    */
    AaaaPartIPAddress *string `json:"aaaa_part_ip_address,omitempty"`
  
    /*
AAAA Create reverse
Create reverse record for this IP Address
    */
    AaaaExtraCreateReverse *bool `json:"aaaa_extra_create_reverse,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]string `json:"a6record,omitempty"`
  
    /*
A6 Record data

    */
    A6PartData *string `json:"a6_part_data,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]string `json:"afsdbrecord,omitempty"`
  
    /*
AFSDB Subtype

    */
    AfsdbPartSubtype *int `json:"afsdb_part_subtype,omitempty"`
  
    /*
AFSDB Hostname

    */
    AfsdbPartHostname *string `json:"afsdb_part_hostname,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]string `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]string `json:"certrecord,omitempty"`
  
    /*
CERT Certificate Type

    */
    CertPartType *int `json:"cert_part_type,omitempty"`
  
    /*
CERT Key Tag

    */
    CertPartKeyTag *int `json:"cert_part_key_tag,omitempty"`
  
    /*
CERT Algorithm

    */
    CertPartAlgorithm *int `json:"cert_part_algorithm,omitempty"`
  
    /*
CERT Certificate/CRL

    */
    CertPartCertificateOrCrl *string `json:"cert_part_certificate_or_crl,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]string `json:"cnamerecord,omitempty"`
  
    /*
CNAME Hostname
A hostname which this alias hostname points to
    */
    CnamePartHostname *string `json:"cname_part_hostname,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]string `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]string `json:"dlvrecord,omitempty"`
  
    /*
DLV Key Tag

    */
    DlvPartKeyTag *int `json:"dlv_part_key_tag,omitempty"`
  
    /*
DLV Algorithm

    */
    DlvPartAlgorithm *int `json:"dlv_part_algorithm,omitempty"`
  
    /*
DLV Digest Type

    */
    DlvPartDigestType *int `json:"dlv_part_digest_type,omitempty"`
  
    /*
DLV Digest

    */
    DlvPartDigest *string `json:"dlv_part_digest,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]string `json:"dnamerecord,omitempty"`
  
    /*
DNAME Target

    */
    DnamePartTarget *string `json:"dname_part_target,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]string `json:"dsrecord,omitempty"`
  
    /*
DS Key Tag

    */
    DsPartKeyTag *int `json:"ds_part_key_tag,omitempty"`
  
    /*
DS Algorithm

    */
    DsPartAlgorithm *int `json:"ds_part_algorithm,omitempty"`
  
    /*
DS Digest Type

    */
    DsPartDigestType *int `json:"ds_part_digest_type,omitempty"`
  
    /*
DS Digest

    */
    DsPartDigest *string `json:"ds_part_digest,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]string `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]string `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]string `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]string `json:"kxrecord,omitempty"`
  
    /*
KX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    KxPartPreference *int `json:"kx_part_preference,omitempty"`
  
    /*
KX Exchanger
A host willing to act as a key exchanger
    */
    KxPartExchanger *string `json:"kx_part_exchanger,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]string `json:"locrecord,omitempty"`
  
    /*
LOC Degrees Latitude

    */
    LocPartLatDeg *int `json:"loc_part_lat_deg,omitempty"`
  
    /*
LOC Minutes Latitude

    */
    LocPartLatMin *int `json:"loc_part_lat_min,omitempty"`
  
    /*
LOC Seconds Latitude

    */
    LocPartLatSec *float64 `json:"loc_part_lat_sec,omitempty"`
  
    /*
LOC Direction Latitude

    */
    LocPartLatDir *string `json:"loc_part_lat_dir,omitempty"`
  
    /*
LOC Degrees Longitude

    */
    LocPartLonDeg *int `json:"loc_part_lon_deg,omitempty"`
  
    /*
LOC Minutes Longitude

    */
    LocPartLonMin *int `json:"loc_part_lon_min,omitempty"`
  
    /*
LOC Seconds Longitude

    */
    LocPartLonSec *float64 `json:"loc_part_lon_sec,omitempty"`
  
    /*
LOC Direction Longitude

    */
    LocPartLonDir *string `json:"loc_part_lon_dir,omitempty"`
  
    /*
LOC Altitude

    */
    LocPartAltitude *float64 `json:"loc_part_altitude,omitempty"`
  
    /*
LOC Size

    */
    LocPartSize *float64 `json:"loc_part_size,omitempty"`
  
    /*
LOC Horizontal Precision

    */
    LocPartHPrecision *float64 `json:"loc_part_h_precision,omitempty"`
  
    /*
LOC Vertical Precision

    */
    LocPartVPrecision *float64 `json:"loc_part_v_precision,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]string `json:"mxrecord,omitempty"`
  
    /*
MX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    MxPartPreference *int `json:"mx_part_preference,omitempty"`
  
    /*
MX Exchanger
A host willing to act as a mail exchanger
    */
    MxPartExchanger *string `json:"mx_part_exchanger,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]string `json:"naptrrecord,omitempty"`
  
    /*
NAPTR Order

    */
    NaptrPartOrder *int `json:"naptr_part_order,omitempty"`
  
    /*
NAPTR Preference

    */
    NaptrPartPreference *int `json:"naptr_part_preference,omitempty"`
  
    /*
NAPTR Flags

    */
    NaptrPartFlags *string `json:"naptr_part_flags,omitempty"`
  
    /*
NAPTR Service

    */
    NaptrPartService *string `json:"naptr_part_service,omitempty"`
  
    /*
NAPTR Regular Expression

    */
    NaptrPartRegexp *string `json:"naptr_part_regexp,omitempty"`
  
    /*
NAPTR Replacement

    */
    NaptrPartReplacement *string `json:"naptr_part_replacement,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]string `json:"nsrecord,omitempty"`
  
    /*
NS Hostname

    */
    NsPartHostname *string `json:"ns_part_hostname,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]string `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]string `json:"ptrrecord,omitempty"`
  
    /*
PTR Hostname
The hostname this reverse record points to
    */
    PtrPartHostname *string `json:"ptr_part_hostname,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]string `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]string `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]string `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]string `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]string `json:"srvrecord,omitempty"`
  
    /*
SRV Priority (order)
Lower number means higher priority. Clients will attempt to contact the server with the lowest-numbered priority they can reach.
    */
    SrvPartPriority *int `json:"srv_part_priority,omitempty"`
  
    /*
SRV Weight
Relative weight for entries with the same priority.
    */
    SrvPartWeight *int `json:"srv_part_weight,omitempty"`
  
    /*
SRV Port

    */
    SrvPartPort *int `json:"srv_part_port,omitempty"`
  
    /*
SRV Target
The domain name of the target host or '.' if the service is decidedly not available at this domain
    */
    SrvPartTarget *string `json:"srv_part_target,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]string `json:"sshfprecord,omitempty"`
  
    /*
SSHFP Algorithm

    */
    SshfpPartAlgorithm *int `json:"sshfp_part_algorithm,omitempty"`
  
    /*
SSHFP Fingerprint Type

    */
    SshfpPartFpType *int `json:"sshfp_part_fp_type,omitempty"`
  
    /*
SSHFP Fingerprint

    */
    SshfpPartFingerprint *string `json:"sshfp_part_fingerprint,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]string `json:"tlsarecord,omitempty"`
  
    /*
TLSA Certificate Usage

    */
    TlsaPartCertUsage *int `json:"tlsa_part_cert_usage,omitempty"`
  
    /*
TLSA Selector

    */
    TlsaPartSelector *int `json:"tlsa_part_selector,omitempty"`
  
    /*
TLSA Matching Type

    */
    TlsaPartMatchingType *int `json:"tlsa_part_matching_type,omitempty"`
  
    /*
TLSA Certificate Association Data

    */
    TlsaPartCertAssociationData *string `json:"tlsa_part_cert_association_data,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]string `json:"txtrecord,omitempty"`
  
    /*
TXT Text Data

    */
    TxtPartData *string `json:"txt_part_data,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]string `json:"urirecord,omitempty"`
  
    /*
URI Priority (order)
Lower number means higher priority. Clients will attempt to contact the URI with the lowest-numbered priority they can reach.
    */
    URIPartPriority *int `json:"uri_part_priority,omitempty"`
  
    /*
URI Weight
Relative weight for entries with the same priority.
    */
    URIPartWeight *int `json:"uri_part_weight,omitempty"`
  
    /*
URI Target Uniform Resource Identifier
Target Uniform Resource Identifier according to RFC 3986
    */
    URIPartTarget *string `json:"uri_part_target,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Force
force NS record creation even if its hostname is not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsrecordAddKwParams struct {
  *DnsrecordAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordAddResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordAddResult `json:"result"`
}

type DnsrecordAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsrecord `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnsrecordAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordAddResult%v", string(b))
}

/*
Delete DNS resource record.
*/
func (c *Client) DnsrecordDel(
  reqArgs *DnsrecordDelArgs,
  optArgs *DnsrecordDelOptionalArgs, // can be nil
) (*DnsrecordDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordDelKwParams{
    DnsrecordDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_del",
    Params: []interface{}{
      []interface{}{reqArgs.Dnszoneidnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordDelArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname string `json:"dnszoneidnsname,omitempty"`
  }

type DnsrecordDelOptionalArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname *string `json:"idnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]string `json:"arecord,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]string `json:"aaaarecord,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]string `json:"a6record,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]string `json:"afsdbrecord,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]string `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]string `json:"certrecord,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]string `json:"cnamerecord,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]string `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]string `json:"dlvrecord,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]string `json:"dnamerecord,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]string `json:"dsrecord,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]string `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]string `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]string `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]string `json:"kxrecord,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]string `json:"locrecord,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]string `json:"mxrecord,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]string `json:"naptrrecord,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]string `json:"nsrecord,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]string `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]string `json:"ptrrecord,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]string `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]string `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]string `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]string `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]string `json:"srvrecord,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]string `json:"sshfprecord,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]string `json:"tlsarecord,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]string `json:"txtrecord,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]string `json:"urirecord,omitempty"`
  
    /*
Delete all associated records

    */
    DelAll *bool `json:"del_all,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*


    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsrecordDelKwParams struct {
  *DnsrecordDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordDelResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordDelResult `json:"result"`
}

type DnsrecordDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Dnsrecord `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []DNSName `json:"value,omitempty"`
  }

func (t *DnsrecordDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordDelResult%v", string(b))
}

/*
Delete DNS record entry.
*/
func (c *Client) DnsrecordDelentry(
  reqArgs *DnsrecordDelentryArgs,
  optArgs *DnsrecordDelentryOptionalArgs, // can be nil
) (*DnsrecordDelentryResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordDelentryKwParams{
    DnsrecordDelentryOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_delentry",
    Params: []interface{}{
      []interface{}{reqArgs.Dnszoneidnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordDelentryResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordDelentryArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname string `json:"dnszoneidnsname,omitempty"`
  }

type DnsrecordDelentryOptionalArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname *[]string `json:"idnsname,omitempty"`
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type dnsrecordDelentryKwParams struct {
  *DnsrecordDelentryOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordDelentryResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordDelentryResult `json:"result"`
}

type DnsrecordDelentryResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []DNSName `json:"value,omitempty"`
  }

func (t *DnsrecordDelentryResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordDelentryResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordDelentryResult%v", string(b))
}

/*
Search for DNS resources.
*/
func (c *Client) DnsrecordFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DnsrecordFindArgs,
  optArgs *DnsrecordFindOptionalArgs, // can be nil
) (*DnsrecordFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordFindKwParams{
    DnsrecordFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_find",
    Params: []interface{}{
      []interface{}{reqArgs.Dnszoneidnsname, criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordFindArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname string `json:"dnszoneidnsname,omitempty"`
  }

type DnsrecordFindOptionalArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname *string `json:"idnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]string `json:"arecord,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]string `json:"aaaarecord,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]string `json:"a6record,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]string `json:"afsdbrecord,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]string `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]string `json:"certrecord,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]string `json:"cnamerecord,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]string `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]string `json:"dlvrecord,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]string `json:"dnamerecord,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]string `json:"dsrecord,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]string `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]string `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]string `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]string `json:"kxrecord,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]string `json:"locrecord,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]string `json:"mxrecord,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]string `json:"naptrrecord,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]string `json:"nsrecord,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]string `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]string `json:"ptrrecord,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]string `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]string `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]string `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]string `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]string `json:"srvrecord,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]string `json:"sshfprecord,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]string `json:"tlsarecord,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]string `json:"txtrecord,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]string `json:"urirecord,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type dnsrecordFindKwParams struct {
  *DnsrecordFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordFindResult `json:"result"`
}

type DnsrecordFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Dnsrecord `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *DnsrecordFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordFindResult%v", string(b))
}

/*
Modify a DNS resource record.
*/
func (c *Client) DnsrecordMod(
  reqArgs *DnsrecordModArgs,
  optArgs *DnsrecordModOptionalArgs, // can be nil
) (*DnsrecordModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordModKwParams{
    DnsrecordModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Dnszoneidnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordModArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname string `json:"dnszoneidnsname,omitempty"`
  }

type DnsrecordModOptionalArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname *string `json:"idnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]string `json:"arecord,omitempty"`
  
    /*
A IP Address

    */
    APartIPAddress *string `json:"a_part_ip_address,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]string `json:"aaaarecord,omitempty"`
  
    /*
AAAA IP Address

    */
    AaaaPartIPAddress *string `json:"aaaa_part_ip_address,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]string `json:"a6record,omitempty"`
  
    /*
A6 Record data

    */
    A6PartData *string `json:"a6_part_data,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]string `json:"afsdbrecord,omitempty"`
  
    /*
AFSDB Subtype

    */
    AfsdbPartSubtype *int `json:"afsdb_part_subtype,omitempty"`
  
    /*
AFSDB Hostname

    */
    AfsdbPartHostname *string `json:"afsdb_part_hostname,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]string `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]string `json:"certrecord,omitempty"`
  
    /*
CERT Certificate Type

    */
    CertPartType *int `json:"cert_part_type,omitempty"`
  
    /*
CERT Key Tag

    */
    CertPartKeyTag *int `json:"cert_part_key_tag,omitempty"`
  
    /*
CERT Algorithm

    */
    CertPartAlgorithm *int `json:"cert_part_algorithm,omitempty"`
  
    /*
CERT Certificate/CRL

    */
    CertPartCertificateOrCrl *string `json:"cert_part_certificate_or_crl,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]string `json:"cnamerecord,omitempty"`
  
    /*
CNAME Hostname
A hostname which this alias hostname points to
    */
    CnamePartHostname *string `json:"cname_part_hostname,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]string `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]string `json:"dlvrecord,omitempty"`
  
    /*
DLV Key Tag

    */
    DlvPartKeyTag *int `json:"dlv_part_key_tag,omitempty"`
  
    /*
DLV Algorithm

    */
    DlvPartAlgorithm *int `json:"dlv_part_algorithm,omitempty"`
  
    /*
DLV Digest Type

    */
    DlvPartDigestType *int `json:"dlv_part_digest_type,omitempty"`
  
    /*
DLV Digest

    */
    DlvPartDigest *string `json:"dlv_part_digest,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]string `json:"dnamerecord,omitempty"`
  
    /*
DNAME Target

    */
    DnamePartTarget *string `json:"dname_part_target,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]string `json:"dsrecord,omitempty"`
  
    /*
DS Key Tag

    */
    DsPartKeyTag *int `json:"ds_part_key_tag,omitempty"`
  
    /*
DS Algorithm

    */
    DsPartAlgorithm *int `json:"ds_part_algorithm,omitempty"`
  
    /*
DS Digest Type

    */
    DsPartDigestType *int `json:"ds_part_digest_type,omitempty"`
  
    /*
DS Digest

    */
    DsPartDigest *string `json:"ds_part_digest,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]string `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]string `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]string `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]string `json:"kxrecord,omitempty"`
  
    /*
KX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    KxPartPreference *int `json:"kx_part_preference,omitempty"`
  
    /*
KX Exchanger
A host willing to act as a key exchanger
    */
    KxPartExchanger *string `json:"kx_part_exchanger,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]string `json:"locrecord,omitempty"`
  
    /*
LOC Degrees Latitude

    */
    LocPartLatDeg *int `json:"loc_part_lat_deg,omitempty"`
  
    /*
LOC Minutes Latitude

    */
    LocPartLatMin *int `json:"loc_part_lat_min,omitempty"`
  
    /*
LOC Seconds Latitude

    */
    LocPartLatSec *float64 `json:"loc_part_lat_sec,omitempty"`
  
    /*
LOC Direction Latitude

    */
    LocPartLatDir *string `json:"loc_part_lat_dir,omitempty"`
  
    /*
LOC Degrees Longitude

    */
    LocPartLonDeg *int `json:"loc_part_lon_deg,omitempty"`
  
    /*
LOC Minutes Longitude

    */
    LocPartLonMin *int `json:"loc_part_lon_min,omitempty"`
  
    /*
LOC Seconds Longitude

    */
    LocPartLonSec *float64 `json:"loc_part_lon_sec,omitempty"`
  
    /*
LOC Direction Longitude

    */
    LocPartLonDir *string `json:"loc_part_lon_dir,omitempty"`
  
    /*
LOC Altitude

    */
    LocPartAltitude *float64 `json:"loc_part_altitude,omitempty"`
  
    /*
LOC Size

    */
    LocPartSize *float64 `json:"loc_part_size,omitempty"`
  
    /*
LOC Horizontal Precision

    */
    LocPartHPrecision *float64 `json:"loc_part_h_precision,omitempty"`
  
    /*
LOC Vertical Precision

    */
    LocPartVPrecision *float64 `json:"loc_part_v_precision,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]string `json:"mxrecord,omitempty"`
  
    /*
MX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    MxPartPreference *int `json:"mx_part_preference,omitempty"`
  
    /*
MX Exchanger
A host willing to act as a mail exchanger
    */
    MxPartExchanger *string `json:"mx_part_exchanger,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]string `json:"naptrrecord,omitempty"`
  
    /*
NAPTR Order

    */
    NaptrPartOrder *int `json:"naptr_part_order,omitempty"`
  
    /*
NAPTR Preference

    */
    NaptrPartPreference *int `json:"naptr_part_preference,omitempty"`
  
    /*
NAPTR Flags

    */
    NaptrPartFlags *string `json:"naptr_part_flags,omitempty"`
  
    /*
NAPTR Service

    */
    NaptrPartService *string `json:"naptr_part_service,omitempty"`
  
    /*
NAPTR Regular Expression

    */
    NaptrPartRegexp *string `json:"naptr_part_regexp,omitempty"`
  
    /*
NAPTR Replacement

    */
    NaptrPartReplacement *string `json:"naptr_part_replacement,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]string `json:"nsrecord,omitempty"`
  
    /*
NS Hostname

    */
    NsPartHostname *string `json:"ns_part_hostname,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]string `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]string `json:"ptrrecord,omitempty"`
  
    /*
PTR Hostname
The hostname this reverse record points to
    */
    PtrPartHostname *string `json:"ptr_part_hostname,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]string `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]string `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]string `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]string `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]string `json:"srvrecord,omitempty"`
  
    /*
SRV Priority (order)
Lower number means higher priority. Clients will attempt to contact the server with the lowest-numbered priority they can reach.
    */
    SrvPartPriority *int `json:"srv_part_priority,omitempty"`
  
    /*
SRV Weight
Relative weight for entries with the same priority.
    */
    SrvPartWeight *int `json:"srv_part_weight,omitempty"`
  
    /*
SRV Port

    */
    SrvPartPort *int `json:"srv_part_port,omitempty"`
  
    /*
SRV Target
The domain name of the target host or '.' if the service is decidedly not available at this domain
    */
    SrvPartTarget *string `json:"srv_part_target,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]string `json:"sshfprecord,omitempty"`
  
    /*
SSHFP Algorithm

    */
    SshfpPartAlgorithm *int `json:"sshfp_part_algorithm,omitempty"`
  
    /*
SSHFP Fingerprint Type

    */
    SshfpPartFpType *int `json:"sshfp_part_fp_type,omitempty"`
  
    /*
SSHFP Fingerprint

    */
    SshfpPartFingerprint *string `json:"sshfp_part_fingerprint,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]string `json:"tlsarecord,omitempty"`
  
    /*
TLSA Certificate Usage

    */
    TlsaPartCertUsage *int `json:"tlsa_part_cert_usage,omitempty"`
  
    /*
TLSA Selector

    */
    TlsaPartSelector *int `json:"tlsa_part_selector,omitempty"`
  
    /*
TLSA Matching Type

    */
    TlsaPartMatchingType *int `json:"tlsa_part_matching_type,omitempty"`
  
    /*
TLSA Certificate Association Data

    */
    TlsaPartCertAssociationData *string `json:"tlsa_part_cert_association_data,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]string `json:"txtrecord,omitempty"`
  
    /*
TXT Text Data

    */
    TxtPartData *string `json:"txt_part_data,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]string `json:"urirecord,omitempty"`
  
    /*
URI Priority (order)
Lower number means higher priority. Clients will attempt to contact the URI with the lowest-numbered priority they can reach.
    */
    URIPartPriority *int `json:"uri_part_priority,omitempty"`
  
    /*
URI Weight
Relative weight for entries with the same priority.
    */
    URIPartWeight *int `json:"uri_part_weight,omitempty"`
  
    /*
URI Target Uniform Resource Identifier
Target Uniform Resource Identifier according to RFC 3986
    */
    URIPartTarget *string `json:"uri_part_target,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the DNS resource record object
    */
    Rename *string `json:"rename,omitempty"`
  }

type dnsrecordModKwParams struct {
  *DnsrecordModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordModResult `json:"result"`
}

type DnsrecordModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsrecord `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnsrecordModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordModResult%v", string(b))
}

/*
Display DNS resource.
*/
func (c *Client) DnsrecordShow(
  reqArgs *DnsrecordShowArgs,
  optArgs *DnsrecordShowOptionalArgs, // can be nil
) (*DnsrecordShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordShowKwParams{
    DnsrecordShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_show",
    Params: []interface{}{
      []interface{}{reqArgs.Dnszoneidnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordShowArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname string `json:"dnszoneidnsname,omitempty"`
  }

type DnsrecordShowOptionalArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname *string `json:"idnsname,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsrecordShowKwParams struct {
  *DnsrecordShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordShowResult `json:"result"`
}

type DnsrecordShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsrecord `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnsrecordShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordShowResult%v", string(b))
}

/*

*/
func (c *Client) DnsrecordSplitParts(
  reqArgs *DnsrecordSplitPartsArgs,
  optArgs *DnsrecordSplitPartsOptionalArgs, // can be nil
) (*DnsrecordSplitPartsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordSplitPartsKwParams{
    DnsrecordSplitPartsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_split_parts",
    Params: []interface{}{
      []interface{}{reqArgs.Name, reqArgs.Value, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordSplitPartsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordSplitPartsArgs struct {
  
    /*


    */
    Name string `json:"name,omitempty"`
  
    /*


    */
    Value string `json:"value,omitempty"`
  }

type DnsrecordSplitPartsOptionalArgs struct {
  }

type dnsrecordSplitPartsKwParams struct {
  *DnsrecordSplitPartsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordSplitPartsResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordSplitPartsResult `json:"result"`
}

type DnsrecordSplitPartsResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *DnsrecordSplitPartsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordSplitPartsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordSplitPartsResult%v", string(b))
}

/*
Search for DNS servers.
*/
func (c *Client) DnsserverFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DnsserverFindArgs,
  optArgs *DnsserverFindOptionalArgs, // can be nil
) (*DnsserverFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsserverFindKwParams{
    DnsserverFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsserver_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsserverFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsserverFindArgs struct {
  }

type DnsserverFindOptionalArgs struct {
  
    /*
Server name
DNS Server name
    */
    Idnsserverid *string `json:"idnsserverid,omitempty"`
  
    /*
SOA mname override
SOA mname (authoritative server) override
    */
    Idnssoamname *string `json:"idnssoamname,omitempty"`
  
    /*
Forwarders
Per-server forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-server conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("hostname")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type dnsserverFindKwParams struct {
  *DnsserverFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsserverFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsserverFindResult `json:"result"`
}

type DnsserverFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Dnsserver `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *DnsserverFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsserverFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsserverFindResult%v", string(b))
}

/*
Modify DNS server configuration
*/
func (c *Client) DnsserverMod(
  reqArgs *DnsserverModArgs,
  optArgs *DnsserverModOptionalArgs, // can be nil
) (*DnsserverModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsserverModKwParams{
    DnsserverModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsserver_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsserverid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsserverModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsserverModArgs struct {
  
    /*
Server name
DNS Server name
    */
    Idnsserverid string `json:"idnsserverid,omitempty"`
  }

type DnsserverModOptionalArgs struct {
  
    /*
SOA mname override
SOA mname (authoritative server) override
    */
    Idnssoamname *string `json:"idnssoamname,omitempty"`
  
    /*
Forwarders
Per-server forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-server conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsserverModKwParams struct {
  *DnsserverModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsserverModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsserverModResult `json:"result"`
}

type DnsserverModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsserver `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DnsserverModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsserverModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsserverModResult%v", string(b))
}

/*
Display configuration of a DNS server.
*/
func (c *Client) DnsserverShow(
  reqArgs *DnsserverShowArgs,
  optArgs *DnsserverShowOptionalArgs, // can be nil
) (*DnsserverShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsserverShowKwParams{
    DnsserverShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsserver_show",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsserverid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsserverShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsserverShowArgs struct {
  
    /*
Server name
DNS Server name
    */
    Idnsserverid string `json:"idnsserverid,omitempty"`
  }

type DnsserverShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsserverShowKwParams struct {
  *DnsserverShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsserverShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsserverShowResult `json:"result"`
}

type DnsserverShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnsserver `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DnsserverShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsserverShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsserverShowResult%v", string(b))
}

/*
Create new DNS zone (SOA record).
*/
func (c *Client) DnszoneAdd(
  reqArgs *DnszoneAddArgs,
  optArgs *DnszoneAddOptionalArgs, // can be nil
) (*DnszoneAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneAddKwParams{
    DnszoneAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_add",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneAddArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnszoneAddOptionalArgs struct {
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Authoritative nameserver
Authoritative nameserver domain name
    */
    Idnssoamname *string `json:"idnssoamname,omitempty"`
  
    /*
Administrator e-mail address
Administrator e-mail address
    */
    Idnssoarname *string `json:"idnssoarname,omitempty"`
  
    /*
SOA serial
SOA record serial number
    */
    Idnssoaserial *int `json:"idnssoaserial,omitempty"`
  
    /*
SOA refresh
SOA record refresh time
    */
    Idnssoarefresh *int `json:"idnssoarefresh,omitempty"`
  
    /*
SOA retry
SOA record retry time
    */
    Idnssoaretry *int `json:"idnssoaretry,omitempty"`
  
    /*
SOA expire
SOA record expire time
    */
    Idnssoaexpire *int `json:"idnssoaexpire,omitempty"`
  
    /*
SOA minimum
How long should negative responses be cached
    */
    Idnssoaminimum *int `json:"idnssoaminimum,omitempty"`
  
    /*
Time to live
Time to live for records at zone apex
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*
Default time to live
Time to live for records without explicit TTL definition
    */
    Dnsdefaultttl *int `json:"dnsdefaultttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
BIND update policy
BIND update policy
    */
    Idnsupdatepolicy *string `json:"idnsupdatepolicy,omitempty"`
  
    /*
Dynamic update
Allow dynamic updates.
    */
    Idnsallowdynupdate *bool `json:"idnsallowdynupdate,omitempty"`
  
    /*
Allow query
Semicolon separated list of IP addresses or networks which are allowed to issue queries
    */
    Idnsallowquery *string `json:"idnsallowquery,omitempty"`
  
    /*
Allow transfer
Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
    */
    Idnsallowtransfer *string `json:"idnsallowtransfer,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Allow in-line DNSSEC signing
Allow inline DNSSEC signing of records in the zone
    */
    Idnssecinlinesigning *bool `json:"idnssecinlinesigning,omitempty"`
  
    /*
NSEC3PARAM record
NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
    */
    Nsec3paramrecord *string `json:"nsec3paramrecord,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Force DNS zone creation even if it will overlap with an existing zone.
    */
    SkipOverlapCheck *bool `json:"skip_overlap_check,omitempty"`
  
    /*

Force DNS zone creation even if nameserver is not resolvable. (Deprecated)
    */
    Force *bool `json:"force,omitempty"`
  
    /*

Force DNS zone creation even if nameserver is not resolvable.
    */
    SkipNameserverCheck *bool `json:"skip_nameserver_check,omitempty"`
  
    /*


    */
    IPAddress *string `json:"ip_address,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnszoneAddKwParams struct {
  *DnszoneAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneAddResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneAddResult `json:"result"`
}

type DnszoneAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnszone `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnszoneAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneAddResult%v", string(b))
}

/*
Add a permission for per-zone access delegation.
*/
func (c *Client) DnszoneAddPermission(
  reqArgs *DnszoneAddPermissionArgs,
  optArgs *DnszoneAddPermissionOptionalArgs, // can be nil
) (*DnszoneAddPermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneAddPermissionKwParams{
    DnszoneAddPermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_add_permission",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneAddPermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneAddPermissionArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnszoneAddPermissionOptionalArgs struct {
  }

type dnszoneAddPermissionKwParams struct {
  *DnszoneAddPermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneAddPermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneAddPermissionResult `json:"result"`
}

type DnszoneAddPermissionResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
Permission value
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DnszoneAddPermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneAddPermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneAddPermissionResult%v", string(b))
}

/*
Delete DNS zone (SOA record).
*/
func (c *Client) DnszoneDel(
  reqArgs *DnszoneDelArgs,
  optArgs *DnszoneDelOptionalArgs, // can be nil
) (*DnszoneDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneDelKwParams{
    DnszoneDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_del",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneDelArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname []string `json:"idnsname,omitempty"`
  }

type DnszoneDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type dnszoneDelKwParams struct {
  *DnszoneDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneDelResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneDelResult `json:"result"`
}

type DnszoneDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Dnszone `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []DNSName `json:"value,omitempty"`
  }

func (t *DnszoneDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneDelResult%v", string(b))
}

/*
Disable DNS Zone.
*/
func (c *Client) DnszoneDisable(
  reqArgs *DnszoneDisableArgs,
  optArgs *DnszoneDisableOptionalArgs, // can be nil
) (*DnszoneDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneDisableKwParams{
    DnszoneDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneDisableArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnszoneDisableOptionalArgs struct {
  }

type dnszoneDisableKwParams struct {
  *DnszoneDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneDisableResult `json:"result"`
}

type DnszoneDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnszoneDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneDisableResult%v", string(b))
}

/*
Enable DNS Zone.
*/
func (c *Client) DnszoneEnable(
  reqArgs *DnszoneEnableArgs,
  optArgs *DnszoneEnableOptionalArgs, // can be nil
) (*DnszoneEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneEnableKwParams{
    DnszoneEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_enable",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneEnableArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnszoneEnableOptionalArgs struct {
  }

type dnszoneEnableKwParams struct {
  *DnszoneEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneEnableResult `json:"result"`
}

type DnszoneEnableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnszoneEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneEnableResult%v", string(b))
}

/*
Search for DNS zones (SOA records).
*/
func (c *Client) DnszoneFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DnszoneFindArgs,
  optArgs *DnszoneFindOptionalArgs, // can be nil
) (*DnszoneFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneFindKwParams{
    DnszoneFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneFindArgs struct {
  }

type DnszoneFindOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *string `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Active zone
Is zone active?
    */
    Idnszoneactive *bool `json:"idnszoneactive,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Authoritative nameserver
Authoritative nameserver domain name
    */
    Idnssoamname *string `json:"idnssoamname,omitempty"`
  
    /*
Administrator e-mail address
Administrator e-mail address
    */
    Idnssoarname *string `json:"idnssoarname,omitempty"`
  
    /*
SOA serial
SOA record serial number
    */
    Idnssoaserial *int `json:"idnssoaserial,omitempty"`
  
    /*
SOA refresh
SOA record refresh time
    */
    Idnssoarefresh *int `json:"idnssoarefresh,omitempty"`
  
    /*
SOA retry
SOA record retry time
    */
    Idnssoaretry *int `json:"idnssoaretry,omitempty"`
  
    /*
SOA expire
SOA record expire time
    */
    Idnssoaexpire *int `json:"idnssoaexpire,omitempty"`
  
    /*
SOA minimum
How long should negative responses be cached
    */
    Idnssoaminimum *int `json:"idnssoaminimum,omitempty"`
  
    /*
Time to live
Time to live for records at zone apex
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*
Default time to live
Time to live for records without explicit TTL definition
    */
    Dnsdefaultttl *int `json:"dnsdefaultttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
BIND update policy
BIND update policy
    */
    Idnsupdatepolicy *string `json:"idnsupdatepolicy,omitempty"`
  
    /*
Dynamic update
Allow dynamic updates.
    */
    Idnsallowdynupdate *bool `json:"idnsallowdynupdate,omitempty"`
  
    /*
Allow query
Semicolon separated list of IP addresses or networks which are allowed to issue queries
    */
    Idnsallowquery *string `json:"idnsallowquery,omitempty"`
  
    /*
Allow transfer
Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
    */
    Idnsallowtransfer *string `json:"idnsallowtransfer,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Allow in-line DNSSEC signing
Allow inline DNSSEC signing of records in the zone
    */
    Idnssecinlinesigning *bool `json:"idnssecinlinesigning,omitempty"`
  
    /*
NSEC3PARAM record
NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
    */
    Nsec3paramrecord *string `json:"nsec3paramrecord,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Forward zones only
Search for forward zones only
    */
    ForwardOnly *bool `json:"forward_only,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type dnszoneFindKwParams struct {
  *DnszoneFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneFindResult `json:"result"`
}

type DnszoneFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Dnszone `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *DnszoneFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneFindResult%v", string(b))
}

/*
Modify DNS zone (SOA record).
*/
func (c *Client) DnszoneMod(
  reqArgs *DnszoneModArgs,
  optArgs *DnszoneModOptionalArgs, // can be nil
) (*DnszoneModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneModKwParams{
    DnszoneModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneModArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnszoneModOptionalArgs struct {
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Authoritative nameserver
Authoritative nameserver domain name
    */
    Idnssoamname *string `json:"idnssoamname,omitempty"`
  
    /*
Administrator e-mail address
Administrator e-mail address
    */
    Idnssoarname *string `json:"idnssoarname,omitempty"`
  
    /*
SOA serial
SOA record serial number
    */
    Idnssoaserial *int `json:"idnssoaserial,omitempty"`
  
    /*
SOA refresh
SOA record refresh time
    */
    Idnssoarefresh *int `json:"idnssoarefresh,omitempty"`
  
    /*
SOA retry
SOA record retry time
    */
    Idnssoaretry *int `json:"idnssoaretry,omitempty"`
  
    /*
SOA expire
SOA record expire time
    */
    Idnssoaexpire *int `json:"idnssoaexpire,omitempty"`
  
    /*
SOA minimum
How long should negative responses be cached
    */
    Idnssoaminimum *int `json:"idnssoaminimum,omitempty"`
  
    /*
Time to live
Time to live for records at zone apex
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*
Default time to live
Time to live for records without explicit TTL definition
    */
    Dnsdefaultttl *int `json:"dnsdefaultttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
BIND update policy
BIND update policy
    */
    Idnsupdatepolicy *string `json:"idnsupdatepolicy,omitempty"`
  
    /*
Dynamic update
Allow dynamic updates.
    */
    Idnsallowdynupdate *bool `json:"idnsallowdynupdate,omitempty"`
  
    /*
Allow query
Semicolon separated list of IP addresses or networks which are allowed to issue queries
    */
    Idnsallowquery *string `json:"idnsallowquery,omitempty"`
  
    /*
Allow transfer
Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
    */
    Idnsallowtransfer *string `json:"idnsallowtransfer,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Allow in-line DNSSEC signing
Allow inline DNSSEC signing of records in the zone
    */
    Idnssecinlinesigning *bool `json:"idnssecinlinesigning,omitempty"`
  
    /*
NSEC3PARAM record
NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
    */
    Nsec3paramrecord *string `json:"nsec3paramrecord,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Force
Force nameserver change even if nameserver not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnszoneModKwParams struct {
  *DnszoneModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneModResult `json:"result"`
}

type DnszoneModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnszone `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnszoneModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneModResult%v", string(b))
}

/*
Remove a permission for per-zone access delegation.
*/
func (c *Client) DnszoneRemovePermission(
  reqArgs *DnszoneRemovePermissionArgs,
  optArgs *DnszoneRemovePermissionOptionalArgs, // can be nil
) (*DnszoneRemovePermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneRemovePermissionKwParams{
    DnszoneRemovePermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_remove_permission",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneRemovePermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneRemovePermissionArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnszoneRemovePermissionOptionalArgs struct {
  }

type dnszoneRemovePermissionKwParams struct {
  *DnszoneRemovePermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneRemovePermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneRemovePermissionResult `json:"result"`
}

type DnszoneRemovePermissionResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
Permission value
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *DnszoneRemovePermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneRemovePermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneRemovePermissionResult%v", string(b))
}

/*
Display information about a DNS zone (SOA record).
*/
func (c *Client) DnszoneShow(
  reqArgs *DnszoneShowArgs,
  optArgs *DnszoneShowOptionalArgs, // can be nil
) (*DnszoneShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneShowKwParams{
    DnszoneShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_show",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneShowArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type DnszoneShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnszoneShowKwParams struct {
  *DnszoneShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneShowResult `json:"result"`
}

type DnszoneShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Dnszone `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *DnszoneShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneShowResult%v", string(b))
}

/*
Query current Domain Level.
*/
func (c *Client) DomainlevelGet(
  reqArgs *DomainlevelGetArgs,
  optArgs *DomainlevelGetOptionalArgs, // can be nil
) (*DomainlevelGetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := domainlevelGetKwParams{
    DomainlevelGetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "domainlevel_get",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res domainlevelGetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DomainlevelGetArgs struct {
  }

type DomainlevelGetOptionalArgs struct {
  }

type domainlevelGetKwParams struct {
  *DomainlevelGetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type domainlevelGetResponse struct {
	Error  *Error      `json:"error"`
	Result *DomainlevelGetResult `json:"result"`
}

type DomainlevelGetResult struct {
  
  
    /*
Current domain level:
    (required)
    */
    Result IPAPrim[int] `json:"result,omitempty"`
  }

func (t *DomainlevelGetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DomainlevelGetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DomainlevelGetResult%v", string(b))
}

/*
Change current Domain Level.
*/
func (c *Client) DomainlevelSet(
  reqArgs *DomainlevelSetArgs,
  optArgs *DomainlevelSetOptionalArgs, // can be nil
) (*DomainlevelSetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := domainlevelSetKwParams{
    DomainlevelSetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "domainlevel_set",
    Params: []interface{}{
      []interface{}{reqArgs.Ipadomainlevel, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res domainlevelSetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DomainlevelSetArgs struct {
  
    /*
Domain Level

    */
    Ipadomainlevel int `json:"ipadomainlevel,omitempty"`
  }

type DomainlevelSetOptionalArgs struct {
  }

type domainlevelSetKwParams struct {
  *DomainlevelSetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type domainlevelSetResponse struct {
	Error  *Error      `json:"error"`
	Result *DomainlevelSetResult `json:"result"`
}

type DomainlevelSetResult struct {
  
  
    /*
Current domain level:
    (required)
    */
    Result IPAPrim[int] `json:"result,omitempty"`
  }

func (t *DomainlevelSetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DomainlevelSetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DomainlevelSetResult%v", string(b))
}

/*
Create a new group.
*/
func (c *Client) GroupAdd(
  reqArgs *GroupAddArgs,
  optArgs *GroupAddOptionalArgs, // can be nil
) (*GroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupAddKwParams{
    GroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupAddArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupAddOptionalArgs struct {
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
GID
GID (use this option to set it manually)
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Create as a non-POSIX group
    */
    Nonposix *bool `json:"nonposix,omitempty"`
  
    /*

Allow adding external non-IPA members from trusted domains
    */
    External *bool `json:"external,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type groupAddKwParams struct {
  *GroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupAddResult `json:"result"`
}

type GroupAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Group `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *GroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupAddResult%v", string(b))
}

/*
Add members to a group.
*/
func (c *Client) GroupAddMember(
  reqArgs *GroupAddMemberArgs,
  optArgs *GroupAddMemberOptionalArgs, // can be nil
) (*GroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupAddMemberKwParams{
    GroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupAddMemberArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupAddMemberOptionalArgs struct {
  
    /*
External member
Members of a trusted domain in DOM\name or name@domain form
    */
    Ipaexternalmember *[]string `json:"ipaexternalmember,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type groupAddMemberKwParams struct {
  *GroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupAddMemberResult `json:"result"`
}

type GroupAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *GroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupAddMemberResult%v", string(b))
}

/*
Delete group.
*/
func (c *Client) GroupDel(
  reqArgs *GroupDelArgs,
  optArgs *GroupDelOptionalArgs, // can be nil
) (*GroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupDelKwParams{
    GroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupDelArgs struct {
  
    /*
Group name

    */
    Cn []string `json:"cn,omitempty"`
  }

type GroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type groupDelKwParams struct {
  *GroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupDelResult `json:"result"`
}

type GroupDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Group `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *GroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupDelResult%v", string(b))
}

/*
Detach a managed group from a user.
*/
func (c *Client) GroupDetach(
  reqArgs *GroupDetachArgs,
  optArgs *GroupDetachOptionalArgs, // can be nil
) (*GroupDetachResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupDetachKwParams{
    GroupDetachOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_detach",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupDetachResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupDetachArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupDetachOptionalArgs struct {
  }

type groupDetachKwParams struct {
  *GroupDetachOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupDetachResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupDetachResult `json:"result"`
}

type GroupDetachResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *GroupDetachResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupDetachResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupDetachResult%v", string(b))
}

/*
Search for groups.
*/
func (c *Client) GroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *GroupFindArgs,
  optArgs *GroupFindOptionalArgs, // can be nil
) (*GroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupFindKwParams{
    GroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupFindArgs struct {
  }

type GroupFindOptionalArgs struct {
  
    /*
Group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
GID
GID (use this option to set it manually)
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

search for private groups
    */
    Private *bool `json:"private,omitempty"`
  
    /*

search for POSIX groups
    */
    Posix *bool `json:"posix,omitempty"`
  
    /*

search for groups with support of external non-IPA members from trusted domains
    */
    External *bool `json:"external,omitempty"`
  
    /*

search for non-POSIX groups
    */
    Nonposix *bool `json:"nonposix,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("group-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
user
Search for groups with these member users.
    */
    User *[]string `json:"user,omitempty"`
  
    /*
user
Search for groups without these member users.
    */
    NoUser *[]string `json:"no_user,omitempty"`
  
    /*
group
Search for groups with these member groups.
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
group
Search for groups without these member groups.
    */
    NoGroup *[]string `json:"no_group,omitempty"`
  
    /*
group
Search for groups with these member of groups.
    */
    InGroup *[]string `json:"in_group,omitempty"`
  
    /*
group
Search for groups without these member of groups.
    */
    NotInGroup *[]string `json:"not_in_group,omitempty"`
  
    /*
netgroup
Search for groups with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for groups without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
role
Search for groups with these member of roles.
    */
    InRole *[]string `json:"in_role,omitempty"`
  
    /*
role
Search for groups without these member of roles.
    */
    NotInRole *[]string `json:"not_in_role,omitempty"`
  
    /*
HBAC rule
Search for groups with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for groups without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for groups with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for groups without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  }

type groupFindKwParams struct {
  *GroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupFindResult `json:"result"`
}

type GroupFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Group `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *GroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupFindResult%v", string(b))
}

/*
Modify a group.
*/
func (c *Client) GroupMod(
  reqArgs *GroupModArgs,
  optArgs *GroupModOptionalArgs, // can be nil
) (*GroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupModKwParams{
    GroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupModArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupModOptionalArgs struct {
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
GID
GID (use this option to set it manually)
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

change to a POSIX group
    */
    Posix *bool `json:"posix,omitempty"`
  
    /*

change to support external non-IPA members from trusted domains
    */
    External *bool `json:"external,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the group object
    */
    Rename *string `json:"rename,omitempty"`
  }

type groupModKwParams struct {
  *GroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupModResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupModResult `json:"result"`
}

type GroupModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Group `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *GroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupModResult%v", string(b))
}

/*
Remove members from a group.
*/
func (c *Client) GroupRemoveMember(
  reqArgs *GroupRemoveMemberArgs,
  optArgs *GroupRemoveMemberOptionalArgs, // can be nil
) (*GroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupRemoveMemberKwParams{
    GroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupRemoveMemberArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupRemoveMemberOptionalArgs struct {
  
    /*
External member
Members of a trusted domain in DOM\name or name@domain form
    */
    Ipaexternalmember *[]string `json:"ipaexternalmember,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type groupRemoveMemberKwParams struct {
  *GroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupRemoveMemberResult `json:"result"`
}

type GroupRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *GroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupRemoveMemberResult%v", string(b))
}

/*
Display information about a named group.
*/
func (c *Client) GroupShow(
  reqArgs *GroupShowArgs,
  optArgs *GroupShowOptionalArgs, // can be nil
) (*GroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupShowKwParams{
    GroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupShowArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type groupShowKwParams struct {
  *GroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupShowResult `json:"result"`
}

type GroupShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Group `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *GroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupShowResult%v", string(b))
}

/*
Create a new HBAC rule.
*/
func (c *Client) HbacruleAdd(
  reqArgs *HbacruleAddArgs,
  optArgs *HbacruleAddOptionalArgs, // can be nil
) (*HbacruleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddKwParams{
    HbacruleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddOptionalArgs struct {
  
    /*
Rule type
Rule type (allow)
    */
    Accessruletype *string `json:"accessruletype,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Source host category
Source host category the rule applies to
    */
    Sourcehostcategory *string `json:"sourcehostcategory,omitempty"`
  
    /*
Service category
Service category the rule applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacruleAddKwParams struct {
  *HbacruleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddResult `json:"result"`
}

type HbacruleAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hbacrule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacruleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddResult%v", string(b))
}

/*
Add target hosts and hostgroups to an HBAC rule.
*/
func (c *Client) HbacruleAddHost(
  reqArgs *HbacruleAddHostArgs,
  optArgs *HbacruleAddHostOptionalArgs, // can be nil
) (*HbacruleAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddHostKwParams{
    HbacruleAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add_host",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hbacruleAddHostKwParams struct {
  *HbacruleAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddHostResult `json:"result"`
}

type HbacruleAddHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacruleAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddHostResult%v", string(b))
}

/*
Add services to an HBAC rule.
*/
func (c *Client) HbacruleAddService(
  reqArgs *HbacruleAddServiceArgs,
  optArgs *HbacruleAddServiceOptionalArgs, // can be nil
) (*HbacruleAddServiceResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddServiceKwParams{
    HbacruleAddServiceOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add_service",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddServiceResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddServiceArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddServiceOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member HBAC service
HBAC services to add
    */
    Hbacsvc *[]string `json:"hbacsvc,omitempty"`
  
    /*
member HBAC service group
HBAC service groups to add
    */
    Hbacsvcgroup *[]string `json:"hbacsvcgroup,omitempty"`
  }

type hbacruleAddServiceKwParams struct {
  *HbacruleAddServiceOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddServiceResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddServiceResult `json:"result"`
}

type HbacruleAddServiceResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacruleAddServiceResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddServiceResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddServiceResult%v", string(b))
}

/*

*/
func (c *Client) HbacruleAddSourcehost(
  reqArgs *HbacruleAddSourcehostArgs,
  optArgs *HbacruleAddSourcehostOptionalArgs, // can be nil
) (*HbacruleAddSourcehostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddSourcehostKwParams{
    HbacruleAddSourcehostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add_sourcehost",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddSourcehostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddSourcehostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddSourcehostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hbacruleAddSourcehostKwParams struct {
  *HbacruleAddSourcehostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddSourcehostResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddSourcehostResult `json:"result"`
}

type HbacruleAddSourcehostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacruleAddSourcehostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddSourcehostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddSourcehostResult%v", string(b))
}

/*
Add users and groups to an HBAC rule.
*/
func (c *Client) HbacruleAddUser(
  reqArgs *HbacruleAddUserArgs,
  optArgs *HbacruleAddUserOptionalArgs, // can be nil
) (*HbacruleAddUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddUserKwParams{
    HbacruleAddUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add_user",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type hbacruleAddUserKwParams struct {
  *HbacruleAddUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddUserResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddUserResult `json:"result"`
}

type HbacruleAddUserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacruleAddUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddUserResult%v", string(b))
}

/*
Delete an HBAC rule.
*/
func (c *Client) HbacruleDel(
  reqArgs *HbacruleDelArgs,
  optArgs *HbacruleDelOptionalArgs, // can be nil
) (*HbacruleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleDelKwParams{
    HbacruleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleDelArgs struct {
  
    /*
Rule name

    */
    Cn []string `json:"cn,omitempty"`
  }

type HbacruleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type hbacruleDelKwParams struct {
  *HbacruleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleDelResult `json:"result"`
}

type HbacruleDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Hbacrule `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacruleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleDelResult%v", string(b))
}

/*
Disable an HBAC rule.
*/
func (c *Client) HbacruleDisable(
  reqArgs *HbacruleDisableArgs,
  optArgs *HbacruleDisableOptionalArgs, // can be nil
) (*HbacruleDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleDisableKwParams{
    HbacruleDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleDisableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleDisableOptionalArgs struct {
  }

type hbacruleDisableKwParams struct {
  *HbacruleDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleDisableResult `json:"result"`
}

type HbacruleDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacruleDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleDisableResult%v", string(b))
}

/*
Enable an HBAC rule.
*/
func (c *Client) HbacruleEnable(
  reqArgs *HbacruleEnableArgs,
  optArgs *HbacruleEnableOptionalArgs, // can be nil
) (*HbacruleEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleEnableKwParams{
    HbacruleEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_enable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleEnableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleEnableOptionalArgs struct {
  }

type hbacruleEnableKwParams struct {
  *HbacruleEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleEnableResult `json:"result"`
}

type HbacruleEnableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacruleEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleEnableResult%v", string(b))
}

/*
Search for HBAC rules.
*/
func (c *Client) HbacruleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HbacruleFindArgs,
  optArgs *HbacruleFindOptionalArgs, // can be nil
) (*HbacruleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleFindKwParams{
    HbacruleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleFindArgs struct {
  }

type HbacruleFindOptionalArgs struct {
  
    /*
Rule name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Rule type
Rule type (allow)
    */
    Accessruletype *string `json:"accessruletype,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Source host category
Source host category the rule applies to
    */
    Sourcehostcategory *string `json:"sourcehostcategory,omitempty"`
  
    /*
Service category
Service category the rule applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type hbacruleFindKwParams struct {
  *HbacruleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleFindResult `json:"result"`
}

type HbacruleFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Hbacrule `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *HbacruleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleFindResult%v", string(b))
}

/*
Modify an HBAC rule.
*/
func (c *Client) HbacruleMod(
  reqArgs *HbacruleModArgs,
  optArgs *HbacruleModOptionalArgs, // can be nil
) (*HbacruleModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleModKwParams{
    HbacruleModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleModArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleModOptionalArgs struct {
  
    /*
Rule type
Rule type (allow)
    */
    Accessruletype *string `json:"accessruletype,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Source host category
Source host category the rule applies to
    */
    Sourcehostcategory *string `json:"sourcehostcategory,omitempty"`
  
    /*
Service category
Service category the rule applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the HBAC rule object
    */
    Rename *string `json:"rename,omitempty"`
  }

type hbacruleModKwParams struct {
  *HbacruleModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleModResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleModResult `json:"result"`
}

type HbacruleModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hbacrule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacruleModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleModResult%v", string(b))
}

/*
Remove target hosts and hostgroups from an HBAC rule.
*/
func (c *Client) HbacruleRemoveHost(
  reqArgs *HbacruleRemoveHostArgs,
  optArgs *HbacruleRemoveHostOptionalArgs, // can be nil
) (*HbacruleRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleRemoveHostKwParams{
    HbacruleRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_remove_host",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleRemoveHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hbacruleRemoveHostKwParams struct {
  *HbacruleRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleRemoveHostResult `json:"result"`
}

type HbacruleRemoveHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacruleRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleRemoveHostResult%v", string(b))
}

/*
Remove service and service groups from an HBAC rule.
*/
func (c *Client) HbacruleRemoveService(
  reqArgs *HbacruleRemoveServiceArgs,
  optArgs *HbacruleRemoveServiceOptionalArgs, // can be nil
) (*HbacruleRemoveServiceResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleRemoveServiceKwParams{
    HbacruleRemoveServiceOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_remove_service",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleRemoveServiceResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleRemoveServiceArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleRemoveServiceOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member HBAC service
HBAC services to remove
    */
    Hbacsvc *[]string `json:"hbacsvc,omitempty"`
  
    /*
member HBAC service group
HBAC service groups to remove
    */
    Hbacsvcgroup *[]string `json:"hbacsvcgroup,omitempty"`
  }

type hbacruleRemoveServiceKwParams struct {
  *HbacruleRemoveServiceOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleRemoveServiceResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleRemoveServiceResult `json:"result"`
}

type HbacruleRemoveServiceResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacruleRemoveServiceResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleRemoveServiceResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleRemoveServiceResult%v", string(b))
}

/*

*/
func (c *Client) HbacruleRemoveSourcehost(
  reqArgs *HbacruleRemoveSourcehostArgs,
  optArgs *HbacruleRemoveSourcehostOptionalArgs, // can be nil
) (*HbacruleRemoveSourcehostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleRemoveSourcehostKwParams{
    HbacruleRemoveSourcehostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_remove_sourcehost",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleRemoveSourcehostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleRemoveSourcehostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleRemoveSourcehostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hbacruleRemoveSourcehostKwParams struct {
  *HbacruleRemoveSourcehostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleRemoveSourcehostResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleRemoveSourcehostResult `json:"result"`
}

type HbacruleRemoveSourcehostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacruleRemoveSourcehostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleRemoveSourcehostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleRemoveSourcehostResult%v", string(b))
}

/*
Remove users and groups from an HBAC rule.
*/
func (c *Client) HbacruleRemoveUser(
  reqArgs *HbacruleRemoveUserArgs,
  optArgs *HbacruleRemoveUserOptionalArgs, // can be nil
) (*HbacruleRemoveUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleRemoveUserKwParams{
    HbacruleRemoveUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_remove_user",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleRemoveUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleRemoveUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleRemoveUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type hbacruleRemoveUserKwParams struct {
  *HbacruleRemoveUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleRemoveUserResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleRemoveUserResult `json:"result"`
}

type HbacruleRemoveUserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacruleRemoveUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleRemoveUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleRemoveUserResult%v", string(b))
}

/*
Display the properties of an HBAC rule.
*/
func (c *Client) HbacruleShow(
  reqArgs *HbacruleShowArgs,
  optArgs *HbacruleShowOptionalArgs, // can be nil
) (*HbacruleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleShowKwParams{
    HbacruleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleShowArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacruleShowKwParams struct {
  *HbacruleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleShowResult `json:"result"`
}

type HbacruleShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hbacrule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacruleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleShowResult%v", string(b))
}

/*
Add a new HBAC service.
*/
func (c *Client) HbacsvcAdd(
  reqArgs *HbacsvcAddArgs,
  optArgs *HbacsvcAddOptionalArgs, // can be nil
) (*HbacsvcAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcAddKwParams{
    HbacsvcAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcAddArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcAddOptionalArgs struct {
  
    /*
Description
HBAC service description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcAddKwParams struct {
  *HbacsvcAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcAddResult `json:"result"`
}

type HbacsvcAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hbacsvc `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacsvcAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcAddResult%v", string(b))
}

/*
Delete an existing HBAC service.
*/
func (c *Client) HbacsvcDel(
  reqArgs *HbacsvcDelArgs,
  optArgs *HbacsvcDelOptionalArgs, // can be nil
) (*HbacsvcDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcDelKwParams{
    HbacsvcDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcDelArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn []string `json:"cn,omitempty"`
  }

type HbacsvcDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type hbacsvcDelKwParams struct {
  *HbacsvcDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcDelResult `json:"result"`
}

type HbacsvcDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Hbacsvc `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacsvcDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcDelResult%v", string(b))
}

/*
Search for HBAC services.
*/
func (c *Client) HbacsvcFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HbacsvcFindArgs,
  optArgs *HbacsvcFindOptionalArgs, // can be nil
) (*HbacsvcFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcFindKwParams{
    HbacsvcFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcFindArgs struct {
  }

type HbacsvcFindOptionalArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
HBAC service description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("service")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type hbacsvcFindKwParams struct {
  *HbacsvcFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcFindResult `json:"result"`
}

type HbacsvcFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Hbacsvc `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *HbacsvcFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcFindResult%v", string(b))
}

/*
Modify an HBAC service.
*/
func (c *Client) HbacsvcMod(
  reqArgs *HbacsvcModArgs,
  optArgs *HbacsvcModOptionalArgs, // can be nil
) (*HbacsvcModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcModKwParams{
    HbacsvcModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcModArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcModOptionalArgs struct {
  
    /*
Description
HBAC service description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcModKwParams struct {
  *HbacsvcModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcModResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcModResult `json:"result"`
}

type HbacsvcModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hbacsvc `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacsvcModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcModResult%v", string(b))
}

/*
Display information about an HBAC service.
*/
func (c *Client) HbacsvcShow(
  reqArgs *HbacsvcShowArgs,
  optArgs *HbacsvcShowOptionalArgs, // can be nil
) (*HbacsvcShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcShowKwParams{
    HbacsvcShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcShowArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcShowKwParams struct {
  *HbacsvcShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcShowResult `json:"result"`
}

type HbacsvcShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hbacsvc `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacsvcShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcShowResult%v", string(b))
}

/*
Add a new HBAC service group.
*/
func (c *Client) HbacsvcgroupAdd(
  reqArgs *HbacsvcgroupAddArgs,
  optArgs *HbacsvcgroupAddOptionalArgs, // can be nil
) (*HbacsvcgroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupAddKwParams{
    HbacsvcgroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupAddArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupAddOptionalArgs struct {
  
    /*
Description
HBAC service group description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcgroupAddKwParams struct {
  *HbacsvcgroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupAddResult `json:"result"`
}

type HbacsvcgroupAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hbacsvcgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacsvcgroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupAddResult%v", string(b))
}

/*
Add members to an HBAC service group.
*/
func (c *Client) HbacsvcgroupAddMember(
  reqArgs *HbacsvcgroupAddMemberArgs,
  optArgs *HbacsvcgroupAddMemberOptionalArgs, // can be nil
) (*HbacsvcgroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupAddMemberKwParams{
    HbacsvcgroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupAddMemberArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member HBAC service
HBAC services to add
    */
    Hbacsvc *[]string `json:"hbacsvc,omitempty"`
  }

type hbacsvcgroupAddMemberKwParams struct {
  *HbacsvcgroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupAddMemberResult `json:"result"`
}

type HbacsvcgroupAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacsvcgroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupAddMemberResult%v", string(b))
}

/*
Delete an HBAC service group.
*/
func (c *Client) HbacsvcgroupDel(
  reqArgs *HbacsvcgroupDelArgs,
  optArgs *HbacsvcgroupDelOptionalArgs, // can be nil
) (*HbacsvcgroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupDelKwParams{
    HbacsvcgroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupDelArgs struct {
  
    /*
Service group name

    */
    Cn []string `json:"cn,omitempty"`
  }

type HbacsvcgroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type hbacsvcgroupDelKwParams struct {
  *HbacsvcgroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupDelResult `json:"result"`
}

type HbacsvcgroupDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Hbacsvcgroup `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacsvcgroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupDelResult%v", string(b))
}

/*
Search for an HBAC service group.
*/
func (c *Client) HbacsvcgroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HbacsvcgroupFindArgs,
  optArgs *HbacsvcgroupFindOptionalArgs, // can be nil
) (*HbacsvcgroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupFindKwParams{
    HbacsvcgroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupFindArgs struct {
  }

type HbacsvcgroupFindOptionalArgs struct {
  
    /*
Service group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
HBAC service group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type hbacsvcgroupFindKwParams struct {
  *HbacsvcgroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupFindResult `json:"result"`
}

type HbacsvcgroupFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Hbacsvcgroup `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *HbacsvcgroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupFindResult%v", string(b))
}

/*
Modify an HBAC service group.
*/
func (c *Client) HbacsvcgroupMod(
  reqArgs *HbacsvcgroupModArgs,
  optArgs *HbacsvcgroupModOptionalArgs, // can be nil
) (*HbacsvcgroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupModKwParams{
    HbacsvcgroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupModArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupModOptionalArgs struct {
  
    /*
Description
HBAC service group description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcgroupModKwParams struct {
  *HbacsvcgroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupModResult `json:"result"`
}

type HbacsvcgroupModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hbacsvcgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacsvcgroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupModResult%v", string(b))
}

/*
Remove members from an HBAC service group.
*/
func (c *Client) HbacsvcgroupRemoveMember(
  reqArgs *HbacsvcgroupRemoveMemberArgs,
  optArgs *HbacsvcgroupRemoveMemberOptionalArgs, // can be nil
) (*HbacsvcgroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupRemoveMemberKwParams{
    HbacsvcgroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupRemoveMemberArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member HBAC service
HBAC services to remove
    */
    Hbacsvc *[]string `json:"hbacsvc,omitempty"`
  }

type hbacsvcgroupRemoveMemberKwParams struct {
  *HbacsvcgroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupRemoveMemberResult `json:"result"`
}

type HbacsvcgroupRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HbacsvcgroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupRemoveMemberResult%v", string(b))
}

/*
Display information about an HBAC service group.
*/
func (c *Client) HbacsvcgroupShow(
  reqArgs *HbacsvcgroupShowArgs,
  optArgs *HbacsvcgroupShowOptionalArgs, // can be nil
) (*HbacsvcgroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupShowKwParams{
    HbacsvcgroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupShowArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcgroupShowKwParams struct {
  *HbacsvcgroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupShowResult `json:"result"`
}

type HbacsvcgroupShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hbacsvcgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HbacsvcgroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupShowResult%v", string(b))
}

/*
Simulate use of Host-based access controls
*/
func (c *Client) Hbactest(
  reqArgs *HbactestArgs,
  optArgs *HbactestOptionalArgs, // can be nil
) (*HbactestResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbactestKwParams{
    HbactestOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbactest",
    Params: []interface{}{
      []interface{}{reqArgs.User, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbactestResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbactestArgs struct {
  
    /*
User name

    */
    User string `json:"user,omitempty"`
  }

type HbactestOptionalArgs struct {
  
    /*
Source host

    */
    Sourcehost *string `json:"sourcehost,omitempty"`
  
    /*
Target host

    */
    Targethost *string `json:"targethost,omitempty"`
  
    /*
Service

    */
    Service *string `json:"service,omitempty"`
  
    /*
Rules to test. If not specified, --enabled is assumed

    */
    Rules *[]string `json:"rules,omitempty"`
  
    /*
Hide details which rules are matched, not matched, or invalid

    */
    Nodetail *bool `json:"nodetail,omitempty"`
  
    /*
Include all enabled IPA rules into test [default]

    */
    Enabled *bool `json:"enabled,omitempty"`
  
    /*
Include all disabled IPA rules into test

    */
    Disabled *bool `json:"disabled,omitempty"`
  
    /*
Size Limit
Maximum number of rules to process when no --rules is specified
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  }

type hbactestKwParams struct {
  *HbactestOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbactestResponse struct {
	Error  *Error      `json:"error"`
	Result *HbactestResult `json:"result"`
}

type HbactestResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
Warning
    (optional)
    */
    Warning *[]interface{} `json:"warning,omitempty"`
  
    /*
Matched rules
    (optional)
    */
    Matched *[]interface{} `json:"matched,omitempty"`
  
    /*
Not matched rules
    (optional)
    */
    Notmatched *[]interface{} `json:"notmatched,omitempty"`
  
    /*
Non-existent or invalid rules
    (optional)
    */
    Error *[]interface{} `json:"error,omitempty"`
  
    /*
Result of simulation
    (required)
    */
    Value IPAPrim[bool] `json:"value,omitempty"`
  }

func (t *HbactestResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbactestResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbactestResult%v", string(b))
}

/*
Add a new host.
*/
func (c *Client) HostAdd(
  reqArgs *HostAddArgs,
  optArgs *HostAddOptionalArgs, // can be nil
) (*HostAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAddKwParams{
    HostAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_add",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAddArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostAddOptionalArgs struct {
  
    /*
Description
A description of this host
    */
    Description *string `json:"description,omitempty"`
  
    /*
Locality
Host locality (e.g. "Baltimore, MD")
    */
    L *string `json:"l,omitempty"`
  
    /*
Location
Host location (e.g. "Lab 2")
    */
    Nshostlocation *string `json:"nshostlocation,omitempty"`
  
    /*
Platform
Host hardware platform (e.g. "Lenovo T61")
    */
    Nshardwareplatform *string `json:"nshardwareplatform,omitempty"`
  
    /*
Operating system
Host operating system and version (e.g. "Fedora 9")
    */
    Nsosversion *string `json:"nsosversion,omitempty"`
  
    /*
User password
Password used in bulk enrollment
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random password to be used in bulk enrollment
    */
    Random *bool `json:"random,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
MAC address
Hardware MAC address(es) on this host
    */
    Macaddress *[]string `json:"macaddress,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
Class
Host category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
Assigned ID View

    */
    Ipaassignedidview *string `json:"ipaassignedidview,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Force
force host name even if not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*

skip reverse DNS detection
    */
    NoReverse *bool `json:"no_reverse,omitempty"`
  
    /*
IP Address
Add the host to DNS with this IP address
    */
    IPAddress *string `json:"ip_address,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostAddKwParams struct {
  *HostAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAddResult `json:"result"`
}

type HostAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Host `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAddResult%v", string(b))
}

/*
Add certificates to host entry
*/
func (c *Client) HostAddCert(
  reqArgs *HostAddCertArgs,
  optArgs *HostAddCertOptionalArgs, // can be nil
) (*HostAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAddCertKwParams{
    HostAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_add_cert",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAddCertArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type HostAddCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostAddCertKwParams struct {
  *HostAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAddCertResult `json:"result"`
}

type HostAddCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAddCertResult%v", string(b))
}

/*
Add hosts that can manage this host.
*/
func (c *Client) HostAddManagedby(
  reqArgs *HostAddManagedbyArgs,
  optArgs *HostAddManagedbyOptionalArgs, // can be nil
) (*HostAddManagedbyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAddManagedbyKwParams{
    HostAddManagedbyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_add_managedby",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAddManagedbyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAddManagedbyArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostAddManagedbyOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  }

type hostAddManagedbyKwParams struct {
  *HostAddManagedbyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAddManagedbyResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAddManagedbyResult `json:"result"`
}

type HostAddManagedbyResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HostAddManagedbyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAddManagedbyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAddManagedbyResult%v", string(b))
}

/*
Add new principal alias to host entry
*/
func (c *Client) HostAddPrincipal(
  reqArgs *HostAddPrincipalArgs,
  optArgs *HostAddPrincipalOptionalArgs, // can be nil
) (*HostAddPrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAddPrincipalKwParams{
    HostAddPrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_add_principal",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, reqArgs.Krbprincipalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAddPrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAddPrincipalArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type HostAddPrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostAddPrincipalKwParams struct {
  *HostAddPrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAddPrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAddPrincipalResult `json:"result"`
}

type HostAddPrincipalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostAddPrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAddPrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAddPrincipalResult%v", string(b))
}

/*
Allow users, groups, hosts or host groups to create a keytab of this host.
*/
func (c *Client) HostAllowCreateKeytab(
  reqArgs *HostAllowCreateKeytabArgs,
  optArgs *HostAllowCreateKeytabOptionalArgs, // can be nil
) (*HostAllowCreateKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAllowCreateKeytabKwParams{
    HostAllowCreateKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_allow_create_keytab",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAllowCreateKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAllowCreateKeytabArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostAllowCreateKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostAllowCreateKeytabKwParams struct {
  *HostAllowCreateKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAllowCreateKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAllowCreateKeytabResult `json:"result"`
}

type HostAllowCreateKeytabResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HostAllowCreateKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAllowCreateKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAllowCreateKeytabResult%v", string(b))
}

/*
Allow users, groups, hosts or host groups to retrieve a keytab of this host.
*/
func (c *Client) HostAllowRetrieveKeytab(
  reqArgs *HostAllowRetrieveKeytabArgs,
  optArgs *HostAllowRetrieveKeytabOptionalArgs, // can be nil
) (*HostAllowRetrieveKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAllowRetrieveKeytabKwParams{
    HostAllowRetrieveKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_allow_retrieve_keytab",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAllowRetrieveKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAllowRetrieveKeytabArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostAllowRetrieveKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostAllowRetrieveKeytabKwParams struct {
  *HostAllowRetrieveKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAllowRetrieveKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAllowRetrieveKeytabResult `json:"result"`
}

type HostAllowRetrieveKeytabResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HostAllowRetrieveKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAllowRetrieveKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAllowRetrieveKeytabResult%v", string(b))
}

/*
Delete a host.
*/
func (c *Client) HostDel(
  reqArgs *HostDelArgs,
  optArgs *HostDelOptionalArgs, // can be nil
) (*HostDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostDelKwParams{
    HostDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_del",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostDelArgs struct {
  
    /*
Host name

    */
    Fqdn []string `json:"fqdn,omitempty"`
  }

type HostDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*

Remove A, AAAA, SSHFP and PTR records of the host(s) managed by IPA DNS
    */
    Updatedns *bool `json:"updatedns,omitempty"`
  }

type hostDelKwParams struct {
  *HostDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HostDelResult `json:"result"`
}

type HostDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Host `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostDelResult%v", string(b))
}

/*
Disable the Kerberos key, SSL certificate and all services of a host.
*/
func (c *Client) HostDisable(
  reqArgs *HostDisableArgs,
  optArgs *HostDisableOptionalArgs, // can be nil
) (*HostDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostDisableKwParams{
    HostDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostDisableArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostDisableOptionalArgs struct {
  }

type hostDisableKwParams struct {
  *HostDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *HostDisableResult `json:"result"`
}

type HostDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostDisableResult%v", string(b))
}

/*
Disallow users, groups, hosts or host groups to create a keytab of this host.
*/
func (c *Client) HostDisallowCreateKeytab(
  reqArgs *HostDisallowCreateKeytabArgs,
  optArgs *HostDisallowCreateKeytabOptionalArgs, // can be nil
) (*HostDisallowCreateKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostDisallowCreateKeytabKwParams{
    HostDisallowCreateKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_disallow_create_keytab",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostDisallowCreateKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostDisallowCreateKeytabArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostDisallowCreateKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostDisallowCreateKeytabKwParams struct {
  *HostDisallowCreateKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostDisallowCreateKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *HostDisallowCreateKeytabResult `json:"result"`
}

type HostDisallowCreateKeytabResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HostDisallowCreateKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostDisallowCreateKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostDisallowCreateKeytabResult%v", string(b))
}

/*
Disallow users, groups, hosts or host groups to retrieve a keytab of this host.
*/
func (c *Client) HostDisallowRetrieveKeytab(
  reqArgs *HostDisallowRetrieveKeytabArgs,
  optArgs *HostDisallowRetrieveKeytabOptionalArgs, // can be nil
) (*HostDisallowRetrieveKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostDisallowRetrieveKeytabKwParams{
    HostDisallowRetrieveKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_disallow_retrieve_keytab",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostDisallowRetrieveKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostDisallowRetrieveKeytabArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostDisallowRetrieveKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostDisallowRetrieveKeytabKwParams struct {
  *HostDisallowRetrieveKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostDisallowRetrieveKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *HostDisallowRetrieveKeytabResult `json:"result"`
}

type HostDisallowRetrieveKeytabResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HostDisallowRetrieveKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostDisallowRetrieveKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostDisallowRetrieveKeytabResult%v", string(b))
}

/*
Search for hosts.
*/
func (c *Client) HostFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HostFindArgs,
  optArgs *HostFindOptionalArgs, // can be nil
) (*HostFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostFindKwParams{
    HostFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostFindArgs struct {
  }

type HostFindOptionalArgs struct {
  
    /*
Host name

    */
    Fqdn *string `json:"fqdn,omitempty"`
  
    /*
Description
A description of this host
    */
    Description *string `json:"description,omitempty"`
  
    /*
Locality
Host locality (e.g. "Baltimore, MD")
    */
    L *string `json:"l,omitempty"`
  
    /*
Location
Host location (e.g. "Lab 2")
    */
    Nshostlocation *string `json:"nshostlocation,omitempty"`
  
    /*
Platform
Host hardware platform (e.g. "Lenovo T61")
    */
    Nshardwareplatform *string `json:"nshardwareplatform,omitempty"`
  
    /*
Operating system
Host operating system and version (e.g. "Fedora 9")
    */
    Nsosversion *string `json:"nsosversion,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
MAC address
Hardware MAC address(es) on this host
    */
    Macaddress *[]string `json:"macaddress,omitempty"`
  
    /*
Class
Host category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
Assigned ID View

    */
    Ipaassignedidview *string `json:"ipaassignedidview,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("hostname")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
host group
Search for hosts with these member of host groups.
    */
    InHostgroup *[]string `json:"in_hostgroup,omitempty"`
  
    /*
host group
Search for hosts without these member of host groups.
    */
    NotInHostgroup *[]string `json:"not_in_hostgroup,omitempty"`
  
    /*
netgroup
Search for hosts with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for hosts without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
role
Search for hosts with these member of roles.
    */
    InRole *[]string `json:"in_role,omitempty"`
  
    /*
role
Search for hosts without these member of roles.
    */
    NotInRole *[]string `json:"not_in_role,omitempty"`
  
    /*
HBAC rule
Search for hosts with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for hosts without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for hosts with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for hosts without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  
    /*
user
Search for hosts with these enrolled by users.
    */
    EnrollByUser *[]string `json:"enroll_by_user,omitempty"`
  
    /*
user
Search for hosts without these enrolled by users.
    */
    NotEnrollByUser *[]string `json:"not_enroll_by_user,omitempty"`
  
    /*
host
Search for hosts with these managed by hosts.
    */
    ManByHost *[]string `json:"man_by_host,omitempty"`
  
    /*
host
Search for hosts without these managed by hosts.
    */
    NotManByHost *[]string `json:"not_man_by_host,omitempty"`
  
    /*
host
Search for hosts with these managing hosts.
    */
    ManHost *[]string `json:"man_host,omitempty"`
  
    /*
host
Search for hosts without these managing hosts.
    */
    NotManHost *[]string `json:"not_man_host,omitempty"`
  }

type hostFindKwParams struct {
  *HostFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HostFindResult `json:"result"`
}

type HostFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Host `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *HostFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostFindResult%v", string(b))
}

/*
Modify information about a host.
*/
func (c *Client) HostMod(
  reqArgs *HostModArgs,
  optArgs *HostModOptionalArgs, // can be nil
) (*HostModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostModKwParams{
    HostModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostModArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostModOptionalArgs struct {
  
    /*
Description
A description of this host
    */
    Description *string `json:"description,omitempty"`
  
    /*
Locality
Host locality (e.g. "Baltimore, MD")
    */
    L *string `json:"l,omitempty"`
  
    /*
Location
Host location (e.g. "Lab 2")
    */
    Nshostlocation *string `json:"nshostlocation,omitempty"`
  
    /*
Platform
Host hardware platform (e.g. "Lenovo T61")
    */
    Nshardwareplatform *string `json:"nshardwareplatform,omitempty"`
  
    /*
Operating system
Host operating system and version (e.g. "Fedora 9")
    */
    Nsosversion *string `json:"nsosversion,omitempty"`
  
    /*
User password
Password used in bulk enrollment
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random password to be used in bulk enrollment
    */
    Random *bool `json:"random,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
MAC address
Hardware MAC address(es) on this host
    */
    Macaddress *[]string `json:"macaddress,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
Class
Host category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
Assigned ID View

    */
    Ipaassignedidview *string `json:"ipaassignedidview,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Update DNS entries
    */
    Updatedns *bool `json:"updatedns,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostModKwParams struct {
  *HostModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostModResponse struct {
	Error  *Error      `json:"error"`
	Result *HostModResult `json:"result"`
}

type HostModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Host `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostModResult%v", string(b))
}

/*
Remove certificates from host entry
*/
func (c *Client) HostRemoveCert(
  reqArgs *HostRemoveCertArgs,
  optArgs *HostRemoveCertOptionalArgs, // can be nil
) (*HostRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostRemoveCertKwParams{
    HostRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_remove_cert",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostRemoveCertArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type HostRemoveCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostRemoveCertKwParams struct {
  *HostRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *HostRemoveCertResult `json:"result"`
}

type HostRemoveCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostRemoveCertResult%v", string(b))
}

/*
Remove hosts that can manage this host.
*/
func (c *Client) HostRemoveManagedby(
  reqArgs *HostRemoveManagedbyArgs,
  optArgs *HostRemoveManagedbyOptionalArgs, // can be nil
) (*HostRemoveManagedbyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostRemoveManagedbyKwParams{
    HostRemoveManagedbyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_remove_managedby",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostRemoveManagedbyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostRemoveManagedbyArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostRemoveManagedbyOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  }

type hostRemoveManagedbyKwParams struct {
  *HostRemoveManagedbyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostRemoveManagedbyResponse struct {
	Error  *Error      `json:"error"`
	Result *HostRemoveManagedbyResult `json:"result"`
}

type HostRemoveManagedbyResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HostRemoveManagedbyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostRemoveManagedbyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostRemoveManagedbyResult%v", string(b))
}

/*
Remove principal alias from a host entry
*/
func (c *Client) HostRemovePrincipal(
  reqArgs *HostRemovePrincipalArgs,
  optArgs *HostRemovePrincipalOptionalArgs, // can be nil
) (*HostRemovePrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostRemovePrincipalKwParams{
    HostRemovePrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_remove_principal",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, reqArgs.Krbprincipalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostRemovePrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostRemovePrincipalArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type HostRemovePrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostRemovePrincipalKwParams struct {
  *HostRemovePrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostRemovePrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *HostRemovePrincipalResult `json:"result"`
}

type HostRemovePrincipalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostRemovePrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostRemovePrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostRemovePrincipalResult%v", string(b))
}

/*
Display information about a host.
*/
func (c *Client) HostShow(
  reqArgs *HostShowArgs,
  optArgs *HostShowOptionalArgs, // can be nil
) (*HostShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostShowKwParams{
    HostShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_show",
    Params: []interface{}{
      []interface{}{reqArgs.Fqdn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostShowArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

file to store certificate in
    */
    Out *string `json:"out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostShowKwParams struct {
  *HostShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HostShowResult `json:"result"`
}

type HostShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Host `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostShowResult%v", string(b))
}

/*
Add a new hostgroup.
*/
func (c *Client) HostgroupAdd(
  reqArgs *HostgroupAddArgs,
  optArgs *HostgroupAddOptionalArgs, // can be nil
) (*HostgroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupAddKwParams{
    HostgroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupAddArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupAddOptionalArgs struct {
  
    /*
Description
A description of this host-group
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostgroupAddKwParams struct {
  *HostgroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupAddResult `json:"result"`
}

type HostgroupAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hostgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostgroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupAddResult%v", string(b))
}

/*
Add members to a hostgroup.
*/
func (c *Client) HostgroupAddMember(
  reqArgs *HostgroupAddMemberArgs,
  optArgs *HostgroupAddMemberOptionalArgs, // can be nil
) (*HostgroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupAddMemberKwParams{
    HostgroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupAddMemberArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostgroupAddMemberKwParams struct {
  *HostgroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupAddMemberResult `json:"result"`
}

type HostgroupAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HostgroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupAddMemberResult%v", string(b))
}

/*
Delete a hostgroup.
*/
func (c *Client) HostgroupDel(
  reqArgs *HostgroupDelArgs,
  optArgs *HostgroupDelOptionalArgs, // can be nil
) (*HostgroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupDelKwParams{
    HostgroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupDelArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn []string `json:"cn,omitempty"`
  }

type HostgroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type hostgroupDelKwParams struct {
  *HostgroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupDelResult `json:"result"`
}

type HostgroupDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Hostgroup `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostgroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupDelResult%v", string(b))
}

/*
Search for hostgroups.
*/
func (c *Client) HostgroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HostgroupFindArgs,
  optArgs *HostgroupFindOptionalArgs, // can be nil
) (*HostgroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupFindKwParams{
    HostgroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupFindArgs struct {
  }

type HostgroupFindOptionalArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
A description of this host-group
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("hostgroup-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
host
Search for host groups with these member hosts.
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
host
Search for host groups without these member hosts.
    */
    NoHost *[]string `json:"no_host,omitempty"`
  
    /*
host group
Search for host groups with these member host groups.
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
host group
Search for host groups without these member host groups.
    */
    NoHostgroup *[]string `json:"no_hostgroup,omitempty"`
  
    /*
host group
Search for host groups with these member of host groups.
    */
    InHostgroup *[]string `json:"in_hostgroup,omitempty"`
  
    /*
host group
Search for host groups without these member of host groups.
    */
    NotInHostgroup *[]string `json:"not_in_hostgroup,omitempty"`
  
    /*
netgroup
Search for host groups with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for host groups without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
HBAC rule
Search for host groups with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for host groups without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for host groups with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for host groups without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  }

type hostgroupFindKwParams struct {
  *HostgroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupFindResult `json:"result"`
}

type HostgroupFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Hostgroup `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *HostgroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupFindResult%v", string(b))
}

/*
Modify a hostgroup.
*/
func (c *Client) HostgroupMod(
  reqArgs *HostgroupModArgs,
  optArgs *HostgroupModOptionalArgs, // can be nil
) (*HostgroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupModKwParams{
    HostgroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupModArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupModOptionalArgs struct {
  
    /*
Description
A description of this host-group
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the host group object
    */
    Rename *string `json:"rename,omitempty"`
  }

type hostgroupModKwParams struct {
  *HostgroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupModResult `json:"result"`
}

type HostgroupModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hostgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostgroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupModResult%v", string(b))
}

/*
Remove members from a hostgroup.
*/
func (c *Client) HostgroupRemoveMember(
  reqArgs *HostgroupRemoveMemberArgs,
  optArgs *HostgroupRemoveMemberOptionalArgs, // can be nil
) (*HostgroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupRemoveMemberKwParams{
    HostgroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupRemoveMemberArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostgroupRemoveMemberKwParams struct {
  *HostgroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupRemoveMemberResult `json:"result"`
}

type HostgroupRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *HostgroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupRemoveMemberResult%v", string(b))
}

/*
Display information about a hostgroup.
*/
func (c *Client) HostgroupShow(
  reqArgs *HostgroupShowArgs,
  optArgs *HostgroupShowOptionalArgs, // can be nil
) (*HostgroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupShowKwParams{
    HostgroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupShowArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostgroupShowKwParams struct {
  *HostgroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupShowResult `json:"result"`
}

type HostgroupShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Hostgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *HostgroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupShowResult%v", string(b))
}

/*

*/
func (c *Client) I18nMessages(
  reqArgs *I18nMessagesArgs,
  optArgs *I18nMessagesOptionalArgs, // can be nil
) (*I18nMessagesResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := i18nMessagesKwParams{
    I18nMessagesOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "i18n_messages",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res i18nMessagesResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type I18nMessagesArgs struct {
  }

type I18nMessagesOptionalArgs struct {
  }

type i18nMessagesKwParams struct {
  *I18nMessagesOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type i18nMessagesResponse struct {
	Error  *Error      `json:"error"`
	Result *I18nMessagesResult `json:"result"`
}

type I18nMessagesResult struct {
  
  
    /*
Dict of I18N messages
    (required)
    */
    Texts interface{} `json:"texts,omitempty"`
  }

func (t *I18nMessagesResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("I18nMessagesResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("I18nMessagesResult%v", string(b))
}

/*
Add a new Group ID override.
*/
func (c *Client) IdoverridegroupAdd(
  reqArgs *IdoverridegroupAddArgs,
  optArgs *IdoverridegroupAddOptionalArgs, // can be nil
) (*IdoverridegroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupAddKwParams{
    IdoverridegroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_add",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupAddArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverridegroupAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverridegroupAddKwParams struct {
  *IdoverridegroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupAddResult `json:"result"`
}

type IdoverridegroupAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idoverridegroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverridegroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupAddResult%v", string(b))
}

/*
Delete an Group ID override.
*/
func (c *Client) IdoverridegroupDel(
  reqArgs *IdoverridegroupDelArgs,
  optArgs *IdoverridegroupDelOptionalArgs, // can be nil
) (*IdoverridegroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupDelKwParams{
    IdoverridegroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_del",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupDelArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid []string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverridegroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  }

type idoverridegroupDelKwParams struct {
  *IdoverridegroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupDelResult `json:"result"`
}

type IdoverridegroupDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Idoverridegroup `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverridegroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupDelResult%v", string(b))
}

/*
Search for an Group ID override.
*/
func (c *Client) IdoverridegroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *IdoverridegroupFindArgs,
  optArgs *IdoverridegroupFindOptionalArgs, // can be nil
) (*IdoverridegroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupFindKwParams{
    IdoverridegroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_find",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupFindArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  }

type IdoverridegroupFindOptionalArgs struct {
  
    /*
Anchor to override

    */
    Ipaanchoruuid *string `json:"ipaanchoruuid,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("anchor")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type idoverridegroupFindKwParams struct {
  *IdoverridegroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupFindResult `json:"result"`
}

type IdoverridegroupFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Idoverridegroup `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *IdoverridegroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupFindResult%v", string(b))
}

/*
Modify an Group ID override.
*/
func (c *Client) IdoverridegroupMod(
  reqArgs *IdoverridegroupModArgs,
  optArgs *IdoverridegroupModOptionalArgs, // can be nil
) (*IdoverridegroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupModKwParams{
    IdoverridegroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupModArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverridegroupModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the Group ID override object
    */
    Rename *string `json:"rename,omitempty"`
  }

type idoverridegroupModKwParams struct {
  *IdoverridegroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupModResult `json:"result"`
}

type IdoverridegroupModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idoverridegroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverridegroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupModResult%v", string(b))
}

/*
Display information about an Group ID override.
*/
func (c *Client) IdoverridegroupShow(
  reqArgs *IdoverridegroupShowArgs,
  optArgs *IdoverridegroupShowOptionalArgs, // can be nil
) (*IdoverridegroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupShowKwParams{
    IdoverridegroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_show",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupShowArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverridegroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverridegroupShowKwParams struct {
  *IdoverridegroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupShowResult `json:"result"`
}

type IdoverridegroupShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idoverridegroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverridegroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupShowResult%v", string(b))
}

/*
Add a new User ID override.
*/
func (c *Client) IdoverrideuserAdd(
  reqArgs *IdoverrideuserAddArgs,
  optArgs *IdoverrideuserAddOptionalArgs, // can be nil
) (*IdoverrideuserAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserAddKwParams{
    IdoverrideuserAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_add",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserAddArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverrideuserAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
UID
User ID Number
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*


    */
    Ipaoriginaluid *string `json:"ipaoriginaluid,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverrideuserAddKwParams struct {
  *IdoverrideuserAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserAddResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserAddResult `json:"result"`
}

type IdoverrideuserAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idoverrideuser `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverrideuserAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserAddResult%v", string(b))
}

/*
Add one or more certificates to the idoverrideuser entry
*/
func (c *Client) IdoverrideuserAddCert(
  reqArgs *IdoverrideuserAddCertArgs,
  optArgs *IdoverrideuserAddCertOptionalArgs, // can be nil
) (*IdoverrideuserAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserAddCertKwParams{
    IdoverrideuserAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_add_cert",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserAddCertArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type IdoverrideuserAddCertOptionalArgs struct {
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverrideuserAddCertKwParams struct {
  *IdoverrideuserAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserAddCertResult `json:"result"`
}

type IdoverrideuserAddCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverrideuserAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserAddCertResult%v", string(b))
}

/*
Delete an User ID override.
*/
func (c *Client) IdoverrideuserDel(
  reqArgs *IdoverrideuserDelArgs,
  optArgs *IdoverrideuserDelOptionalArgs, // can be nil
) (*IdoverrideuserDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserDelKwParams{
    IdoverrideuserDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_del",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserDelArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid []string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverrideuserDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  }

type idoverrideuserDelKwParams struct {
  *IdoverrideuserDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserDelResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserDelResult `json:"result"`
}

type IdoverrideuserDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Idoverrideuser `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverrideuserDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserDelResult%v", string(b))
}

/*
Search for an User ID override.
*/
func (c *Client) IdoverrideuserFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *IdoverrideuserFindArgs,
  optArgs *IdoverrideuserFindOptionalArgs, // can be nil
) (*IdoverrideuserFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserFindKwParams{
    IdoverrideuserFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_find",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserFindArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  }

type IdoverrideuserFindOptionalArgs struct {
  
    /*
Anchor to override

    */
    Ipaanchoruuid *string `json:"ipaanchoruuid,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
UID
User ID Number
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*


    */
    Ipaoriginaluid *string `json:"ipaoriginaluid,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("anchor")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type idoverrideuserFindKwParams struct {
  *IdoverrideuserFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserFindResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserFindResult `json:"result"`
}

type IdoverrideuserFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Idoverrideuser `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *IdoverrideuserFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserFindResult%v", string(b))
}

/*
Modify an User ID override.
*/
func (c *Client) IdoverrideuserMod(
  reqArgs *IdoverrideuserModArgs,
  optArgs *IdoverrideuserModOptionalArgs, // can be nil
) (*IdoverrideuserModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserModKwParams{
    IdoverrideuserModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserModArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverrideuserModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
UID
User ID Number
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*


    */
    Ipaoriginaluid *string `json:"ipaoriginaluid,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the User ID override object
    */
    Rename *string `json:"rename,omitempty"`
  }

type idoverrideuserModKwParams struct {
  *IdoverrideuserModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserModResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserModResult `json:"result"`
}

type IdoverrideuserModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idoverrideuser `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverrideuserModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserModResult%v", string(b))
}

/*
Remove one or more certificates to the idoverrideuser entry
*/
func (c *Client) IdoverrideuserRemoveCert(
  reqArgs *IdoverrideuserRemoveCertArgs,
  optArgs *IdoverrideuserRemoveCertOptionalArgs, // can be nil
) (*IdoverrideuserRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserRemoveCertKwParams{
    IdoverrideuserRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_remove_cert",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserRemoveCertArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type IdoverrideuserRemoveCertOptionalArgs struct {
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverrideuserRemoveCertKwParams struct {
  *IdoverrideuserRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserRemoveCertResult `json:"result"`
}

type IdoverrideuserRemoveCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverrideuserRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserRemoveCertResult%v", string(b))
}

/*
Display information about an User ID override.
*/
func (c *Client) IdoverrideuserShow(
  reqArgs *IdoverrideuserShowArgs,
  optArgs *IdoverrideuserShowOptionalArgs, // can be nil
) (*IdoverrideuserShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserShowKwParams{
    IdoverrideuserShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_show",
    Params: []interface{}{
      []interface{}{reqArgs.Idviewcn, reqArgs.Ipaanchoruuid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserShowArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverrideuserShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverrideuserShowKwParams struct {
  *IdoverrideuserShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserShowResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserShowResult `json:"result"`
}

type IdoverrideuserShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idoverrideuser `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdoverrideuserShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserShowResult%v", string(b))
}

/*
Add new ID range.

    To add a new ID range you always have to specify

        --base-id
        --range-size

    Additionally

        --rid-base
        --secondary-rid-base

    may be given for a new ID range for the local domain while

        --rid-base
        --dom-sid

    must be given to add a new range for a trusted AD domain.

=======
WARNING:

DNA plugin in 389-ds will allocate IDs based on the ranges configured for the
local domain. Currently the DNA plugin *cannot* be reconfigured itself based
on the local ranges set via this family of commands.

Manual configuration change has to be done in the DNA plugin configuration for
the new local range. Specifically, The dnaNextRange attribute of 'cn=Posix
IDs,cn=Distributed Numeric Assignment Plugin,cn=plugins,cn=config' has to be
modified to match the new range.
=======
*/
func (c *Client) IdrangeAdd(
  reqArgs *IdrangeAddArgs,
  optArgs *IdrangeAddOptionalArgs, // can be nil
) (*IdrangeAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeAddKwParams{
    IdrangeAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Ipabaseid, reqArgs.Ipaidrangesize, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeAddArgs struct {
  
    /*
Range name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
First Posix ID of the range

    */
    Ipabaseid int `json:"ipabaseid,omitempty"`
  
    /*
Number of IDs in the range

    */
    Ipaidrangesize int `json:"ipaidrangesize,omitempty"`
  }

type IdrangeAddOptionalArgs struct {
  
    /*
First RID of the corresponding RID range

    */
    Ipabaserid *int `json:"ipabaserid,omitempty"`
  
    /*
First RID of the secondary RID range

    */
    Ipasecondarybaserid *int `json:"ipasecondarybaserid,omitempty"`
  
    /*
Domain SID of the trusted domain

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Name of the trusted domain

    */
    Ipanttrusteddomainname *string `json:"ipanttrusteddomainname,omitempty"`
  
    /*
Range type
ID range type, one of ipa-ad-trust, ipa-ad-trust-posix, ipa-local
    */
    Iparangetype *string `json:"iparangetype,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idrangeAddKwParams struct {
  *IdrangeAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeAddResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeAddResult `json:"result"`
}

type IdrangeAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idrange `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdrangeAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeAddResult%v", string(b))
}

/*
Delete an ID range.
*/
func (c *Client) IdrangeDel(
  reqArgs *IdrangeDelArgs,
  optArgs *IdrangeDelOptionalArgs, // can be nil
) (*IdrangeDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeDelKwParams{
    IdrangeDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeDelArgs struct {
  
    /*
Range name

    */
    Cn []string `json:"cn,omitempty"`
  }

type IdrangeDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type idrangeDelKwParams struct {
  *IdrangeDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeDelResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeDelResult `json:"result"`
}

type IdrangeDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Idrange `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdrangeDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeDelResult%v", string(b))
}

/*
Search for ranges.
*/
func (c *Client) IdrangeFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *IdrangeFindArgs,
  optArgs *IdrangeFindOptionalArgs, // can be nil
) (*IdrangeFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeFindKwParams{
    IdrangeFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeFindArgs struct {
  }

type IdrangeFindOptionalArgs struct {
  
    /*
Range name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
First Posix ID of the range

    */
    Ipabaseid *int `json:"ipabaseid,omitempty"`
  
    /*
Number of IDs in the range

    */
    Ipaidrangesize *int `json:"ipaidrangesize,omitempty"`
  
    /*
First RID of the corresponding RID range

    */
    Ipabaserid *int `json:"ipabaserid,omitempty"`
  
    /*
First RID of the secondary RID range

    */
    Ipasecondarybaserid *int `json:"ipasecondarybaserid,omitempty"`
  
    /*
Domain SID of the trusted domain

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Range type
ID range type, one of ipa-ad-trust, ipa-ad-trust-posix, ipa-local
    */
    Iparangetype *string `json:"iparangetype,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type idrangeFindKwParams struct {
  *IdrangeFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeFindResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeFindResult `json:"result"`
}

type IdrangeFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Idrange `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *IdrangeFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeFindResult%v", string(b))
}

/*
Modify ID range.

=======
WARNING:

DNA plugin in 389-ds will allocate IDs based on the ranges configured for the
local domain. Currently the DNA plugin *cannot* be reconfigured itself based
on the local ranges set via this family of commands.

Manual configuration change has to be done in the DNA plugin configuration for
the new local range. Specifically, The dnaNextRange attribute of 'cn=Posix
IDs,cn=Distributed Numeric Assignment Plugin,cn=plugins,cn=config' has to be
modified to match the new range.
=======
*/
func (c *Client) IdrangeMod(
  reqArgs *IdrangeModArgs,
  optArgs *IdrangeModOptionalArgs, // can be nil
) (*IdrangeModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeModKwParams{
    IdrangeModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeModArgs struct {
  
    /*
Range name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdrangeModOptionalArgs struct {
  
    /*
First Posix ID of the range

    */
    Ipabaseid *int `json:"ipabaseid,omitempty"`
  
    /*
Number of IDs in the range

    */
    Ipaidrangesize *int `json:"ipaidrangesize,omitempty"`
  
    /*
First RID of the corresponding RID range

    */
    Ipabaserid *int `json:"ipabaserid,omitempty"`
  
    /*
First RID of the secondary RID range

    */
    Ipasecondarybaserid *int `json:"ipasecondarybaserid,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Domain SID of the trusted domain

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Name of the trusted domain

    */
    Ipanttrusteddomainname *string `json:"ipanttrusteddomainname,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idrangeModKwParams struct {
  *IdrangeModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeModResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeModResult `json:"result"`
}

type IdrangeModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idrange `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdrangeModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeModResult%v", string(b))
}

/*
Display information about a range.
*/
func (c *Client) IdrangeShow(
  reqArgs *IdrangeShowArgs,
  optArgs *IdrangeShowOptionalArgs, // can be nil
) (*IdrangeShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeShowKwParams{
    IdrangeShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeShowArgs struct {
  
    /*
Range name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdrangeShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idrangeShowKwParams struct {
  *IdrangeShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeShowResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeShowResult `json:"result"`
}

type IdrangeShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idrange `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdrangeShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeShowResult%v", string(b))
}

/*
Add a new ID View.
*/
func (c *Client) IdviewAdd(
  reqArgs *IdviewAddArgs,
  optArgs *IdviewAddOptionalArgs, // can be nil
) (*IdviewAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewAddKwParams{
    IdviewAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewAddArgs struct {
  
    /*
ID View Name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdviewAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *string `json:"ipadomainresolutionorder,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idviewAddKwParams struct {
  *IdviewAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewAddResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewAddResult `json:"result"`
}

type IdviewAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idview `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdviewAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewAddResult%v", string(b))
}

/*
Applies ID View to specified hosts or current members of specified hostgroups. If any other ID View is applied to the host, it is overridden.
*/
func (c *Client) IdviewApply(
  reqArgs *IdviewApplyArgs,
  optArgs *IdviewApplyOptionalArgs, // can be nil
) (*IdviewApplyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewApplyKwParams{
    IdviewApplyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_apply",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewApplyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewApplyArgs struct {
  
    /*
ID View Name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdviewApplyOptionalArgs struct {
  
    /*
hosts
Hosts to apply the ID View to
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
hostgroups
Hostgroups to whose hosts apply the ID View to. Please note that view is not applied automatically to any hosts added to the hostgroup after running the idview-apply command.
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type idviewApplyKwParams struct {
  *IdviewApplyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewApplyResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewApplyResult `json:"result"`
}

type IdviewApplyResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
Hosts that this ID View was applied to.
    (required)
    */
    Succeeded interface{} `json:"succeeded,omitempty"`
  
    /*
Hosts or hostgroups that this ID View could not be applied to.
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of hosts the ID View was applied to:
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *IdviewApplyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewApplyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewApplyResult%v", string(b))
}

/*
Delete an ID View.
*/
func (c *Client) IdviewDel(
  reqArgs *IdviewDelArgs,
  optArgs *IdviewDelOptionalArgs, // can be nil
) (*IdviewDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewDelKwParams{
    IdviewDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewDelArgs struct {
  
    /*
ID View Name

    */
    Cn []string `json:"cn,omitempty"`
  }

type IdviewDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type idviewDelKwParams struct {
  *IdviewDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewDelResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewDelResult `json:"result"`
}

type IdviewDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Idview `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdviewDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewDelResult%v", string(b))
}

/*
Search for an ID View.
*/
func (c *Client) IdviewFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *IdviewFindArgs,
  optArgs *IdviewFindOptionalArgs, // can be nil
) (*IdviewFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewFindKwParams{
    IdviewFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewFindArgs struct {
  }

type IdviewFindOptionalArgs struct {
  
    /*
ID View Name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type idviewFindKwParams struct {
  *IdviewFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewFindResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewFindResult `json:"result"`
}

type IdviewFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Idview `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *IdviewFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewFindResult%v", string(b))
}

/*
Modify an ID View.
*/
func (c *Client) IdviewMod(
  reqArgs *IdviewModArgs,
  optArgs *IdviewModOptionalArgs, // can be nil
) (*IdviewModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewModKwParams{
    IdviewModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewModArgs struct {
  
    /*
ID View Name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdviewModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *string `json:"ipadomainresolutionorder,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the ID View object
    */
    Rename *string `json:"rename,omitempty"`
  }

type idviewModKwParams struct {
  *IdviewModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewModResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewModResult `json:"result"`
}

type IdviewModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idview `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdviewModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewModResult%v", string(b))
}

/*
Display information about an ID View.
*/
func (c *Client) IdviewShow(
  reqArgs *IdviewShowArgs,
  optArgs *IdviewShowOptionalArgs, // can be nil
) (*IdviewShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewShowKwParams{
    IdviewShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewShowArgs struct {
  
    /*
ID View Name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdviewShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Enumerate all the hosts the view applies to.
    */
    ShowHosts *bool `json:"show_hosts,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idviewShowKwParams struct {
  *IdviewShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewShowResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewShowResult `json:"result"`
}

type IdviewShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Idview `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *IdviewShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewShowResult%v", string(b))
}

/*
Clears ID View from specified hosts or current members of specified hostgroups.
*/
func (c *Client) IdviewUnapply(
  reqArgs *IdviewUnapplyArgs,
  optArgs *IdviewUnapplyOptionalArgs, // can be nil
) (*IdviewUnapplyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewUnapplyKwParams{
    IdviewUnapplyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_unapply",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewUnapplyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewUnapplyArgs struct {
  }

type IdviewUnapplyOptionalArgs struct {
  
    /*
hosts
Hosts to clear (any) ID View from.
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
hostgroups
Hostgroups whose hosts should have ID Views cleared. Note that view is not cleared automatically from any host added to the hostgroup after running idview-unapply command.
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type idviewUnapplyKwParams struct {
  *IdviewUnapplyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewUnapplyResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewUnapplyResult `json:"result"`
}

type IdviewUnapplyResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
Hosts that ID View was cleared from.
    (required)
    */
    Succeeded interface{} `json:"succeeded,omitempty"`
  
    /*
Hosts or hostgroups that ID View could not be cleared from.
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of hosts that had a ID View was unset:
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *IdviewUnapplyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewUnapplyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewUnapplyResult%v", string(b))
}

/*
Join an IPA domain
*/
func (c *Client) Join(
  reqArgs *JoinArgs,
  optArgs *JoinOptionalArgs, // can be nil
) (*JoinResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := joinKwParams{
    JoinOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "join",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res joinResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type JoinArgs struct {
  
    /*

The hostname to register as
    */
    Cn string `json:"cn,omitempty"`
  }

type JoinOptionalArgs struct {
  
    /*

The IPA realm
    */
    Realm *string `json:"realm,omitempty"`
  
    /*

Hardware platform of the host (e.g. Lenovo T61)
    */
    Nshardwareplatform *string `json:"nshardwareplatform,omitempty"`
  
    /*

Operating System and version of the host (e.g. Fedora 9)
    */
    Nsosversion *string `json:"nsosversion,omitempty"`
  }

type joinKwParams struct {
  *JoinOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type joinResponse struct {
	Error  *Error      `json:"error"`
	Result *JoinResult `json:"result"`
}

type JoinResult struct {
  
  }

func (t *JoinResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("JoinResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("JoinResult%v", string(b))
}

/*
Export plugin meta-data for the webUI.
*/
func (c *Client) JSONMetadata(
  objname string, // Name of object to export
  methodname string, // Name of method to export
  reqArgs *JSONMetadataArgs,
  optArgs *JSONMetadataOptionalArgs, // can be nil
) (*JSONMetadataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := jsonMetadataKwParams{
    JSONMetadataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "json_metadata",
    Params: []interface{}{
      []interface{}{objname, methodname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res jsonMetadataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type JSONMetadataArgs struct {
  }

type JSONMetadataOptionalArgs struct {
  
    /*

Name of object to export
    */
    Object *string `json:"object,omitempty"`
  
    /*

Name of method to export
    */
    Method *string `json:"method,omitempty"`
  
    /*

Name of command to export
    */
    Command *string `json:"command,omitempty"`
  }

type jsonMetadataKwParams struct {
  *JSONMetadataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type jsonMetadataResponse struct {
	Error  *Error      `json:"error"`
	Result *JSONMetadataResult `json:"result"`
}

type JSONMetadataResult struct {
  
  
    /*
Dict of JSON encoded IPA Objects
    (required)
    */
    Objects interface{} `json:"objects,omitempty"`
  
    /*
Dict of JSON encoded IPA Methods
    (required)
    */
    Methods interface{} `json:"methods,omitempty"`
  
    /*
Dict of JSON encoded IPA Commands
    (required)
    */
    Commands interface{} `json:"commands,omitempty"`
  }

func (t *JSONMetadataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("JSONMetadataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("JSONMetadataResult%v", string(b))
}

/*

*/
func (c *Client) KraIsEnabled(
  reqArgs *KraIsEnabledArgs,
  optArgs *KraIsEnabledOptionalArgs, // can be nil
) (*KraIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := kraIsEnabledKwParams{
    KraIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "kra_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res kraIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type KraIsEnabledArgs struct {
  }

type KraIsEnabledOptionalArgs struct {
  }

type kraIsEnabledKwParams struct {
  *KraIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type kraIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *KraIsEnabledResult `json:"result"`
}

type KraIsEnabledResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *KraIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("KraIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("KraIsEnabledResult%v", string(b))
}

/*
Modify Kerberos ticket policy.
*/
func (c *Client) KrbtpolicyMod(
  uid string, // Manage ticket policy for specific user
  reqArgs *KrbtpolicyModArgs,
  optArgs *KrbtpolicyModOptionalArgs, // can be nil
) (*KrbtpolicyModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := krbtpolicyModKwParams{
    KrbtpolicyModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "krbtpolicy_mod",
    Params: []interface{}{
      []interface{}{uid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res krbtpolicyModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type KrbtpolicyModArgs struct {
  }

type KrbtpolicyModOptionalArgs struct {
  
    /*
Max life
Maximum ticket life (seconds)
    */
    Krbmaxticketlife *int `json:"krbmaxticketlife,omitempty"`
  
    /*
Max renew
Maximum renewable age (seconds)
    */
    Krbmaxrenewableage *int `json:"krbmaxrenewableage,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type krbtpolicyModKwParams struct {
  *KrbtpolicyModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type krbtpolicyModResponse struct {
	Error  *Error      `json:"error"`
	Result *KrbtpolicyModResult `json:"result"`
}

type KrbtpolicyModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Krbtpolicy `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *KrbtpolicyModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("KrbtpolicyModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("KrbtpolicyModResult%v", string(b))
}

/*
Reset Kerberos ticket policy to the default values.
*/
func (c *Client) KrbtpolicyReset(
  uid string, // Manage ticket policy for specific user
  reqArgs *KrbtpolicyResetArgs,
  optArgs *KrbtpolicyResetOptionalArgs, // can be nil
) (*KrbtpolicyResetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := krbtpolicyResetKwParams{
    KrbtpolicyResetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "krbtpolicy_reset",
    Params: []interface{}{
      []interface{}{uid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res krbtpolicyResetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type KrbtpolicyResetArgs struct {
  }

type KrbtpolicyResetOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type krbtpolicyResetKwParams struct {
  *KrbtpolicyResetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type krbtpolicyResetResponse struct {
	Error  *Error      `json:"error"`
	Result *KrbtpolicyResetResult `json:"result"`
}

type KrbtpolicyResetResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *KrbtpolicyResetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("KrbtpolicyResetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("KrbtpolicyResetResult%v", string(b))
}

/*
Display the current Kerberos ticket policy.
*/
func (c *Client) KrbtpolicyShow(
  uid string, // Manage ticket policy for specific user
  reqArgs *KrbtpolicyShowArgs,
  optArgs *KrbtpolicyShowOptionalArgs, // can be nil
) (*KrbtpolicyShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := krbtpolicyShowKwParams{
    KrbtpolicyShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "krbtpolicy_show",
    Params: []interface{}{
      []interface{}{uid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res krbtpolicyShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type KrbtpolicyShowArgs struct {
  }

type KrbtpolicyShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type krbtpolicyShowKwParams struct {
  *KrbtpolicyShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type krbtpolicyShowResponse struct {
	Error  *Error      `json:"error"`
	Result *KrbtpolicyShowResult `json:"result"`
}

type KrbtpolicyShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Krbtpolicy `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *KrbtpolicyShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("KrbtpolicyShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("KrbtpolicyShowResult%v", string(b))
}

/*
Add a new IPA location.
*/
func (c *Client) LocationAdd(
  reqArgs *LocationAddArgs,
  optArgs *LocationAddOptionalArgs, // can be nil
) (*LocationAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationAddKwParams{
    LocationAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_add",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationAddArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type LocationAddOptionalArgs struct {
  
    /*
Description
IPA Location description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type locationAddKwParams struct {
  *LocationAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationAddResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationAddResult `json:"result"`
}

type LocationAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Location `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *LocationAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationAddResult%v", string(b))
}

/*
Delete an IPA location.
*/
func (c *Client) LocationDel(
  reqArgs *LocationDelArgs,
  optArgs *LocationDelOptionalArgs, // can be nil
) (*LocationDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationDelKwParams{
    LocationDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_del",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationDelArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname []string `json:"idnsname,omitempty"`
  }

type LocationDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type locationDelKwParams struct {
  *LocationDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationDelResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationDelResult `json:"result"`
}

type LocationDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Location `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []DNSName `json:"value,omitempty"`
  }

func (t *LocationDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationDelResult%v", string(b))
}

/*
Search for IPA locations.
*/
func (c *Client) LocationFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *LocationFindArgs,
  optArgs *LocationFindOptionalArgs, // can be nil
) (*LocationFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationFindKwParams{
    LocationFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationFindArgs struct {
  }

type LocationFindOptionalArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname *string `json:"idnsname,omitempty"`
  
    /*
Description
IPA Location description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type locationFindKwParams struct {
  *LocationFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationFindResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationFindResult `json:"result"`
}

type LocationFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Location `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *LocationFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationFindResult%v", string(b))
}

/*
Modify information about an IPA location.
*/
func (c *Client) LocationMod(
  reqArgs *LocationModArgs,
  optArgs *LocationModOptionalArgs, // can be nil
) (*LocationModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationModKwParams{
    LocationModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationModArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type LocationModOptionalArgs struct {
  
    /*
Description
IPA Location description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type locationModKwParams struct {
  *LocationModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationModResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationModResult `json:"result"`
}

type LocationModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Location `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  }

func (t *LocationModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationModResult%v", string(b))
}

/*
Display information about an IPA location.
*/
func (c *Client) LocationShow(
  reqArgs *LocationShowArgs,
  optArgs *LocationShowOptionalArgs, // can be nil
) (*LocationShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationShowKwParams{
    LocationShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_show",
    Params: []interface{}{
      []interface{}{reqArgs.Idnsname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationShowArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname string `json:"idnsname,omitempty"`
  }

type LocationShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type locationShowKwParams struct {
  *LocationShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationShowResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationShowResult `json:"result"`
}

type LocationShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Location `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value DNSName `json:"value,omitempty"`
  
    /*
Servers in location
    (required)
    */
    Servers interface{} `json:"servers,omitempty"`
  }

func (t *LocationShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationShowResult%v", string(b))
}

/*
Migrate users and groups from DS to IPA.
*/
func (c *Client) MigrateDs(
  reqArgs *MigrateDsArgs,
  optArgs *MigrateDsOptionalArgs, // can be nil
) (*MigrateDsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := migrateDsKwParams{
    MigrateDsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "migrate_ds",
    Params: []interface{}{
      []interface{}{reqArgs.Ldapuri, reqArgs.Bindpw, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res migrateDsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type MigrateDsArgs struct {
  
    /*
LDAP URI
LDAP URI of DS server to migrate from
    */
    Ldapuri string `json:"ldapuri,omitempty"`
  
    /*
Password
bind password
    */
    Bindpw string `json:"bindpw,omitempty"`
  }

type MigrateDsOptionalArgs struct {
  
    /*
Bind DN

    */
    Binddn *string `json:"binddn,omitempty"`
  
    /*
User container
DN of container for users in DS relative to base DN
    */
    Usercontainer *string `json:"usercontainer,omitempty"`
  
    /*
Group container
DN of container for groups in DS relative to base DN
    */
    Groupcontainer *string `json:"groupcontainer,omitempty"`
  
    /*
User object class
Objectclasses used to search for user entries in DS
    */
    Userobjectclass *[]string `json:"userobjectclass,omitempty"`
  
    /*
Group object class
Objectclasses used to search for group entries in DS
    */
    Groupobjectclass *[]string `json:"groupobjectclass,omitempty"`
  
    /*
Ignore user object class
Objectclasses to be ignored for user entries in DS
    */
    Userignoreobjectclass *[]string `json:"userignoreobjectclass,omitempty"`
  
    /*
Ignore user attribute
Attributes to be ignored for user entries in DS
    */
    Userignoreattribute *[]string `json:"userignoreattribute,omitempty"`
  
    /*
Ignore group object class
Objectclasses to be ignored for group entries in DS
    */
    Groupignoreobjectclass *[]string `json:"groupignoreobjectclass,omitempty"`
  
    /*
Ignore group attribute
Attributes to be ignored for group entries in DS
    */
    Groupignoreattribute *[]string `json:"groupignoreattribute,omitempty"`
  
    /*
Overwrite GID
When migrating a group already existing in IPA domain overwrite the group GID and report as success
    */
    Groupoverwritegid *bool `json:"groupoverwritegid,omitempty"`
  
    /*
LDAP schema
The schema used on the LDAP server. Supported values are RFC2307 and RFC2307bis. The default is RFC2307bis
    */
    Schema *string `json:"schema,omitempty"`
  
    /*
Continue
Continuous operation mode. Errors are reported but the process continues
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Base DN
Base DN on remote LDAP server
    */
    Basedn *string `json:"basedn,omitempty"`
  
    /*
Ignore compat plugin
Allows migration despite the usage of compat plugin
    */
    Compat *bool `json:"compat,omitempty"`
  
    /*
CA certificate
Load CA certificate of LDAP server from FILE
    */
    Cacertfile *string `json:"cacertfile,omitempty"`
  
    /*
Add to default group
Add migrated users without a group to a default group (default: true)
    */
    UseDefGroup *bool `json:"use_def_group,omitempty"`
  
    /*
Search scope
LDAP search scope for users and groups: base, onelevel, or subtree. Defaults to onelevel
    */
    Scope *string `json:"scope,omitempty"`
  
    /*

groups to exclude from migration
    */
    ExcludeGroups *[]string `json:"exclude_groups,omitempty"`
  
    /*

users to exclude from migration
    */
    ExcludeUsers *[]string `json:"exclude_users,omitempty"`
  }

type migrateDsKwParams struct {
  *MigrateDsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type migrateDsResponse struct {
	Error  *Error      `json:"error"`
	Result *MigrateDsResult `json:"result"`
}

type MigrateDsResult struct {
  
  
    /*
Lists of objects migrated; categorized by type.
    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Lists of objects that could not be migrated; categorized by type.
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
False if migration mode was disabled.
    (required)
    */
    Enabled IPAPrim[bool] `json:"enabled,omitempty"`
  
    /*
False if migration fails because the compatibility plug-in is enabled.
    (required)
    */
    Compat IPAPrim[bool] `json:"compat,omitempty"`
  }

func (t *MigrateDsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("MigrateDsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("MigrateDsResult%v", string(b))
}

/*
Add a new netgroup.
*/
func (c *Client) NetgroupAdd(
  reqArgs *NetgroupAddArgs,
  optArgs *NetgroupAddOptionalArgs, // can be nil
) (*NetgroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupAddKwParams{
    NetgroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupAddArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupAddOptionalArgs struct {
  
    /*
Description
Netgroup description
    */
    Description *string `json:"description,omitempty"`
  
    /*
NIS domain name

    */
    Nisdomainname *string `json:"nisdomainname,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type netgroupAddKwParams struct {
  *NetgroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupAddResult `json:"result"`
}

type NetgroupAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Netgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *NetgroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupAddResult%v", string(b))
}

/*
Add members to a netgroup.
*/
func (c *Client) NetgroupAddMember(
  reqArgs *NetgroupAddMemberArgs,
  optArgs *NetgroupAddMemberOptionalArgs, // can be nil
) (*NetgroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupAddMemberKwParams{
    NetgroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupAddMemberArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
member netgroup
netgroups to add
    */
    Netgroup *[]string `json:"netgroup,omitempty"`
  }

type netgroupAddMemberKwParams struct {
  *NetgroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupAddMemberResult `json:"result"`
}

type NetgroupAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *NetgroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupAddMemberResult%v", string(b))
}

/*
Delete a netgroup.
*/
func (c *Client) NetgroupDel(
  reqArgs *NetgroupDelArgs,
  optArgs *NetgroupDelOptionalArgs, // can be nil
) (*NetgroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupDelKwParams{
    NetgroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupDelArgs struct {
  
    /*
Netgroup name

    */
    Cn []string `json:"cn,omitempty"`
  }

type NetgroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type netgroupDelKwParams struct {
  *NetgroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupDelResult `json:"result"`
}

type NetgroupDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Netgroup `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *NetgroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupDelResult%v", string(b))
}

/*
Search for a netgroup.
*/
func (c *Client) NetgroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *NetgroupFindArgs,
  optArgs *NetgroupFindOptionalArgs, // can be nil
) (*NetgroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupFindKwParams{
    NetgroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupFindArgs struct {
  }

type NetgroupFindOptionalArgs struct {
  
    /*
Netgroup name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Netgroup description
    */
    Description *string `json:"description,omitempty"`
  
    /*
NIS domain name

    */
    Nisdomainname *string `json:"nisdomainname,omitempty"`
  
    /*
IPA unique ID
IPA unique ID
    */
    Ipauniqueid *string `json:"ipauniqueid,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*


    */
    Private *bool `json:"private,omitempty"`
  
    /*

search for managed groups
    */
    Managed *bool `json:"managed,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
netgroup
Search for netgroups with these member netgroups.
    */
    Netgroup *[]string `json:"netgroup,omitempty"`
  
    /*
netgroup
Search for netgroups without these member netgroups.
    */
    NoNetgroup *[]string `json:"no_netgroup,omitempty"`
  
    /*
user
Search for netgroups with these member users.
    */
    User *[]string `json:"user,omitempty"`
  
    /*
user
Search for netgroups without these member users.
    */
    NoUser *[]string `json:"no_user,omitempty"`
  
    /*
group
Search for netgroups with these member groups.
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
group
Search for netgroups without these member groups.
    */
    NoGroup *[]string `json:"no_group,omitempty"`
  
    /*
host
Search for netgroups with these member hosts.
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
host
Search for netgroups without these member hosts.
    */
    NoHost *[]string `json:"no_host,omitempty"`
  
    /*
host group
Search for netgroups with these member host groups.
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
host group
Search for netgroups without these member host groups.
    */
    NoHostgroup *[]string `json:"no_hostgroup,omitempty"`
  
    /*
netgroup
Search for netgroups with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for netgroups without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  }

type netgroupFindKwParams struct {
  *NetgroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupFindResult `json:"result"`
}

type NetgroupFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Netgroup `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *NetgroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupFindResult%v", string(b))
}

/*
Modify a netgroup.
*/
func (c *Client) NetgroupMod(
  reqArgs *NetgroupModArgs,
  optArgs *NetgroupModOptionalArgs, // can be nil
) (*NetgroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupModKwParams{
    NetgroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupModArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupModOptionalArgs struct {
  
    /*
Description
Netgroup description
    */
    Description *string `json:"description,omitempty"`
  
    /*
NIS domain name

    */
    Nisdomainname *string `json:"nisdomainname,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type netgroupModKwParams struct {
  *NetgroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupModResult `json:"result"`
}

type NetgroupModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Netgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *NetgroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupModResult%v", string(b))
}

/*
Remove members from a netgroup.
*/
func (c *Client) NetgroupRemoveMember(
  reqArgs *NetgroupRemoveMemberArgs,
  optArgs *NetgroupRemoveMemberOptionalArgs, // can be nil
) (*NetgroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupRemoveMemberKwParams{
    NetgroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupRemoveMemberArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
member netgroup
netgroups to remove
    */
    Netgroup *[]string `json:"netgroup,omitempty"`
  }

type netgroupRemoveMemberKwParams struct {
  *NetgroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupRemoveMemberResult `json:"result"`
}

type NetgroupRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *NetgroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupRemoveMemberResult%v", string(b))
}

/*
Display information about a netgroup.
*/
func (c *Client) NetgroupShow(
  reqArgs *NetgroupShowArgs,
  optArgs *NetgroupShowOptionalArgs, // can be nil
) (*NetgroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupShowKwParams{
    NetgroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupShowArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type netgroupShowKwParams struct {
  *NetgroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupShowResult `json:"result"`
}

type NetgroupShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Netgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *NetgroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupShowResult%v", string(b))
}

/*
Modify OTP configuration options.
*/
func (c *Client) OtpconfigMod(
  reqArgs *OtpconfigModArgs,
  optArgs *OtpconfigModOptionalArgs, // can be nil
) (*OtpconfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otpconfigModKwParams{
    OtpconfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otpconfig_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otpconfigModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtpconfigModArgs struct {
  }

type OtpconfigModOptionalArgs struct {
  
    /*
TOTP authentication Window
TOTP authentication time variance (seconds)
    */
    Ipatokentotpauthwindow *int `json:"ipatokentotpauthwindow,omitempty"`
  
    /*
TOTP Synchronization Window
TOTP synchronization time variance (seconds)
    */
    Ipatokentotpsyncwindow *int `json:"ipatokentotpsyncwindow,omitempty"`
  
    /*
HOTP Authentication Window
HOTP authentication skip-ahead
    */
    Ipatokenhotpauthwindow *int `json:"ipatokenhotpauthwindow,omitempty"`
  
    /*
HOTP Synchronization Window
HOTP synchronization skip-ahead
    */
    Ipatokenhotpsyncwindow *int `json:"ipatokenhotpsyncwindow,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type otpconfigModKwParams struct {
  *OtpconfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otpconfigModResponse struct {
	Error  *Error      `json:"error"`
	Result *OtpconfigModResult `json:"result"`
}

type OtpconfigModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Otpconfig `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *OtpconfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtpconfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtpconfigModResult%v", string(b))
}

/*
Show the current OTP configuration.
*/
func (c *Client) OtpconfigShow(
  reqArgs *OtpconfigShowArgs,
  optArgs *OtpconfigShowOptionalArgs, // can be nil
) (*OtpconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otpconfigShowKwParams{
    OtpconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otpconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otpconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtpconfigShowArgs struct {
  }

type OtpconfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type otpconfigShowKwParams struct {
  *OtpconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otpconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *OtpconfigShowResult `json:"result"`
}

type OtpconfigShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Otpconfig `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *OtpconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtpconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtpconfigShowResult%v", string(b))
}

/*
Add a new OTP token.
*/
func (c *Client) OtptokenAdd(
  ipatokenuniqueid string, // 
  reqArgs *OtptokenAddArgs,
  optArgs *OtptokenAddOptionalArgs, // can be nil
) (*OtptokenAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenAddKwParams{
    OtptokenAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_add",
    Params: []interface{}{
      []interface{}{ipatokenuniqueid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenAddArgs struct {
  }

type OtptokenAddOptionalArgs struct {
  
    /*
Type
Type of the token
    */
    Type *string `json:"type,omitempty"`
  
    /*
Description
Token description (informational only)
    */
    Description *string `json:"description,omitempty"`
  
    /*
Owner
Assigned user of the token (default: self)
    */
    Ipatokenowner *string `json:"ipatokenowner,omitempty"`
  
    /*
Disabled
Mark the token as disabled (default: false)
    */
    Ipatokendisabled *bool `json:"ipatokendisabled,omitempty"`
  
    /*
Validity start
First date/time the token can be used
    */
    Ipatokennotbefore *time.Time `json:"ipatokennotbefore,omitempty"`
  
    /*
Validity end
Last date/time the token can be used
    */
    Ipatokennotafter *time.Time `json:"ipatokennotafter,omitempty"`
  
    /*
Vendor
Token vendor name (informational only)
    */
    Ipatokenvendor *string `json:"ipatokenvendor,omitempty"`
  
    /*
Model
Token model (informational only)
    */
    Ipatokenmodel *string `json:"ipatokenmodel,omitempty"`
  
    /*
Serial
Token serial (informational only)
    */
    Ipatokenserial *string `json:"ipatokenserial,omitempty"`
  
    /*
Key
Token secret (Base32; default: random)
    */
    Ipatokenotpkey *string `json:"ipatokenotpkey,omitempty"`
  
    /*
Algorithm
Token hash algorithm
    */
    Ipatokenotpalgorithm *string `json:"ipatokenotpalgorithm,omitempty"`
  
    /*
Digits
Number of digits each token code will have
    */
    Ipatokenotpdigits *int `json:"ipatokenotpdigits,omitempty"`
  
    /*
Clock offset
TOTP token / FreeIPA server time difference
    */
    Ipatokentotpclockoffset *int `json:"ipatokentotpclockoffset,omitempty"`
  
    /*
Clock interval
Length of TOTP token code validity
    */
    Ipatokentotptimestep *int `json:"ipatokentotptimestep,omitempty"`
  
    /*
Counter
Initial counter for the HOTP token
    */
    Ipatokenhotpcounter *int `json:"ipatokenhotpcounter,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
(deprecated)

    */
    Qrcode *bool `json:"qrcode,omitempty"`
  
    /*
Do not display QR code

    */
    NoQrcode *bool `json:"no_qrcode,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type otptokenAddKwParams struct {
  *OtptokenAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenAddResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenAddResult `json:"result"`
}

type OtptokenAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Otptoken `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *OtptokenAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenAddResult%v", string(b))
}

/*
Add users that can manage this token.
*/
func (c *Client) OtptokenAddManagedby(
  reqArgs *OtptokenAddManagedbyArgs,
  optArgs *OtptokenAddManagedbyOptionalArgs, // can be nil
) (*OtptokenAddManagedbyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenAddManagedbyKwParams{
    OtptokenAddManagedbyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_add_managedby",
    Params: []interface{}{
      []interface{}{reqArgs.Ipatokenuniqueid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenAddManagedbyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenAddManagedbyArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenAddManagedbyOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  }

type otptokenAddManagedbyKwParams struct {
  *OtptokenAddManagedbyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenAddManagedbyResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenAddManagedbyResult `json:"result"`
}

type OtptokenAddManagedbyResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *OtptokenAddManagedbyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenAddManagedbyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenAddManagedbyResult%v", string(b))
}

/*
Delete an OTP token.
*/
func (c *Client) OtptokenDel(
  reqArgs *OtptokenDelArgs,
  optArgs *OtptokenDelOptionalArgs, // can be nil
) (*OtptokenDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenDelKwParams{
    OtptokenDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_del",
    Params: []interface{}{
      []interface{}{reqArgs.Ipatokenuniqueid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenDelArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid []string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type otptokenDelKwParams struct {
  *OtptokenDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenDelResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenDelResult `json:"result"`
}

type OtptokenDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Otptoken `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *OtptokenDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenDelResult%v", string(b))
}

/*
Search for OTP token.
*/
func (c *Client) OtptokenFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *OtptokenFindArgs,
  optArgs *OtptokenFindOptionalArgs, // can be nil
) (*OtptokenFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenFindKwParams{
    OtptokenFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenFindArgs struct {
  }

type OtptokenFindOptionalArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid *string `json:"ipatokenuniqueid,omitempty"`
  
    /*
Type
Type of the token
    */
    Type *string `json:"type,omitempty"`
  
    /*
Description
Token description (informational only)
    */
    Description *string `json:"description,omitempty"`
  
    /*
Owner
Assigned user of the token (default: self)
    */
    Ipatokenowner *string `json:"ipatokenowner,omitempty"`
  
    /*
Disabled
Mark the token as disabled (default: false)
    */
    Ipatokendisabled *bool `json:"ipatokendisabled,omitempty"`
  
    /*
Validity start
First date/time the token can be used
    */
    Ipatokennotbefore *time.Time `json:"ipatokennotbefore,omitempty"`
  
    /*
Validity end
Last date/time the token can be used
    */
    Ipatokennotafter *time.Time `json:"ipatokennotafter,omitempty"`
  
    /*
Vendor
Token vendor name (informational only)
    */
    Ipatokenvendor *string `json:"ipatokenvendor,omitempty"`
  
    /*
Model
Token model (informational only)
    */
    Ipatokenmodel *string `json:"ipatokenmodel,omitempty"`
  
    /*
Serial
Token serial (informational only)
    */
    Ipatokenserial *string `json:"ipatokenserial,omitempty"`
  
    /*
Algorithm
Token hash algorithm
    */
    Ipatokenotpalgorithm *string `json:"ipatokenotpalgorithm,omitempty"`
  
    /*
Digits
Number of digits each token code will have
    */
    Ipatokenotpdigits *int `json:"ipatokenotpdigits,omitempty"`
  
    /*
Clock offset
TOTP token / FreeIPA server time difference
    */
    Ipatokentotpclockoffset *int `json:"ipatokentotpclockoffset,omitempty"`
  
    /*
Clock interval
Length of TOTP token code validity
    */
    Ipatokentotptimestep *int `json:"ipatokentotptimestep,omitempty"`
  
    /*
Counter
Initial counter for the HOTP token
    */
    Ipatokenhotpcounter *int `json:"ipatokenhotpcounter,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("id")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type otptokenFindKwParams struct {
  *OtptokenFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenFindResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenFindResult `json:"result"`
}

type OtptokenFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Otptoken `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *OtptokenFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenFindResult%v", string(b))
}

/*
Modify a OTP token.
*/
func (c *Client) OtptokenMod(
  reqArgs *OtptokenModArgs,
  optArgs *OtptokenModOptionalArgs, // can be nil
) (*OtptokenModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenModKwParams{
    OtptokenModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Ipatokenuniqueid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenModArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenModOptionalArgs struct {
  
    /*
Description
Token description (informational only)
    */
    Description *string `json:"description,omitempty"`
  
    /*
Owner
Assigned user of the token (default: self)
    */
    Ipatokenowner *string `json:"ipatokenowner,omitempty"`
  
    /*
Disabled
Mark the token as disabled (default: false)
    */
    Ipatokendisabled *bool `json:"ipatokendisabled,omitempty"`
  
    /*
Validity start
First date/time the token can be used
    */
    Ipatokennotbefore *time.Time `json:"ipatokennotbefore,omitempty"`
  
    /*
Validity end
Last date/time the token can be used
    */
    Ipatokennotafter *time.Time `json:"ipatokennotafter,omitempty"`
  
    /*
Vendor
Token vendor name (informational only)
    */
    Ipatokenvendor *string `json:"ipatokenvendor,omitempty"`
  
    /*
Model
Token model (informational only)
    */
    Ipatokenmodel *string `json:"ipatokenmodel,omitempty"`
  
    /*
Serial
Token serial (informational only)
    */
    Ipatokenserial *string `json:"ipatokenserial,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the OTP token object
    */
    Rename *string `json:"rename,omitempty"`
  }

type otptokenModKwParams struct {
  *OtptokenModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenModResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenModResult `json:"result"`
}

type OtptokenModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Otptoken `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *OtptokenModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenModResult%v", string(b))
}

/*
Remove users that can manage this token.
*/
func (c *Client) OtptokenRemoveManagedby(
  reqArgs *OtptokenRemoveManagedbyArgs,
  optArgs *OtptokenRemoveManagedbyOptionalArgs, // can be nil
) (*OtptokenRemoveManagedbyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenRemoveManagedbyKwParams{
    OtptokenRemoveManagedbyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_remove_managedby",
    Params: []interface{}{
      []interface{}{reqArgs.Ipatokenuniqueid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenRemoveManagedbyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenRemoveManagedbyArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenRemoveManagedbyOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  }

type otptokenRemoveManagedbyKwParams struct {
  *OtptokenRemoveManagedbyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenRemoveManagedbyResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenRemoveManagedbyResult `json:"result"`
}

type OtptokenRemoveManagedbyResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *OtptokenRemoveManagedbyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenRemoveManagedbyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenRemoveManagedbyResult%v", string(b))
}

/*
Display information about an OTP token.
*/
func (c *Client) OtptokenShow(
  reqArgs *OtptokenShowArgs,
  optArgs *OtptokenShowOptionalArgs, // can be nil
) (*OtptokenShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenShowKwParams{
    OtptokenShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_show",
    Params: []interface{}{
      []interface{}{reqArgs.Ipatokenuniqueid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenShowArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type otptokenShowKwParams struct {
  *OtptokenShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenShowResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenShowResult `json:"result"`
}

type OtptokenShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Otptoken `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *OtptokenShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenShowResult%v", string(b))
}

/*
Search for command outputs.
*/
func (c *Client) OutputFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *OutputFindArgs,
  optArgs *OutputFindOptionalArgs, // can be nil
) (*OutputFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := outputFindKwParams{
    OutputFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "output_find",
    Params: []interface{}{
      []interface{}{reqArgs.CommandfullName, criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res outputFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OutputFindArgs struct {
  
    /*
Full name

    */
    CommandfullName string `json:"commandfull_name,omitempty"`
  }

type OutputFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type outputFindKwParams struct {
  *OutputFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type outputFindResponse struct {
	Error  *Error      `json:"error"`
	Result *OutputFindResult `json:"result"`
}

type OutputFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Output `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *OutputFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OutputFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OutputFindResult%v", string(b))
}

/*
Display information about a command output.
*/
func (c *Client) OutputShow(
  reqArgs *OutputShowArgs,
  optArgs *OutputShowOptionalArgs, // can be nil
) (*OutputShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := outputShowKwParams{
    OutputShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "output_show",
    Params: []interface{}{
      []interface{}{reqArgs.CommandfullName, reqArgs.Name, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res outputShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OutputShowArgs struct {
  
    /*
Full name

    */
    CommandfullName string `json:"commandfull_name,omitempty"`
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  }

type OutputShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type outputShowKwParams struct {
  *OutputShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type outputShowResponse struct {
	Error  *Error      `json:"error"`
	Result *OutputShowResult `json:"result"`
}

type OutputShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Output `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *OutputShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OutputShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OutputShowResult%v", string(b))
}

/*
Search command parameters.
*/
func (c *Client) ParamFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ParamFindArgs,
  optArgs *ParamFindOptionalArgs, // can be nil
) (*ParamFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := paramFindKwParams{
    ParamFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "param_find",
    Params: []interface{}{
      []interface{}{reqArgs.MetaobjectfullName, criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res paramFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ParamFindArgs struct {
  
    /*
Full name

    */
    MetaobjectfullName string `json:"metaobjectfull_name,omitempty"`
  }

type ParamFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type paramFindKwParams struct {
  *ParamFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type paramFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ParamFindResult `json:"result"`
}

type ParamFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Param `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *ParamFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ParamFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ParamFindResult%v", string(b))
}

/*
Display information about a command parameter.
*/
func (c *Client) ParamShow(
  reqArgs *ParamShowArgs,
  optArgs *ParamShowOptionalArgs, // can be nil
) (*ParamShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := paramShowKwParams{
    ParamShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "param_show",
    Params: []interface{}{
      []interface{}{reqArgs.MetaobjectfullName, reqArgs.Name, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res paramShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ParamShowArgs struct {
  
    /*
Full name

    */
    MetaobjectfullName string `json:"metaobjectfull_name,omitempty"`
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  }

type ParamShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type paramShowKwParams struct {
  *ParamShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type paramShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ParamShowResult `json:"result"`
}

type ParamShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Param `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ParamShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ParamShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ParamShowResult%v", string(b))
}

/*
Set a user's password.
*/
func (c *Client) Passwd(
  reqArgs *PasswdArgs,
  optArgs *PasswdOptionalArgs, // can be nil
) (*PasswdResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := passwdKwParams{
    PasswdOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "passwd",
    Params: []interface{}{
      []interface{}{reqArgs.Principal, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res passwdResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PasswdArgs struct {
  
    /*
User name

    */
    Principal string `json:"principal,omitempty"`
  }

type PasswdOptionalArgs struct {
  
    /*
New Password

    */
    Password *string `json:"password,omitempty"`
  
    /*
Current Password

    */
    CurrentPassword *string `json:"current_password,omitempty"`
  
    /*
OTP
One Time Password
    */
    Otp *string `json:"otp,omitempty"`
  }

type passwdKwParams struct {
  *PasswdOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type passwdResponse struct {
	Error  *Error      `json:"error"`
	Result *PasswdResult `json:"result"`
}

type PasswdResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PasswdResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PasswdResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PasswdResult%v", string(b))
}

/*
Add a new permission.
*/
func (c *Client) PermissionAdd(
  reqArgs *PermissionAddArgs,
  optArgs *PermissionAddOptionalArgs, // can be nil
) (*PermissionAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionAddKwParams{
    PermissionAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionAddArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionAddOptionalArgs struct {
  
    /*
Granted rights
Rights to grant (read, search, compare, write, add, delete, all)
    */
    Ipapermright *[]string `json:"ipapermright,omitempty"`
  
    /*
Effective attributes
All attributes to which the permission applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Bind rule type
Bind rule type
    */
    Ipapermbindruletype *string `json:"ipapermbindruletype,omitempty"`
  
    /*
Subtree
Subtree to apply permissions to
    */
    Ipapermlocation *string `json:"ipapermlocation,omitempty"`
  
    /*
Extra target filter
Extra target filter
    */
    Extratargetfilter *[]string `json:"extratargetfilter,omitempty"`
  
    /*
Raw target filter
All target filters, including those implied by type and memberof
    */
    Ipapermtargetfilter *[]string `json:"ipapermtargetfilter,omitempty"`
  
    /*
Target DN
Optional DN to apply the permission to (must be in the subtree, but may not yet exist)
    */
    Ipapermtarget *string `json:"ipapermtarget,omitempty"`
  
    /*
Target DN subtree
Optional DN subtree where an entry can be moved to (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetto *string `json:"ipapermtargetto,omitempty"`
  
    /*
Origin DN subtree
Optional DN subtree from where an entry can be moved (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetfrom *string `json:"ipapermtargetfrom,omitempty"`
  
    /*
Member of group
Target members of a group (sets memberOf targetfilter)
    */
    Memberof *[]string `json:"memberof,omitempty"`
  
    /*
Target group
User group to apply permissions to (sets target)
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Type
Type of IPA object (sets subtree and objectClass targetfilter)
    */
    Type *string `json:"type,omitempty"`
  
    /*

Deprecated; use extratargetfilter
    */
    Filter *[]string `json:"filter,omitempty"`
  
    /*

Deprecated; use ipapermlocation
    */
    Subtree *[]string `json:"subtree,omitempty"`
  
    /*

Deprecated; use ipapermright
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type permissionAddKwParams struct {
  *PermissionAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionAddResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionAddResult `json:"result"`
}

type PermissionAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Permission `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PermissionAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionAddResult%v", string(b))
}

/*
Add members to a permission.
*/
func (c *Client) PermissionAddMember(
  reqArgs *PermissionAddMemberArgs,
  optArgs *PermissionAddMemberOptionalArgs, // can be nil
) (*PermissionAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionAddMemberKwParams{
    PermissionAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionAddMemberArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member privilege
privileges to add
    */
    Privilege *[]string `json:"privilege,omitempty"`
  }

type permissionAddMemberKwParams struct {
  *PermissionAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionAddMemberResult `json:"result"`
}

type PermissionAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *PermissionAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionAddMemberResult%v", string(b))
}

/*
Add a system permission without an ACI (internal command)
*/
func (c *Client) PermissionAddNoaci(
  reqArgs *PermissionAddNoaciArgs,
  optArgs *PermissionAddNoaciOptionalArgs, // can be nil
) (*PermissionAddNoaciResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionAddNoaciKwParams{
    PermissionAddNoaciOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_add_noaci",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Ipapermissiontype, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionAddNoaciResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionAddNoaciArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Permission flags

    */
    Ipapermissiontype []string `json:"ipapermissiontype,omitempty"`
  }

type PermissionAddNoaciOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type permissionAddNoaciKwParams struct {
  *PermissionAddNoaciOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionAddNoaciResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionAddNoaciResult `json:"result"`
}

type PermissionAddNoaciResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PermissionAddNoaciResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionAddNoaciResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionAddNoaciResult%v", string(b))
}

/*
Delete a permission.
*/
func (c *Client) PermissionDel(
  reqArgs *PermissionDelArgs,
  optArgs *PermissionDelOptionalArgs, // can be nil
) (*PermissionDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionDelKwParams{
    PermissionDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionDelArgs struct {
  
    /*
Permission name

    */
    Cn []string `json:"cn,omitempty"`
  }

type PermissionDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Force
force delete of SYSTEM permissions
    */
    Force *bool `json:"force,omitempty"`
  }

type permissionDelKwParams struct {
  *PermissionDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionDelResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionDelResult `json:"result"`
}

type PermissionDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Permission `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PermissionDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionDelResult%v", string(b))
}

/*
Search for permissions.
*/
func (c *Client) PermissionFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *PermissionFindArgs,
  optArgs *PermissionFindOptionalArgs, // can be nil
) (*PermissionFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionFindKwParams{
    PermissionFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionFindArgs struct {
  }

type PermissionFindOptionalArgs struct {
  
    /*
Permission name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Granted rights
Rights to grant (read, search, compare, write, add, delete, all)
    */
    Ipapermright *[]string `json:"ipapermright,omitempty"`
  
    /*
Effective attributes
All attributes to which the permission applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Included attributes
User-specified attributes to which the permission applies
    */
    Ipapermincludedattr *[]string `json:"ipapermincludedattr,omitempty"`
  
    /*
Excluded attributes
User-specified attributes to which the permission explicitly does not apply
    */
    Ipapermexcludedattr *[]string `json:"ipapermexcludedattr,omitempty"`
  
    /*
Default attributes
Attributes to which the permission applies by default
    */
    Ipapermdefaultattr *[]string `json:"ipapermdefaultattr,omitempty"`
  
    /*
Bind rule type
Bind rule type
    */
    Ipapermbindruletype *string `json:"ipapermbindruletype,omitempty"`
  
    /*
Subtree
Subtree to apply permissions to
    */
    Ipapermlocation *string `json:"ipapermlocation,omitempty"`
  
    /*
Extra target filter
Extra target filter
    */
    Extratargetfilter *[]string `json:"extratargetfilter,omitempty"`
  
    /*
Raw target filter
All target filters, including those implied by type and memberof
    */
    Ipapermtargetfilter *[]string `json:"ipapermtargetfilter,omitempty"`
  
    /*
Target DN
Optional DN to apply the permission to (must be in the subtree, but may not yet exist)
    */
    Ipapermtarget *string `json:"ipapermtarget,omitempty"`
  
    /*
Target DN subtree
Optional DN subtree where an entry can be moved to (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetto *string `json:"ipapermtargetto,omitempty"`
  
    /*
Origin DN subtree
Optional DN subtree from where an entry can be moved (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetfrom *string `json:"ipapermtargetfrom,omitempty"`
  
    /*
Member of group
Target members of a group (sets memberOf targetfilter)
    */
    Memberof *[]string `json:"memberof,omitempty"`
  
    /*
Target group
User group to apply permissions to (sets target)
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Type
Type of IPA object (sets subtree and objectClass targetfilter)
    */
    Type *string `json:"type,omitempty"`
  
    /*

Deprecated; use extratargetfilter
    */
    Filter *[]string `json:"filter,omitempty"`
  
    /*

Deprecated; use ipapermlocation
    */
    Subtree *[]string `json:"subtree,omitempty"`
  
    /*

Deprecated; use ipapermright
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type permissionFindKwParams struct {
  *PermissionFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionFindResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionFindResult `json:"result"`
}

type PermissionFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Permission `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *PermissionFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionFindResult%v", string(b))
}

/*
Modify a permission.
*/
func (c *Client) PermissionMod(
  reqArgs *PermissionModArgs,
  optArgs *PermissionModOptionalArgs, // can be nil
) (*PermissionModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionModKwParams{
    PermissionModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionModArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionModOptionalArgs struct {
  
    /*
Granted rights
Rights to grant (read, search, compare, write, add, delete, all)
    */
    Ipapermright *[]string `json:"ipapermright,omitempty"`
  
    /*
Effective attributes
All attributes to which the permission applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Included attributes
User-specified attributes to which the permission applies
    */
    Ipapermincludedattr *[]string `json:"ipapermincludedattr,omitempty"`
  
    /*
Excluded attributes
User-specified attributes to which the permission explicitly does not apply
    */
    Ipapermexcludedattr *[]string `json:"ipapermexcludedattr,omitempty"`
  
    /*
Bind rule type
Bind rule type
    */
    Ipapermbindruletype *string `json:"ipapermbindruletype,omitempty"`
  
    /*
Subtree
Subtree to apply permissions to
    */
    Ipapermlocation *string `json:"ipapermlocation,omitempty"`
  
    /*
Extra target filter
Extra target filter
    */
    Extratargetfilter *[]string `json:"extratargetfilter,omitempty"`
  
    /*
Raw target filter
All target filters, including those implied by type and memberof
    */
    Ipapermtargetfilter *[]string `json:"ipapermtargetfilter,omitempty"`
  
    /*
Target DN
Optional DN to apply the permission to (must be in the subtree, but may not yet exist)
    */
    Ipapermtarget *string `json:"ipapermtarget,omitempty"`
  
    /*
Target DN subtree
Optional DN subtree where an entry can be moved to (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetto *string `json:"ipapermtargetto,omitempty"`
  
    /*
Origin DN subtree
Optional DN subtree from where an entry can be moved (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetfrom *string `json:"ipapermtargetfrom,omitempty"`
  
    /*
Member of group
Target members of a group (sets memberOf targetfilter)
    */
    Memberof *[]string `json:"memberof,omitempty"`
  
    /*
Target group
User group to apply permissions to (sets target)
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Type
Type of IPA object (sets subtree and objectClass targetfilter)
    */
    Type *string `json:"type,omitempty"`
  
    /*

Deprecated; use extratargetfilter
    */
    Filter *[]string `json:"filter,omitempty"`
  
    /*

Deprecated; use ipapermlocation
    */
    Subtree *[]string `json:"subtree,omitempty"`
  
    /*

Deprecated; use ipapermright
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the permission object
    */
    Rename *string `json:"rename,omitempty"`
  }

type permissionModKwParams struct {
  *PermissionModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionModResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionModResult `json:"result"`
}

type PermissionModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Permission `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PermissionModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionModResult%v", string(b))
}

/*
Remove members from a permission.
*/
func (c *Client) PermissionRemoveMember(
  reqArgs *PermissionRemoveMemberArgs,
  optArgs *PermissionRemoveMemberOptionalArgs, // can be nil
) (*PermissionRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionRemoveMemberKwParams{
    PermissionRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionRemoveMemberArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member privilege
privileges to remove
    */
    Privilege *[]string `json:"privilege,omitempty"`
  }

type permissionRemoveMemberKwParams struct {
  *PermissionRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionRemoveMemberResult `json:"result"`
}

type PermissionRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *PermissionRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionRemoveMemberResult%v", string(b))
}

/*
Display information about a permission.
*/
func (c *Client) PermissionShow(
  reqArgs *PermissionShowArgs,
  optArgs *PermissionShowOptionalArgs, // can be nil
) (*PermissionShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionShowKwParams{
    PermissionShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionShowArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type permissionShowKwParams struct {
  *PermissionShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionShowResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionShowResult `json:"result"`
}

type PermissionShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Permission `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PermissionShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionShowResult%v", string(b))
}

/*
Ping a remote server.
*/
func (c *Client) Ping(
  reqArgs *PingArgs,
  optArgs *PingOptionalArgs, // can be nil
) (*PingResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pingKwParams{
    PingOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ping",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pingResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PingArgs struct {
  }

type PingOptionalArgs struct {
  }

type pingKwParams struct {
  *PingOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pingResponse struct {
	Error  *Error      `json:"error"`
	Result *PingResult `json:"result"`
}

type PingResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  }

func (t *PingResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PingResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PingResult%v", string(b))
}

/*
Report PKINIT status on the IPA masters
*/
func (c *Client) PkinitStatus(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *PkinitStatusArgs,
  optArgs *PkinitStatusOptionalArgs, // can be nil
) (*PkinitStatusResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pkinitStatusKwParams{
    PkinitStatusOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pkinit_status",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pkinitStatusResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PkinitStatusArgs struct {
  }

type PkinitStatusOptionalArgs struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer *string `json:"server_server,omitempty"`
  
    /*
PKINIT status
Whether PKINIT is enabled or disabled
    */
    Status *string `json:"status,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type pkinitStatusKwParams struct {
  *PkinitStatusOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pkinitStatusResponse struct {
	Error  *Error      `json:"error"`
	Result *PkinitStatusResult `json:"result"`
}

type PkinitStatusResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []interface{} `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *PkinitStatusResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PkinitStatusResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PkinitStatusResult%v", string(b))
}

/*
Show all loaded plugins.
*/
func (c *Client) Plugins(
  reqArgs *PluginsArgs,
  optArgs *PluginsOptionalArgs, // can be nil
) (*PluginsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pluginsKwParams{
    PluginsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "plugins",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pluginsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PluginsArgs struct {
  }

type PluginsOptionalArgs struct {
  
    /*

Forward to server instead of running locally
    */
    Server *bool `json:"server,omitempty"`
  
    /*

retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  }

type pluginsKwParams struct {
  *PluginsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pluginsResponse struct {
	Error  *Error      `json:"error"`
	Result *PluginsResult `json:"result"`
}

type PluginsResult struct {
  
  
    /*
Dictionary mapping plugin names to bases
    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Number of plugins loaded
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  }

func (t *PluginsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PluginsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PluginsResult%v", string(b))
}

/*
Add a new privilege.
*/
func (c *Client) PrivilegeAdd(
  reqArgs *PrivilegeAddArgs,
  optArgs *PrivilegeAddOptionalArgs, // can be nil
) (*PrivilegeAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeAddKwParams{
    PrivilegeAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeAddArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeAddOptionalArgs struct {
  
    /*
Description
Privilege description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type privilegeAddKwParams struct {
  *PrivilegeAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeAddResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeAddResult `json:"result"`
}

type PrivilegeAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Privilege `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PrivilegeAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeAddResult%v", string(b))
}

/*
Add members to a privilege.
*/
func (c *Client) PrivilegeAddMember(
  reqArgs *PrivilegeAddMemberArgs,
  optArgs *PrivilegeAddMemberOptionalArgs, // can be nil
) (*PrivilegeAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeAddMemberKwParams{
    PrivilegeAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeAddMemberArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member role
roles to add
    */
    Role *[]string `json:"role,omitempty"`
  }

type privilegeAddMemberKwParams struct {
  *PrivilegeAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeAddMemberResult `json:"result"`
}

type PrivilegeAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *PrivilegeAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeAddMemberResult%v", string(b))
}

/*
Add permissions to a privilege.
*/
func (c *Client) PrivilegeAddPermission(
  reqArgs *PrivilegeAddPermissionArgs,
  optArgs *PrivilegeAddPermissionOptionalArgs, // can be nil
) (*PrivilegeAddPermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeAddPermissionKwParams{
    PrivilegeAddPermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_add_permission",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeAddPermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeAddPermissionArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeAddPermissionOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
permission
permissions
    */
    Permission *[]string `json:"permission,omitempty"`
  }

type privilegeAddPermissionKwParams struct {
  *PrivilegeAddPermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeAddPermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeAddPermissionResult `json:"result"`
}

type PrivilegeAddPermissionResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of permissions added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *PrivilegeAddPermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeAddPermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeAddPermissionResult%v", string(b))
}

/*
Delete a privilege.
*/
func (c *Client) PrivilegeDel(
  reqArgs *PrivilegeDelArgs,
  optArgs *PrivilegeDelOptionalArgs, // can be nil
) (*PrivilegeDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeDelKwParams{
    PrivilegeDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeDelArgs struct {
  
    /*
Privilege name

    */
    Cn []string `json:"cn,omitempty"`
  }

type PrivilegeDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type privilegeDelKwParams struct {
  *PrivilegeDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeDelResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeDelResult `json:"result"`
}

type PrivilegeDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Privilege `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PrivilegeDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeDelResult%v", string(b))
}

/*
Search for privileges.
*/
func (c *Client) PrivilegeFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *PrivilegeFindArgs,
  optArgs *PrivilegeFindOptionalArgs, // can be nil
) (*PrivilegeFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeFindKwParams{
    PrivilegeFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeFindArgs struct {
  }

type PrivilegeFindOptionalArgs struct {
  
    /*
Privilege name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Privilege description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type privilegeFindKwParams struct {
  *PrivilegeFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeFindResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeFindResult `json:"result"`
}

type PrivilegeFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Privilege `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *PrivilegeFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeFindResult%v", string(b))
}

/*
Modify a privilege.
*/
func (c *Client) PrivilegeMod(
  reqArgs *PrivilegeModArgs,
  optArgs *PrivilegeModOptionalArgs, // can be nil
) (*PrivilegeModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeModKwParams{
    PrivilegeModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeModArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeModOptionalArgs struct {
  
    /*
Description
Privilege description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the privilege object
    */
    Rename *string `json:"rename,omitempty"`
  }

type privilegeModKwParams struct {
  *PrivilegeModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeModResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeModResult `json:"result"`
}

type PrivilegeModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Privilege `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PrivilegeModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeModResult%v", string(b))
}

/*
Remove members from a privilege
*/
func (c *Client) PrivilegeRemoveMember(
  reqArgs *PrivilegeRemoveMemberArgs,
  optArgs *PrivilegeRemoveMemberOptionalArgs, // can be nil
) (*PrivilegeRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeRemoveMemberKwParams{
    PrivilegeRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeRemoveMemberArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member role
roles to remove
    */
    Role *[]string `json:"role,omitempty"`
  }

type privilegeRemoveMemberKwParams struct {
  *PrivilegeRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeRemoveMemberResult `json:"result"`
}

type PrivilegeRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *PrivilegeRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeRemoveMemberResult%v", string(b))
}

/*
Remove permissions from a privilege.
*/
func (c *Client) PrivilegeRemovePermission(
  reqArgs *PrivilegeRemovePermissionArgs,
  optArgs *PrivilegeRemovePermissionOptionalArgs, // can be nil
) (*PrivilegeRemovePermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeRemovePermissionKwParams{
    PrivilegeRemovePermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_remove_permission",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeRemovePermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeRemovePermissionArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeRemovePermissionOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
permission
permissions
    */
    Permission *[]string `json:"permission,omitempty"`
  }

type privilegeRemovePermissionKwParams struct {
  *PrivilegeRemovePermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeRemovePermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeRemovePermissionResult `json:"result"`
}

type PrivilegeRemovePermissionResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of permissions removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *PrivilegeRemovePermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeRemovePermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeRemovePermissionResult%v", string(b))
}

/*
Display information about a privilege.
*/
func (c *Client) PrivilegeShow(
  reqArgs *PrivilegeShowArgs,
  optArgs *PrivilegeShowOptionalArgs, // can be nil
) (*PrivilegeShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeShowKwParams{
    PrivilegeShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeShowArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type privilegeShowKwParams struct {
  *PrivilegeShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeShowResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeShowResult `json:"result"`
}

type PrivilegeShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Privilege `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PrivilegeShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeShowResult%v", string(b))
}

/*
Add a new group password policy.
*/
func (c *Client) PwpolicyAdd(
  reqArgs *PwpolicyAddArgs,
  optArgs *PwpolicyAddOptionalArgs, // can be nil
) (*PwpolicyAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyAddKwParams{
    PwpolicyAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyAddArgs struct {
  
    /*
Group
Manage password policy for specific group
    */
    Cn string `json:"cn,omitempty"`
  }

type PwpolicyAddOptionalArgs struct {
  
    /*
Max lifetime (days)
Maximum password lifetime (in days)
    */
    Krbmaxpwdlife *int `json:"krbmaxpwdlife,omitempty"`
  
    /*
Min lifetime (hours)
Minimum password lifetime (in hours)
    */
    Krbminpwdlife *int `json:"krbminpwdlife,omitempty"`
  
    /*
History size
Password history size
    */
    Krbpwdhistorylength *int `json:"krbpwdhistorylength,omitempty"`
  
    /*
Character classes
Minimum number of character classes
    */
    Krbpwdmindiffchars *int `json:"krbpwdmindiffchars,omitempty"`
  
    /*
Min length
Minimum length of password
    */
    Krbpwdminlength *int `json:"krbpwdminlength,omitempty"`
  
    /*
Priority
Priority of the policy (higher number means lower priority
    */
    Cospriority *int `json:"cospriority,omitempty"`
  
    /*
Max failures
Consecutive failures before lockout
    */
    Krbpwdmaxfailure *int `json:"krbpwdmaxfailure,omitempty"`
  
    /*
Failure reset interval
Period after which failure count will be reset (seconds)
    */
    Krbpwdfailurecountinterval *int `json:"krbpwdfailurecountinterval,omitempty"`
  
    /*
Lockout duration
Period for which lockout is enforced (seconds)
    */
    Krbpwdlockoutduration *int `json:"krbpwdlockoutduration,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type pwpolicyAddKwParams struct {
  *PwpolicyAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyAddResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyAddResult `json:"result"`
}

type PwpolicyAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Pwpolicy `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PwpolicyAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyAddResult%v", string(b))
}

/*
Delete a group password policy.
*/
func (c *Client) PwpolicyDel(
  reqArgs *PwpolicyDelArgs,
  optArgs *PwpolicyDelOptionalArgs, // can be nil
) (*PwpolicyDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyDelKwParams{
    PwpolicyDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyDelArgs struct {
  
    /*
Group
Manage password policy for specific group
    */
    Cn []string `json:"cn,omitempty"`
  }

type PwpolicyDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type pwpolicyDelKwParams struct {
  *PwpolicyDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyDelResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyDelResult `json:"result"`
}

type PwpolicyDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Pwpolicy `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PwpolicyDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyDelResult%v", string(b))
}

/*
Search for group password policies.
*/
func (c *Client) PwpolicyFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *PwpolicyFindArgs,
  optArgs *PwpolicyFindOptionalArgs, // can be nil
) (*PwpolicyFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyFindKwParams{
    PwpolicyFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyFindArgs struct {
  }

type PwpolicyFindOptionalArgs struct {
  
    /*
Group
Manage password policy for specific group
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Max lifetime (days)
Maximum password lifetime (in days)
    */
    Krbmaxpwdlife *int `json:"krbmaxpwdlife,omitempty"`
  
    /*
Min lifetime (hours)
Minimum password lifetime (in hours)
    */
    Krbminpwdlife *int `json:"krbminpwdlife,omitempty"`
  
    /*
History size
Password history size
    */
    Krbpwdhistorylength *int `json:"krbpwdhistorylength,omitempty"`
  
    /*
Character classes
Minimum number of character classes
    */
    Krbpwdmindiffchars *int `json:"krbpwdmindiffchars,omitempty"`
  
    /*
Min length
Minimum length of password
    */
    Krbpwdminlength *int `json:"krbpwdminlength,omitempty"`
  
    /*
Priority
Priority of the policy (higher number means lower priority
    */
    Cospriority *int `json:"cospriority,omitempty"`
  
    /*
Max failures
Consecutive failures before lockout
    */
    Krbpwdmaxfailure *int `json:"krbpwdmaxfailure,omitempty"`
  
    /*
Failure reset interval
Period after which failure count will be reset (seconds)
    */
    Krbpwdfailurecountinterval *int `json:"krbpwdfailurecountinterval,omitempty"`
  
    /*
Lockout duration
Period for which lockout is enforced (seconds)
    */
    Krbpwdlockoutduration *int `json:"krbpwdlockoutduration,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("group")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type pwpolicyFindKwParams struct {
  *PwpolicyFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyFindResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyFindResult `json:"result"`
}

type PwpolicyFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Pwpolicy `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *PwpolicyFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyFindResult%v", string(b))
}

/*
Modify a group password policy.
*/
func (c *Client) PwpolicyMod(
  cn string, // Manage password policy for specific group
  reqArgs *PwpolicyModArgs,
  optArgs *PwpolicyModOptionalArgs, // can be nil
) (*PwpolicyModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyModKwParams{
    PwpolicyModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_mod",
    Params: []interface{}{
      []interface{}{cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyModArgs struct {
  }

type PwpolicyModOptionalArgs struct {
  
    /*
Max lifetime (days)
Maximum password lifetime (in days)
    */
    Krbmaxpwdlife *int `json:"krbmaxpwdlife,omitempty"`
  
    /*
Min lifetime (hours)
Minimum password lifetime (in hours)
    */
    Krbminpwdlife *int `json:"krbminpwdlife,omitempty"`
  
    /*
History size
Password history size
    */
    Krbpwdhistorylength *int `json:"krbpwdhistorylength,omitempty"`
  
    /*
Character classes
Minimum number of character classes
    */
    Krbpwdmindiffchars *int `json:"krbpwdmindiffchars,omitempty"`
  
    /*
Min length
Minimum length of password
    */
    Krbpwdminlength *int `json:"krbpwdminlength,omitempty"`
  
    /*
Priority
Priority of the policy (higher number means lower priority
    */
    Cospriority *int `json:"cospriority,omitempty"`
  
    /*
Max failures
Consecutive failures before lockout
    */
    Krbpwdmaxfailure *int `json:"krbpwdmaxfailure,omitempty"`
  
    /*
Failure reset interval
Period after which failure count will be reset (seconds)
    */
    Krbpwdfailurecountinterval *int `json:"krbpwdfailurecountinterval,omitempty"`
  
    /*
Lockout duration
Period for which lockout is enforced (seconds)
    */
    Krbpwdlockoutduration *int `json:"krbpwdlockoutduration,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type pwpolicyModKwParams struct {
  *PwpolicyModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyModResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyModResult `json:"result"`
}

type PwpolicyModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Pwpolicy `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PwpolicyModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyModResult%v", string(b))
}

/*
Display information about password policy.
*/
func (c *Client) PwpolicyShow(
  cn string, // Manage password policy for specific group
  reqArgs *PwpolicyShowArgs,
  optArgs *PwpolicyShowOptionalArgs, // can be nil
) (*PwpolicyShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyShowKwParams{
    PwpolicyShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_show",
    Params: []interface{}{
      []interface{}{cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyShowArgs struct {
  }

type PwpolicyShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
User
Display effective policy for a specific user
    */
    User *string `json:"user,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type pwpolicyShowKwParams struct {
  *PwpolicyShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyShowResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyShowResult `json:"result"`
}

type PwpolicyShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Pwpolicy `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *PwpolicyShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyShowResult%v", string(b))
}

/*
Add a new RADIUS proxy server.
*/
func (c *Client) RadiusproxyAdd(
  reqArgs *RadiusproxyAddArgs,
  optArgs *RadiusproxyAddOptionalArgs, // can be nil
) (*RadiusproxyAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyAddKwParams{
    RadiusproxyAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyAddArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn string `json:"cn,omitempty"`
  }

type RadiusproxyAddOptionalArgs struct {
  
    /*
Description
A description of this RADIUS proxy server
    */
    Description *string `json:"description,omitempty"`
  
    /*
Server
The hostname or IP (with or without port)
    */
    Ipatokenradiusserver *string `json:"ipatokenradiusserver,omitempty"`
  
    /*
Secret
The secret used to encrypt data
    */
    Ipatokenradiussecret *string `json:"ipatokenradiussecret,omitempty"`
  
    /*
Timeout
The total timeout across all retries (in seconds)
    */
    Ipatokenradiustimeout *int `json:"ipatokenradiustimeout,omitempty"`
  
    /*
Retries
The number of times to retry authentication
    */
    Ipatokenradiusretries *int `json:"ipatokenradiusretries,omitempty"`
  
    /*
User attribute
The username attribute on the user object
    */
    Ipatokenusermapattribute *string `json:"ipatokenusermapattribute,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type radiusproxyAddKwParams struct {
  *RadiusproxyAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyAddResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyAddResult `json:"result"`
}

type RadiusproxyAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Radiusproxy `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *RadiusproxyAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyAddResult%v", string(b))
}

/*
Delete a RADIUS proxy server.
*/
func (c *Client) RadiusproxyDel(
  reqArgs *RadiusproxyDelArgs,
  optArgs *RadiusproxyDelOptionalArgs, // can be nil
) (*RadiusproxyDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyDelKwParams{
    RadiusproxyDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyDelArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn []string `json:"cn,omitempty"`
  }

type RadiusproxyDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type radiusproxyDelKwParams struct {
  *RadiusproxyDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyDelResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyDelResult `json:"result"`
}

type RadiusproxyDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Radiusproxy `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *RadiusproxyDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyDelResult%v", string(b))
}

/*
Search for RADIUS proxy servers.
*/
func (c *Client) RadiusproxyFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *RadiusproxyFindArgs,
  optArgs *RadiusproxyFindOptionalArgs, // can be nil
) (*RadiusproxyFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyFindKwParams{
    RadiusproxyFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyFindArgs struct {
  }

type RadiusproxyFindOptionalArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
A description of this RADIUS proxy server
    */
    Description *string `json:"description,omitempty"`
  
    /*
Server
The hostname or IP (with or without port)
    */
    Ipatokenradiusserver *string `json:"ipatokenradiusserver,omitempty"`
  
    /*
Secret
The secret used to encrypt data
    */
    Ipatokenradiussecret *string `json:"ipatokenradiussecret,omitempty"`
  
    /*
Timeout
The total timeout across all retries (in seconds)
    */
    Ipatokenradiustimeout *int `json:"ipatokenradiustimeout,omitempty"`
  
    /*
Retries
The number of times to retry authentication
    */
    Ipatokenradiusretries *int `json:"ipatokenradiusretries,omitempty"`
  
    /*
User attribute
The username attribute on the user object
    */
    Ipatokenusermapattribute *string `json:"ipatokenusermapattribute,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type radiusproxyFindKwParams struct {
  *RadiusproxyFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyFindResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyFindResult `json:"result"`
}

type RadiusproxyFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Radiusproxy `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *RadiusproxyFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyFindResult%v", string(b))
}

/*
Modify a RADIUS proxy server.
*/
func (c *Client) RadiusproxyMod(
  reqArgs *RadiusproxyModArgs,
  optArgs *RadiusproxyModOptionalArgs, // can be nil
) (*RadiusproxyModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyModKwParams{
    RadiusproxyModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyModArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn string `json:"cn,omitempty"`
  }

type RadiusproxyModOptionalArgs struct {
  
    /*
Description
A description of this RADIUS proxy server
    */
    Description *string `json:"description,omitempty"`
  
    /*
Server
The hostname or IP (with or without port)
    */
    Ipatokenradiusserver *string `json:"ipatokenradiusserver,omitempty"`
  
    /*
Secret
The secret used to encrypt data
    */
    Ipatokenradiussecret *string `json:"ipatokenradiussecret,omitempty"`
  
    /*
Timeout
The total timeout across all retries (in seconds)
    */
    Ipatokenradiustimeout *int `json:"ipatokenradiustimeout,omitempty"`
  
    /*
Retries
The number of times to retry authentication
    */
    Ipatokenradiusretries *int `json:"ipatokenradiusretries,omitempty"`
  
    /*
User attribute
The username attribute on the user object
    */
    Ipatokenusermapattribute *string `json:"ipatokenusermapattribute,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the RADIUS proxy server object
    */
    Rename *string `json:"rename,omitempty"`
  }

type radiusproxyModKwParams struct {
  *RadiusproxyModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyModResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyModResult `json:"result"`
}

type RadiusproxyModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Radiusproxy `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *RadiusproxyModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyModResult%v", string(b))
}

/*
Display information about a RADIUS proxy server.
*/
func (c *Client) RadiusproxyShow(
  reqArgs *RadiusproxyShowArgs,
  optArgs *RadiusproxyShowOptionalArgs, // can be nil
) (*RadiusproxyShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyShowKwParams{
    RadiusproxyShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyShowArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn string `json:"cn,omitempty"`
  }

type RadiusproxyShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type radiusproxyShowKwParams struct {
  *RadiusproxyShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyShowResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyShowResult `json:"result"`
}

type RadiusproxyShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Radiusproxy `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *RadiusproxyShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyShowResult%v", string(b))
}

/*
Modify realm domains.
*/
func (c *Client) RealmdomainsMod(
  reqArgs *RealmdomainsModArgs,
  optArgs *RealmdomainsModOptionalArgs, // can be nil
) (*RealmdomainsModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := realmdomainsModKwParams{
    RealmdomainsModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "realmdomains_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res realmdomainsModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RealmdomainsModArgs struct {
  }

type RealmdomainsModOptionalArgs struct {
  
    /*
Domain

    */
    Associateddomain *[]string `json:"associateddomain,omitempty"`
  
    /*
Add domain

    */
    AddDomain *string `json:"add_domain,omitempty"`
  
    /*
Delete domain

    */
    DelDomain *string `json:"del_domain,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Force
Force adding domain even if not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type realmdomainsModKwParams struct {
  *RealmdomainsModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type realmdomainsModResponse struct {
	Error  *Error      `json:"error"`
	Result *RealmdomainsModResult `json:"result"`
}

type RealmdomainsModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Realmdomains `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *RealmdomainsModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RealmdomainsModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RealmdomainsModResult%v", string(b))
}

/*
Display the list of realm domains.
*/
func (c *Client) RealmdomainsShow(
  reqArgs *RealmdomainsShowArgs,
  optArgs *RealmdomainsShowOptionalArgs, // can be nil
) (*RealmdomainsShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := realmdomainsShowKwParams{
    RealmdomainsShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "realmdomains_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res realmdomainsShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RealmdomainsShowArgs struct {
  }

type RealmdomainsShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type realmdomainsShowKwParams struct {
  *RealmdomainsShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type realmdomainsShowResponse struct {
	Error  *Error      `json:"error"`
	Result *RealmdomainsShowResult `json:"result"`
}

type RealmdomainsShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Realmdomains `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *RealmdomainsShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RealmdomainsShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RealmdomainsShowResult%v", string(b))
}

/*
Add a new role.
*/
func (c *Client) RoleAdd(
  reqArgs *RoleAddArgs,
  optArgs *RoleAddOptionalArgs, // can be nil
) (*RoleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleAddKwParams{
    RoleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleAddArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleAddOptionalArgs struct {
  
    /*
Description
A description of this role-group
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type roleAddKwParams struct {
  *RoleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleAddResult `json:"result"`
}

type RoleAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Role `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *RoleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleAddResult%v", string(b))
}

/*
Add members to a role.
*/
func (c *Client) RoleAddMember(
  reqArgs *RoleAddMemberArgs,
  optArgs *RoleAddMemberOptionalArgs, // can be nil
) (*RoleAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleAddMemberKwParams{
    RoleAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleAddMemberArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
member service
services to add
    */
    Service *[]string `json:"service,omitempty"`
  }

type roleAddMemberKwParams struct {
  *RoleAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleAddMemberResult `json:"result"`
}

type RoleAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *RoleAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleAddMemberResult%v", string(b))
}

/*
Add privileges to a role.
*/
func (c *Client) RoleAddPrivilege(
  reqArgs *RoleAddPrivilegeArgs,
  optArgs *RoleAddPrivilegeOptionalArgs, // can be nil
) (*RoleAddPrivilegeResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleAddPrivilegeKwParams{
    RoleAddPrivilegeOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_add_privilege",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleAddPrivilegeResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleAddPrivilegeArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleAddPrivilegeOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
privilege
privileges
    */
    Privilege *[]string `json:"privilege,omitempty"`
  }

type roleAddPrivilegeKwParams struct {
  *RoleAddPrivilegeOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleAddPrivilegeResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleAddPrivilegeResult `json:"result"`
}

type RoleAddPrivilegeResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of privileges added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *RoleAddPrivilegeResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleAddPrivilegeResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleAddPrivilegeResult%v", string(b))
}

/*
Delete a role.
*/
func (c *Client) RoleDel(
  reqArgs *RoleDelArgs,
  optArgs *RoleDelOptionalArgs, // can be nil
) (*RoleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleDelKwParams{
    RoleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleDelArgs struct {
  
    /*
Role name

    */
    Cn []string `json:"cn,omitempty"`
  }

type RoleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type roleDelKwParams struct {
  *RoleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleDelResult `json:"result"`
}

type RoleDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Role `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *RoleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleDelResult%v", string(b))
}

/*
Search for roles.
*/
func (c *Client) RoleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *RoleFindArgs,
  optArgs *RoleFindOptionalArgs, // can be nil
) (*RoleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleFindKwParams{
    RoleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleFindArgs struct {
  }

type RoleFindOptionalArgs struct {
  
    /*
Role name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
A description of this role-group
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type roleFindKwParams struct {
  *RoleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleFindResult `json:"result"`
}

type RoleFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Role `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *RoleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleFindResult%v", string(b))
}

/*
Modify a role.
*/
func (c *Client) RoleMod(
  reqArgs *RoleModArgs,
  optArgs *RoleModOptionalArgs, // can be nil
) (*RoleModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleModKwParams{
    RoleModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleModArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleModOptionalArgs struct {
  
    /*
Description
A description of this role-group
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the role object
    */
    Rename *string `json:"rename,omitempty"`
  }

type roleModKwParams struct {
  *RoleModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleModResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleModResult `json:"result"`
}

type RoleModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Role `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *RoleModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleModResult%v", string(b))
}

/*
Remove members from a role.
*/
func (c *Client) RoleRemoveMember(
  reqArgs *RoleRemoveMemberArgs,
  optArgs *RoleRemoveMemberOptionalArgs, // can be nil
) (*RoleRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleRemoveMemberKwParams{
    RoleRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleRemoveMemberArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
member service
services to remove
    */
    Service *[]string `json:"service,omitempty"`
  }

type roleRemoveMemberKwParams struct {
  *RoleRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleRemoveMemberResult `json:"result"`
}

type RoleRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *RoleRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleRemoveMemberResult%v", string(b))
}

/*
Remove privileges from a role.
*/
func (c *Client) RoleRemovePrivilege(
  reqArgs *RoleRemovePrivilegeArgs,
  optArgs *RoleRemovePrivilegeOptionalArgs, // can be nil
) (*RoleRemovePrivilegeResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleRemovePrivilegeKwParams{
    RoleRemovePrivilegeOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_remove_privilege",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleRemovePrivilegeResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleRemovePrivilegeArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleRemovePrivilegeOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
privilege
privileges
    */
    Privilege *[]string `json:"privilege,omitempty"`
  }

type roleRemovePrivilegeKwParams struct {
  *RoleRemovePrivilegeOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleRemovePrivilegeResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleRemovePrivilegeResult `json:"result"`
}

type RoleRemovePrivilegeResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of privileges removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *RoleRemovePrivilegeResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleRemovePrivilegeResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleRemovePrivilegeResult%v", string(b))
}

/*
Display information about a role.
*/
func (c *Client) RoleShow(
  reqArgs *RoleShowArgs,
  optArgs *RoleShowOptionalArgs, // can be nil
) (*RoleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleShowKwParams{
    RoleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleShowArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type roleShowKwParams struct {
  *RoleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleShowResult `json:"result"`
}

type RoleShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Role `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *RoleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleShowResult%v", string(b))
}

/*

*/
func (c *Client) Schema(
  reqArgs *SchemaArgs,
  optArgs *SchemaOptionalArgs, // can be nil
) (*SchemaResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := schemaKwParams{
    SchemaOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "schema",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res schemaResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SchemaArgs struct {
  }

type SchemaOptionalArgs struct {
  
    /*
Fingerprint of schema cached by client

    */
    KnownFingerprints *[]string `json:"known_fingerprints,omitempty"`
  }

type schemaKwParams struct {
  *SchemaOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type schemaResponse struct {
	Error  *Error      `json:"error"`
	Result *SchemaResult `json:"result"`
}

type SchemaResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *SchemaResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SchemaResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SchemaResult%v", string(b))
}

/*
Add a new self-service permission.
*/
func (c *Client) SelfserviceAdd(
  reqArgs *SelfserviceAddArgs,
  optArgs *SelfserviceAddOptionalArgs, // can be nil
) (*SelfserviceAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceAddKwParams{
    SelfserviceAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_add",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceAddArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type SelfserviceAddOptionalArgs struct {
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the permission applies.
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type selfserviceAddKwParams struct {
  *SelfserviceAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceAddResult `json:"result"`
}

type SelfserviceAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Selfservice `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelfserviceAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceAddResult%v", string(b))
}

/*
Delete a self-service permission.
*/
func (c *Client) SelfserviceDel(
  reqArgs *SelfserviceDelArgs,
  optArgs *SelfserviceDelOptionalArgs, // can be nil
) (*SelfserviceDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceDelKwParams{
    SelfserviceDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_del",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceDelArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type SelfserviceDelOptionalArgs struct {
  }

type selfserviceDelKwParams struct {
  *SelfserviceDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceDelResult `json:"result"`
}

type SelfserviceDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelfserviceDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceDelResult%v", string(b))
}

/*
Search for a self-service permission.
*/
func (c *Client) SelfserviceFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SelfserviceFindArgs,
  optArgs *SelfserviceFindOptionalArgs, // can be nil
) (*SelfserviceFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceFindKwParams{
    SelfserviceFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceFindArgs struct {
  }

type SelfserviceFindOptionalArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname *string `json:"aciname,omitempty"`
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the permission applies.
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type selfserviceFindKwParams struct {
  *SelfserviceFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceFindResult `json:"result"`
}

type SelfserviceFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Selfservice `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *SelfserviceFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceFindResult%v", string(b))
}

/*
Modify a self-service permission.
*/
func (c *Client) SelfserviceMod(
  reqArgs *SelfserviceModArgs,
  optArgs *SelfserviceModOptionalArgs, // can be nil
) (*SelfserviceModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceModKwParams{
    SelfserviceModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceModArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type SelfserviceModOptionalArgs struct {
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the permission applies.
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type selfserviceModKwParams struct {
  *SelfserviceModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceModResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceModResult `json:"result"`
}

type SelfserviceModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Selfservice `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelfserviceModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceModResult%v", string(b))
}

/*
Display information about a self-service permission.
*/
func (c *Client) SelfserviceShow(
  reqArgs *SelfserviceShowArgs,
  optArgs *SelfserviceShowOptionalArgs, // can be nil
) (*SelfserviceShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceShowKwParams{
    SelfserviceShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_show",
    Params: []interface{}{
      []interface{}{reqArgs.Aciname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceShowArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type SelfserviceShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type selfserviceShowKwParams struct {
  *SelfserviceShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceShowResult `json:"result"`
}

type SelfserviceShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Selfservice `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelfserviceShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceShowResult%v", string(b))
}

/*
Create a new SELinux User Map.
*/
func (c *Client) SelinuxusermapAdd(
  reqArgs *SelinuxusermapAddArgs,
  optArgs *SelinuxusermapAddOptionalArgs, // can be nil
) (*SelinuxusermapAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapAddKwParams{
    SelinuxusermapAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Ipaselinuxuser, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapAddArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
SELinux User

    */
    Ipaselinuxuser string `json:"ipaselinuxuser,omitempty"`
  }

type SelinuxusermapAddOptionalArgs struct {
  
    /*
HBAC Rule
HBAC Rule that defines the users, groups and hostgroups
    */
    Seealso *string `json:"seealso,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type selinuxusermapAddKwParams struct {
  *SelinuxusermapAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapAddResult `json:"result"`
}

type SelinuxusermapAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Selinuxusermap `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelinuxusermapAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapAddResult%v", string(b))
}

/*
Add target hosts and hostgroups to an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapAddHost(
  reqArgs *SelinuxusermapAddHostArgs,
  optArgs *SelinuxusermapAddHostOptionalArgs, // can be nil
) (*SelinuxusermapAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapAddHostKwParams{
    SelinuxusermapAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_add_host",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapAddHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type selinuxusermapAddHostKwParams struct {
  *SelinuxusermapAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapAddHostResult `json:"result"`
}

type SelinuxusermapAddHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SelinuxusermapAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapAddHostResult%v", string(b))
}

/*
Add users and groups to an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapAddUser(
  reqArgs *SelinuxusermapAddUserArgs,
  optArgs *SelinuxusermapAddUserOptionalArgs, // can be nil
) (*SelinuxusermapAddUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapAddUserKwParams{
    SelinuxusermapAddUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_add_user",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapAddUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapAddUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapAddUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type selinuxusermapAddUserKwParams struct {
  *SelinuxusermapAddUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapAddUserResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapAddUserResult `json:"result"`
}

type SelinuxusermapAddUserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SelinuxusermapAddUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapAddUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapAddUserResult%v", string(b))
}

/*
Delete a SELinux User Map.
*/
func (c *Client) SelinuxusermapDel(
  reqArgs *SelinuxusermapDelArgs,
  optArgs *SelinuxusermapDelOptionalArgs, // can be nil
) (*SelinuxusermapDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapDelKwParams{
    SelinuxusermapDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapDelArgs struct {
  
    /*
Rule name

    */
    Cn []string `json:"cn,omitempty"`
  }

type SelinuxusermapDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type selinuxusermapDelKwParams struct {
  *SelinuxusermapDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapDelResult `json:"result"`
}

type SelinuxusermapDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Selinuxusermap `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelinuxusermapDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapDelResult%v", string(b))
}

/*
Disable an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapDisable(
  reqArgs *SelinuxusermapDisableArgs,
  optArgs *SelinuxusermapDisableOptionalArgs, // can be nil
) (*SelinuxusermapDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapDisableKwParams{
    SelinuxusermapDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapDisableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapDisableOptionalArgs struct {
  }

type selinuxusermapDisableKwParams struct {
  *SelinuxusermapDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapDisableResult `json:"result"`
}

type SelinuxusermapDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelinuxusermapDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapDisableResult%v", string(b))
}

/*
Enable an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapEnable(
  reqArgs *SelinuxusermapEnableArgs,
  optArgs *SelinuxusermapEnableOptionalArgs, // can be nil
) (*SelinuxusermapEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapEnableKwParams{
    SelinuxusermapEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_enable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapEnableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapEnableOptionalArgs struct {
  }

type selinuxusermapEnableKwParams struct {
  *SelinuxusermapEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapEnableResult `json:"result"`
}

type SelinuxusermapEnableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelinuxusermapEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapEnableResult%v", string(b))
}

/*
Search for SELinux User Maps.
*/
func (c *Client) SelinuxusermapFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SelinuxusermapFindArgs,
  optArgs *SelinuxusermapFindOptionalArgs, // can be nil
) (*SelinuxusermapFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapFindKwParams{
    SelinuxusermapFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapFindArgs struct {
  }

type SelinuxusermapFindOptionalArgs struct {
  
    /*
Rule name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
SELinux User

    */
    Ipaselinuxuser *string `json:"ipaselinuxuser,omitempty"`
  
    /*
HBAC Rule
HBAC Rule that defines the users, groups and hostgroups
    */
    Seealso *string `json:"seealso,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type selinuxusermapFindKwParams struct {
  *SelinuxusermapFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapFindResult `json:"result"`
}

type SelinuxusermapFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Selinuxusermap `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *SelinuxusermapFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapFindResult%v", string(b))
}

/*
Modify a SELinux User Map.
*/
func (c *Client) SelinuxusermapMod(
  reqArgs *SelinuxusermapModArgs,
  optArgs *SelinuxusermapModOptionalArgs, // can be nil
) (*SelinuxusermapModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapModKwParams{
    SelinuxusermapModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapModArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapModOptionalArgs struct {
  
    /*
SELinux User

    */
    Ipaselinuxuser *string `json:"ipaselinuxuser,omitempty"`
  
    /*
HBAC Rule
HBAC Rule that defines the users, groups and hostgroups
    */
    Seealso *string `json:"seealso,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type selinuxusermapModKwParams struct {
  *SelinuxusermapModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapModResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapModResult `json:"result"`
}

type SelinuxusermapModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Selinuxusermap `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelinuxusermapModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapModResult%v", string(b))
}

/*
Remove target hosts and hostgroups from an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapRemoveHost(
  reqArgs *SelinuxusermapRemoveHostArgs,
  optArgs *SelinuxusermapRemoveHostOptionalArgs, // can be nil
) (*SelinuxusermapRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapRemoveHostKwParams{
    SelinuxusermapRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_remove_host",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapRemoveHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type selinuxusermapRemoveHostKwParams struct {
  *SelinuxusermapRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapRemoveHostResult `json:"result"`
}

type SelinuxusermapRemoveHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SelinuxusermapRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapRemoveHostResult%v", string(b))
}

/*
Remove users and groups from an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapRemoveUser(
  reqArgs *SelinuxusermapRemoveUserArgs,
  optArgs *SelinuxusermapRemoveUserOptionalArgs, // can be nil
) (*SelinuxusermapRemoveUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapRemoveUserKwParams{
    SelinuxusermapRemoveUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_remove_user",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapRemoveUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapRemoveUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapRemoveUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type selinuxusermapRemoveUserKwParams struct {
  *SelinuxusermapRemoveUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapRemoveUserResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapRemoveUserResult `json:"result"`
}

type SelinuxusermapRemoveUserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SelinuxusermapRemoveUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapRemoveUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapRemoveUserResult%v", string(b))
}

/*
Display the properties of a SELinux User Map rule.
*/
func (c *Client) SelinuxusermapShow(
  reqArgs *SelinuxusermapShowArgs,
  optArgs *SelinuxusermapShowOptionalArgs, // can be nil
) (*SelinuxusermapShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapShowKwParams{
    SelinuxusermapShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapShowArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type selinuxusermapShowKwParams struct {
  *SelinuxusermapShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapShowResult `json:"result"`
}

type SelinuxusermapShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Selinuxusermap `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SelinuxusermapShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapShowResult%v", string(b))
}

/*
Check connection to remote IPA server.
*/
func (c *Client) ServerConncheck(
  reqArgs *ServerConncheckArgs,
  optArgs *ServerConncheckOptionalArgs, // can be nil
) (*ServerConncheckResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverConncheckKwParams{
    ServerConncheckOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_conncheck",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.RemoteCn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverConncheckResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerConncheckArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Remote server name
Remote IPA server hostname
    */
    RemoteCn string `json:"remote_cn,omitempty"`
  }

type ServerConncheckOptionalArgs struct {
  }

type serverConncheckKwParams struct {
  *ServerConncheckOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverConncheckResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerConncheckResult `json:"result"`
}

type ServerConncheckResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServerConncheckResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerConncheckResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerConncheckResult%v", string(b))
}

/*
Delete IPA server.
*/
func (c *Client) ServerDel(
  reqArgs *ServerDelArgs,
  optArgs *ServerDelOptionalArgs, // can be nil
) (*ServerDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverDelKwParams{
    ServerDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerDelArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn []string `json:"cn,omitempty"`
  }

type ServerDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Ignore topology errors
Ignore topology connectivity problems after removal
    */
    IgnoreTopologyDisconnect *bool `json:"ignore_topology_disconnect,omitempty"`
  
    /*
Ignore check for last remaining CA or DNS server
Skip a check whether the last CA master or DNS server is removed
    */
    IgnoreLastOfRole *bool `json:"ignore_last_of_role,omitempty"`
  
    /*
Force server removal
Force server removal even if it does not exist
    */
    Force *bool `json:"force,omitempty"`
  }

type serverDelKwParams struct {
  *ServerDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverDelResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerDelResult `json:"result"`
}

type ServerDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Server `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServerDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerDelResult%v", string(b))
}

/*
Search for IPA servers.
*/
func (c *Client) ServerFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServerFindArgs,
  optArgs *ServerFindOptionalArgs, // can be nil
) (*ServerFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverFindKwParams{
    ServerFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerFindArgs struct {
  }

type ServerFindOptionalArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Min domain level
Minimum domain level
    */
    Ipamindomainlevel *int `json:"ipamindomainlevel,omitempty"`
  
    /*
Max domain level
Maximum domain level
    */
    Ipamaxdomainlevel *int `json:"ipamaxdomainlevel,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
suffix
Search for servers with these managed suffixes.
    */
    Topologysuffix *[]string `json:"topologysuffix,omitempty"`
  
    /*
suffix
Search for servers without these managed suffixes.
    */
    NoTopologysuffix *[]string `json:"no_topologysuffix,omitempty"`
  
    /*
location
Search for servers with these ipa locations.
    */
    InLocation *[]string `json:"in_location,omitempty"`
  
    /*
location
Search for servers without these ipa locations.
    */
    NotInLocation *[]string `json:"not_in_location,omitempty"`
  
    /*
role
Search for servers with these enabled roles.
    */
    Servrole *[]string `json:"servrole,omitempty"`
  }

type serverFindKwParams struct {
  *ServerFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerFindResult `json:"result"`
}

type ServerFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Server `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *ServerFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerFindResult%v", string(b))
}

/*
Modify information about an IPA server.
*/
func (c *Client) ServerMod(
  reqArgs *ServerModArgs,
  optArgs *ServerModOptionalArgs, // can be nil
) (*ServerModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverModKwParams{
    ServerModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerModArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn string `json:"cn,omitempty"`
  }

type ServerModOptionalArgs struct {
  
    /*
Location
Server location
    */
    IpalocationLocation *string `json:"ipalocation_location,omitempty"`
  
    /*
Service weight
Weight for server services
    */
    Ipaserviceweight *int `json:"ipaserviceweight,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serverModKwParams struct {
  *ServerModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverModResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerModResult `json:"result"`
}

type ServerModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Server `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServerModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerModResult%v", string(b))
}

/*
Find a server role on a server(s)
*/
func (c *Client) ServerRoleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServerRoleFindArgs,
  optArgs *ServerRoleFindOptionalArgs, // can be nil
) (*ServerRoleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverRoleFindKwParams{
    ServerRoleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_role_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverRoleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerRoleFindArgs struct {
  }

type ServerRoleFindOptionalArgs struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer *string `json:"server_server,omitempty"`
  
    /*
Role name
IPA server role name
    */
    RoleServrole *string `json:"role_servrole,omitempty"`
  
    /*
Role status
Status of the role
    */
    Status *string `json:"status,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Include IPA master entries
    */
    IncludeMaster *bool `json:"include_master,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type serverRoleFindKwParams struct {
  *ServerRoleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverRoleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerRoleFindResult `json:"result"`
}

type ServerRoleFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []ServerRole `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *ServerRoleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerRoleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerRoleFindResult%v", string(b))
}

/*
Show role status on a server
*/
func (c *Client) ServerRoleShow(
  reqArgs *ServerRoleShowArgs,
  optArgs *ServerRoleShowOptionalArgs, // can be nil
) (*ServerRoleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverRoleShowKwParams{
    ServerRoleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_role_show",
    Params: []interface{}{
      []interface{}{reqArgs.ServerServer, reqArgs.RoleServrole, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverRoleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerRoleShowArgs struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer string `json:"server_server,omitempty"`
  
    /*
Role name
IPA server role name
    */
    RoleServrole string `json:"role_servrole,omitempty"`
  }

type ServerRoleShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type serverRoleShowKwParams struct {
  *ServerRoleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverRoleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerRoleShowResult `json:"result"`
}

type ServerRoleShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result ServerRole `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *ServerRoleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerRoleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerRoleShowResult%v", string(b))
}

/*
Show IPA server.
*/
func (c *Client) ServerShow(
  reqArgs *ServerShowArgs,
  optArgs *ServerShowOptionalArgs, // can be nil
) (*ServerShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverShowKwParams{
    ServerShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerShowArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn string `json:"cn,omitempty"`
  }

type ServerShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serverShowKwParams struct {
  *ServerShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerShowResult `json:"result"`
}

type ServerShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Server `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServerShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerShowResult%v", string(b))
}

/*
Set enabled/hidden state of a server.
*/
func (c *Client) ServerState(
  reqArgs *ServerStateArgs,
  optArgs *ServerStateOptionalArgs, // can be nil
) (*ServerStateResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverStateKwParams{
    ServerStateOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_state",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.State, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverStateResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerStateArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn string `json:"cn,omitempty"`
  
    /*
State
Server state
    */
    State string `json:"state,omitempty"`
  }

type ServerStateOptionalArgs struct {
  }

type serverStateKwParams struct {
  *ServerStateOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverStateResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerStateResult `json:"result"`
}

type ServerStateResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServerStateResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerStateResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerStateResult%v", string(b))
}

/*
Add a new IPA service.
*/
func (c *Client) ServiceAdd(
  reqArgs *ServiceAddArgs,
  optArgs *ServiceAddOptionalArgs, // can be nil
) (*ServiceAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAddKwParams{
    ServiceAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_add",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAddArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceAddOptionalArgs struct {
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
PAC type
Override default list of supported PAC types. Use 'NONE' to disable PAC support for this service, e.g. this might be necessary for NFS services.
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Force
force principal name even if not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceAddKwParams struct {
  *ServiceAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAddResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAddResult `json:"result"`
}

type ServiceAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Service `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServiceAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAddResult%v", string(b))
}

/*
Add new certificates to a service
*/
func (c *Client) ServiceAddCert(
  reqArgs *ServiceAddCertArgs,
  optArgs *ServiceAddCertOptionalArgs, // can be nil
) (*ServiceAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAddCertKwParams{
    ServiceAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_add_cert",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAddCertArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type ServiceAddCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceAddCertKwParams struct {
  *ServiceAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAddCertResult `json:"result"`
}

type ServiceAddCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServiceAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAddCertResult%v", string(b))
}

/*
Add hosts that can manage this service.
*/
func (c *Client) ServiceAddHost(
  reqArgs *ServiceAddHostArgs,
  optArgs *ServiceAddHostOptionalArgs, // can be nil
) (*ServiceAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAddHostKwParams{
    ServiceAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_add_host",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAddHostArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  }

type serviceAddHostKwParams struct {
  *ServiceAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAddHostResult `json:"result"`
}

type ServiceAddHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServiceAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAddHostResult%v", string(b))
}

/*
Add new principal alias to a service
*/
func (c *Client) ServiceAddPrincipal(
  reqArgs *ServiceAddPrincipalArgs,
  optArgs *ServiceAddPrincipalOptionalArgs, // can be nil
) (*ServiceAddPrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAddPrincipalKwParams{
    ServiceAddPrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_add_principal",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, reqArgs.Krbprincipalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAddPrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAddPrincipalArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type ServiceAddPrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceAddPrincipalKwParams struct {
  *ServiceAddPrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAddPrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAddPrincipalResult `json:"result"`
}

type ServiceAddPrincipalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServiceAddPrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAddPrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAddPrincipalResult%v", string(b))
}

/*
Allow users, groups, hosts or host groups to create a keytab of this service.
*/
func (c *Client) ServiceAllowCreateKeytab(
  reqArgs *ServiceAllowCreateKeytabArgs,
  optArgs *ServiceAllowCreateKeytabOptionalArgs, // can be nil
) (*ServiceAllowCreateKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAllowCreateKeytabKwParams{
    ServiceAllowCreateKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_allow_create_keytab",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAllowCreateKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAllowCreateKeytabArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceAllowCreateKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type serviceAllowCreateKeytabKwParams struct {
  *ServiceAllowCreateKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAllowCreateKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAllowCreateKeytabResult `json:"result"`
}

type ServiceAllowCreateKeytabResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServiceAllowCreateKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAllowCreateKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAllowCreateKeytabResult%v", string(b))
}

/*
Allow users, groups, hosts or host groups to retrieve a keytab of this service.
*/
func (c *Client) ServiceAllowRetrieveKeytab(
  reqArgs *ServiceAllowRetrieveKeytabArgs,
  optArgs *ServiceAllowRetrieveKeytabOptionalArgs, // can be nil
) (*ServiceAllowRetrieveKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAllowRetrieveKeytabKwParams{
    ServiceAllowRetrieveKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_allow_retrieve_keytab",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAllowRetrieveKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAllowRetrieveKeytabArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceAllowRetrieveKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type serviceAllowRetrieveKeytabKwParams struct {
  *ServiceAllowRetrieveKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAllowRetrieveKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAllowRetrieveKeytabResult `json:"result"`
}

type ServiceAllowRetrieveKeytabResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServiceAllowRetrieveKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAllowRetrieveKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAllowRetrieveKeytabResult%v", string(b))
}

/*
Delete an IPA service.
*/
func (c *Client) ServiceDel(
  reqArgs *ServiceDelArgs,
  optArgs *ServiceDelOptionalArgs, // can be nil
) (*ServiceDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceDelKwParams{
    ServiceDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_del",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceDelArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname []string `json:"krbcanonicalname,omitempty"`
  }

type ServiceDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type serviceDelKwParams struct {
  *ServiceDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceDelResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceDelResult `json:"result"`
}

type ServiceDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Service `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServiceDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceDelResult%v", string(b))
}

/*
Disable the Kerberos key and SSL certificate of a service.
*/
func (c *Client) ServiceDisable(
  reqArgs *ServiceDisableArgs,
  optArgs *ServiceDisableOptionalArgs, // can be nil
) (*ServiceDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceDisableKwParams{
    ServiceDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceDisableArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceDisableOptionalArgs struct {
  }

type serviceDisableKwParams struct {
  *ServiceDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceDisableResult `json:"result"`
}

type ServiceDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServiceDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceDisableResult%v", string(b))
}

/*
Disallow users, groups, hosts or host groups to create a keytab of this service.
*/
func (c *Client) ServiceDisallowCreateKeytab(
  reqArgs *ServiceDisallowCreateKeytabArgs,
  optArgs *ServiceDisallowCreateKeytabOptionalArgs, // can be nil
) (*ServiceDisallowCreateKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceDisallowCreateKeytabKwParams{
    ServiceDisallowCreateKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_disallow_create_keytab",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceDisallowCreateKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceDisallowCreateKeytabArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceDisallowCreateKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type serviceDisallowCreateKeytabKwParams struct {
  *ServiceDisallowCreateKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceDisallowCreateKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceDisallowCreateKeytabResult `json:"result"`
}

type ServiceDisallowCreateKeytabResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServiceDisallowCreateKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceDisallowCreateKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceDisallowCreateKeytabResult%v", string(b))
}

/*
Disallow users, groups, hosts or host groups to retrieve a keytab of this service.
*/
func (c *Client) ServiceDisallowRetrieveKeytab(
  reqArgs *ServiceDisallowRetrieveKeytabArgs,
  optArgs *ServiceDisallowRetrieveKeytabOptionalArgs, // can be nil
) (*ServiceDisallowRetrieveKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceDisallowRetrieveKeytabKwParams{
    ServiceDisallowRetrieveKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_disallow_retrieve_keytab",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceDisallowRetrieveKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceDisallowRetrieveKeytabArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceDisallowRetrieveKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type serviceDisallowRetrieveKeytabKwParams struct {
  *ServiceDisallowRetrieveKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceDisallowRetrieveKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceDisallowRetrieveKeytabResult `json:"result"`
}

type ServiceDisallowRetrieveKeytabResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServiceDisallowRetrieveKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceDisallowRetrieveKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceDisallowRetrieveKeytabResult%v", string(b))
}

/*
Search for IPA services.
*/
func (c *Client) ServiceFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServiceFindArgs,
  optArgs *ServiceFindOptionalArgs, // can be nil
) (*ServiceFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceFindKwParams{
    ServiceFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceFindArgs struct {
  }

type ServiceFindOptionalArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname *string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
PAC type
Override default list of supported PAC types. Use 'NONE' to disable PAC support for this service, e.g. this might be necessary for NFS services.
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("canonical-principal")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
host
Search for services with these managed by hosts.
    */
    ManByHost *[]string `json:"man_by_host,omitempty"`
  
    /*
host
Search for services without these managed by hosts.
    */
    NotManByHost *[]string `json:"not_man_by_host,omitempty"`
  }

type serviceFindKwParams struct {
  *ServiceFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceFindResult `json:"result"`
}

type ServiceFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Service `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *ServiceFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceFindResult%v", string(b))
}

/*
Modify an existing IPA service.
*/
func (c *Client) ServiceMod(
  reqArgs *ServiceModArgs,
  optArgs *ServiceModOptionalArgs, // can be nil
) (*ServiceModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceModKwParams{
    ServiceModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceModArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceModOptionalArgs struct {
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
PAC type
Override default list of supported PAC types. Use 'NONE' to disable PAC support for this service, e.g. this might be necessary for NFS services.
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceModKwParams struct {
  *ServiceModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceModResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceModResult `json:"result"`
}

type ServiceModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Service `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServiceModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceModResult%v", string(b))
}

/*
Remove certificates from a service
*/
func (c *Client) ServiceRemoveCert(
  reqArgs *ServiceRemoveCertArgs,
  optArgs *ServiceRemoveCertOptionalArgs, // can be nil
) (*ServiceRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceRemoveCertKwParams{
    ServiceRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_remove_cert",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceRemoveCertArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type ServiceRemoveCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceRemoveCertKwParams struct {
  *ServiceRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceRemoveCertResult `json:"result"`
}

type ServiceRemoveCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServiceRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceRemoveCertResult%v", string(b))
}

/*
Remove hosts that can manage this service.
*/
func (c *Client) ServiceRemoveHost(
  reqArgs *ServiceRemoveHostArgs,
  optArgs *ServiceRemoveHostOptionalArgs, // can be nil
) (*ServiceRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceRemoveHostKwParams{
    ServiceRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_remove_host",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceRemoveHostArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  }

type serviceRemoveHostKwParams struct {
  *ServiceRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceRemoveHostResult `json:"result"`
}

type ServiceRemoveHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServiceRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceRemoveHostResult%v", string(b))
}

/*
Remove principal alias from a service
*/
func (c *Client) ServiceRemovePrincipal(
  reqArgs *ServiceRemovePrincipalArgs,
  optArgs *ServiceRemovePrincipalOptionalArgs, // can be nil
) (*ServiceRemovePrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceRemovePrincipalKwParams{
    ServiceRemovePrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_remove_principal",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, reqArgs.Krbprincipalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceRemovePrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceRemovePrincipalArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type ServiceRemovePrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceRemovePrincipalKwParams struct {
  *ServiceRemovePrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceRemovePrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceRemovePrincipalResult `json:"result"`
}

type ServiceRemovePrincipalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServiceRemovePrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceRemovePrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceRemovePrincipalResult%v", string(b))
}

/*
Display information about an IPA service.
*/
func (c *Client) ServiceShow(
  reqArgs *ServiceShowArgs,
  optArgs *ServiceShowOptionalArgs, // can be nil
) (*ServiceShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceShowKwParams{
    ServiceShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_show",
    Params: []interface{}{
      []interface{}{reqArgs.Krbcanonicalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceShowArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

file to store certificate in
    */
    Out *string `json:"out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceShowKwParams struct {
  *ServiceShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceShowResult `json:"result"`
}

type ServiceShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Service `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServiceShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceShowResult%v", string(b))
}

/*
Create a new service delegation rule.
*/
func (c *Client) ServicedelegationruleAdd(
  reqArgs *ServicedelegationruleAddArgs,
  optArgs *ServicedelegationruleAddOptionalArgs, // can be nil
) (*ServicedelegationruleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleAddKwParams{
    ServicedelegationruleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleAddArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type servicedelegationruleAddKwParams struct {
  *ServicedelegationruleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleAddResult `json:"result"`
}

type ServicedelegationruleAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Servicedelegationrule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServicedelegationruleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleAddResult%v", string(b))
}

/*
Add member to a named service delegation rule.
*/
func (c *Client) ServicedelegationruleAddMember(
  reqArgs *ServicedelegationruleAddMemberArgs,
  optArgs *ServicedelegationruleAddMemberOptionalArgs, // can be nil
) (*ServicedelegationruleAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleAddMemberKwParams{
    ServicedelegationruleAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleAddMemberArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member principal
principal to add
    */
    Principal *[]string `json:"principal,omitempty"`
  }

type servicedelegationruleAddMemberKwParams struct {
  *ServicedelegationruleAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleAddMemberResult `json:"result"`
}

type ServicedelegationruleAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServicedelegationruleAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleAddMemberResult%v", string(b))
}

/*
Add target to a named service delegation rule.
*/
func (c *Client) ServicedelegationruleAddTarget(
  reqArgs *ServicedelegationruleAddTargetArgs,
  optArgs *ServicedelegationruleAddTargetOptionalArgs, // can be nil
) (*ServicedelegationruleAddTargetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleAddTargetKwParams{
    ServicedelegationruleAddTargetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_add_target",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleAddTargetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleAddTargetArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleAddTargetOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member service delegation target
service delegation targets to add
    */
    Servicedelegationtarget *[]string `json:"servicedelegationtarget,omitempty"`
  }

type servicedelegationruleAddTargetKwParams struct {
  *ServicedelegationruleAddTargetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleAddTargetResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleAddTargetResult `json:"result"`
}

type ServicedelegationruleAddTargetResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServicedelegationruleAddTargetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleAddTargetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleAddTargetResult%v", string(b))
}

/*
Delete service delegation.
*/
func (c *Client) ServicedelegationruleDel(
  reqArgs *ServicedelegationruleDelArgs,
  optArgs *ServicedelegationruleDelOptionalArgs, // can be nil
) (*ServicedelegationruleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleDelKwParams{
    ServicedelegationruleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleDelArgs struct {
  
    /*
Delegation name

    */
    Cn []string `json:"cn,omitempty"`
  }

type ServicedelegationruleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type servicedelegationruleDelKwParams struct {
  *ServicedelegationruleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleDelResult `json:"result"`
}

type ServicedelegationruleDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Servicedelegationrule `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServicedelegationruleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleDelResult%v", string(b))
}

/*
Search for service delegations rule.
*/
func (c *Client) ServicedelegationruleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServicedelegationruleFindArgs,
  optArgs *ServicedelegationruleFindOptionalArgs, // can be nil
) (*ServicedelegationruleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleFindKwParams{
    ServicedelegationruleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleFindArgs struct {
  }

type ServicedelegationruleFindOptionalArgs struct {
  
    /*
Delegation name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("delegation-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type servicedelegationruleFindKwParams struct {
  *ServicedelegationruleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleFindResult `json:"result"`
}

type ServicedelegationruleFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Servicedelegationrule `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *ServicedelegationruleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleFindResult%v", string(b))
}

/*
Remove member from a named service delegation rule.
*/
func (c *Client) ServicedelegationruleRemoveMember(
  reqArgs *ServicedelegationruleRemoveMemberArgs,
  optArgs *ServicedelegationruleRemoveMemberOptionalArgs, // can be nil
) (*ServicedelegationruleRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleRemoveMemberKwParams{
    ServicedelegationruleRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleRemoveMemberArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member principal
principal to remove
    */
    Principal *[]string `json:"principal,omitempty"`
  }

type servicedelegationruleRemoveMemberKwParams struct {
  *ServicedelegationruleRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleRemoveMemberResult `json:"result"`
}

type ServicedelegationruleRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServicedelegationruleRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleRemoveMemberResult%v", string(b))
}

/*
Remove target from a named service delegation rule.
*/
func (c *Client) ServicedelegationruleRemoveTarget(
  reqArgs *ServicedelegationruleRemoveTargetArgs,
  optArgs *ServicedelegationruleRemoveTargetOptionalArgs, // can be nil
) (*ServicedelegationruleRemoveTargetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleRemoveTargetKwParams{
    ServicedelegationruleRemoveTargetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_remove_target",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleRemoveTargetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleRemoveTargetArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleRemoveTargetOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member service delegation target
service delegation targets to remove
    */
    Servicedelegationtarget *[]string `json:"servicedelegationtarget,omitempty"`
  }

type servicedelegationruleRemoveTargetKwParams struct {
  *ServicedelegationruleRemoveTargetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleRemoveTargetResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleRemoveTargetResult `json:"result"`
}

type ServicedelegationruleRemoveTargetResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServicedelegationruleRemoveTargetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleRemoveTargetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleRemoveTargetResult%v", string(b))
}

/*
Display information about a named service delegation rule.
*/
func (c *Client) ServicedelegationruleShow(
  reqArgs *ServicedelegationruleShowArgs,
  optArgs *ServicedelegationruleShowOptionalArgs, // can be nil
) (*ServicedelegationruleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleShowKwParams{
    ServicedelegationruleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleShowArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type servicedelegationruleShowKwParams struct {
  *ServicedelegationruleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleShowResult `json:"result"`
}

type ServicedelegationruleShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Servicedelegationrule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServicedelegationruleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleShowResult%v", string(b))
}

/*
Create a new service delegation target.
*/
func (c *Client) ServicedelegationtargetAdd(
  reqArgs *ServicedelegationtargetAddArgs,
  optArgs *ServicedelegationtargetAddOptionalArgs, // can be nil
) (*ServicedelegationtargetAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetAddKwParams{
    ServicedelegationtargetAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetAddArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationtargetAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type servicedelegationtargetAddKwParams struct {
  *ServicedelegationtargetAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetAddResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetAddResult `json:"result"`
}

type ServicedelegationtargetAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Servicedelegationtarget `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServicedelegationtargetAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetAddResult%v", string(b))
}

/*
Add member to a named service delegation target.
*/
func (c *Client) ServicedelegationtargetAddMember(
  reqArgs *ServicedelegationtargetAddMemberArgs,
  optArgs *ServicedelegationtargetAddMemberOptionalArgs, // can be nil
) (*ServicedelegationtargetAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetAddMemberKwParams{
    ServicedelegationtargetAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetAddMemberArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationtargetAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
member principal
principal to add
    */
    Principal *[]string `json:"principal,omitempty"`
  }

type servicedelegationtargetAddMemberKwParams struct {
  *ServicedelegationtargetAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetAddMemberResult `json:"result"`
}

type ServicedelegationtargetAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServicedelegationtargetAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetAddMemberResult%v", string(b))
}

/*
Delete service delegation target.
*/
func (c *Client) ServicedelegationtargetDel(
  reqArgs *ServicedelegationtargetDelArgs,
  optArgs *ServicedelegationtargetDelOptionalArgs, // can be nil
) (*ServicedelegationtargetDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetDelKwParams{
    ServicedelegationtargetDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetDelArgs struct {
  
    /*
Delegation name

    */
    Cn []string `json:"cn,omitempty"`
  }

type ServicedelegationtargetDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type servicedelegationtargetDelKwParams struct {
  *ServicedelegationtargetDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetDelResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetDelResult `json:"result"`
}

type ServicedelegationtargetDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Servicedelegationtarget `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServicedelegationtargetDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetDelResult%v", string(b))
}

/*
Search for service delegation target.
*/
func (c *Client) ServicedelegationtargetFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServicedelegationtargetFindArgs,
  optArgs *ServicedelegationtargetFindOptionalArgs, // can be nil
) (*ServicedelegationtargetFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetFindKwParams{
    ServicedelegationtargetFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetFindArgs struct {
  }

type ServicedelegationtargetFindOptionalArgs struct {
  
    /*
Delegation name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("delegation-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type servicedelegationtargetFindKwParams struct {
  *ServicedelegationtargetFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetFindResult `json:"result"`
}

type ServicedelegationtargetFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Servicedelegationtarget `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *ServicedelegationtargetFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetFindResult%v", string(b))
}

/*
Remove member from a named service delegation target.
*/
func (c *Client) ServicedelegationtargetRemoveMember(
  reqArgs *ServicedelegationtargetRemoveMemberArgs,
  optArgs *ServicedelegationtargetRemoveMemberOptionalArgs, // can be nil
) (*ServicedelegationtargetRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetRemoveMemberKwParams{
    ServicedelegationtargetRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetRemoveMemberArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationtargetRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
member principal
principal to remove
    */
    Principal *[]string `json:"principal,omitempty"`
  }

type servicedelegationtargetRemoveMemberKwParams struct {
  *ServicedelegationtargetRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetRemoveMemberResult `json:"result"`
}

type ServicedelegationtargetRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *ServicedelegationtargetRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetRemoveMemberResult%v", string(b))
}

/*
Display information about a named service delegation target.
*/
func (c *Client) ServicedelegationtargetShow(
  reqArgs *ServicedelegationtargetShowArgs,
  optArgs *ServicedelegationtargetShowOptionalArgs, // can be nil
) (*ServicedelegationtargetShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetShowKwParams{
    ServicedelegationtargetShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetShowArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationtargetShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type servicedelegationtargetShowKwParams struct {
  *ServicedelegationtargetShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetShowResult `json:"result"`
}

type ServicedelegationtargetShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Servicedelegationtarget `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *ServicedelegationtargetShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetShowResult%v", string(b))
}

/*
RPC command used to log the current user out of their session.
*/
func (c *Client) SessionLogout(
  reqArgs *SessionLogoutArgs,
  optArgs *SessionLogoutOptionalArgs, // can be nil
) (*SessionLogoutResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sessionLogoutKwParams{
    SessionLogoutOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "session_logout",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sessionLogoutResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SessionLogoutArgs struct {
  }

type SessionLogoutOptionalArgs struct {
  }

type sessionLogoutKwParams struct {
  *SessionLogoutOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sessionLogoutResponse struct {
	Error  *Error      `json:"error"`
	Result *SessionLogoutResult `json:"result"`
}

type SessionLogoutResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *SessionLogoutResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SessionLogoutResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SessionLogoutResult%v", string(b))
}

/*
Determine whether ipa-adtrust-install has been run with sidgen task
*/
func (c *Client) SidgenWasRun(
  reqArgs *SidgenWasRunArgs,
  optArgs *SidgenWasRunOptionalArgs, // can be nil
) (*SidgenWasRunResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sidgenWasRunKwParams{
    SidgenWasRunOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sidgen_was_run",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sidgenWasRunResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SidgenWasRunArgs struct {
  }

type SidgenWasRunOptionalArgs struct {
  }

type sidgenWasRunKwParams struct {
  *SidgenWasRunOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sidgenWasRunResponse struct {
	Error  *Error      `json:"error"`
	Result *SidgenWasRunResult `json:"result"`
}

type SidgenWasRunResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *SidgenWasRunResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SidgenWasRunResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SidgenWasRunResult%v", string(b))
}

/*
Activate a stage user.
*/
func (c *Client) StageuserActivate(
  reqArgs *StageuserActivateArgs,
  optArgs *StageuserActivateOptionalArgs, // can be nil
) (*StageuserActivateResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserActivateKwParams{
    StageuserActivateOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_activate",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserActivateResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserActivateArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type StageuserActivateOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserActivateKwParams struct {
  *StageuserActivateOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserActivateResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserActivateResult `json:"result"`
}

type StageuserActivateResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserActivateResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserActivateResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserActivateResult%v", string(b))
}

/*
Add a new stage user.
*/
func (c *Client) StageuserAdd(
  reqArgs *StageuserAddArgs,
  optArgs *StageuserAddOptionalArgs, // can be nil
) (*StageuserAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddKwParams{
    StageuserAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type StageuserAddOptionalArgs struct {
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Create Stage user in from a delete user
    */
    FromDelete *bool `json:"from_delete,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserAddKwParams struct {
  *StageuserAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddResult `json:"result"`
}

type StageuserAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Stageuser `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddResult%v", string(b))
}

/*
Add one or more certificates to the stageuser entry
*/
func (c *Client) StageuserAddCert(
  reqArgs *StageuserAddCertArgs,
  optArgs *StageuserAddCertOptionalArgs, // can be nil
) (*StageuserAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddCertKwParams{
    StageuserAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add_cert",
    Params: []interface{}{
      []interface{}{reqArgs.UID, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddCertArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type StageuserAddCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserAddCertKwParams struct {
  *StageuserAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddCertResult `json:"result"`
}

type StageuserAddCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddCertResult%v", string(b))
}

/*
Add one or more certificate mappings to the stage user entry.
*/
func (c *Client) StageuserAddCertmapdata(
  ipacertmapdata string, // Certificate mapping data
  reqArgs *StageuserAddCertmapdataArgs,
  optArgs *StageuserAddCertmapdataOptionalArgs, // can be nil
) (*StageuserAddCertmapdataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddCertmapdataKwParams{
    StageuserAddCertmapdataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add_certmapdata",
    Params: []interface{}{
      []interface{}{reqArgs.UID, ipacertmapdata, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddCertmapdataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddCertmapdataArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type StageuserAddCertmapdataOptionalArgs struct {
  
    /*
Issuer
Issuer of the certificate
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Subject
Subject of the certificate
    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate *[]interface{} `json:"certificate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserAddCertmapdataKwParams struct {
  *StageuserAddCertmapdataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddCertmapdataResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddCertmapdataResult `json:"result"`
}

type StageuserAddCertmapdataResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserAddCertmapdataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddCertmapdataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddCertmapdataResult%v", string(b))
}

/*
Add a manager to the stage user entry
*/
func (c *Client) StageuserAddManager(
  reqArgs *StageuserAddManagerArgs,
  optArgs *StageuserAddManagerOptionalArgs, // can be nil
) (*StageuserAddManagerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddManagerKwParams{
    StageuserAddManagerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add_manager",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddManagerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddManagerArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type StageuserAddManagerOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  }

type stageuserAddManagerKwParams struct {
  *StageuserAddManagerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddManagerResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddManagerResult `json:"result"`
}

type StageuserAddManagerResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *StageuserAddManagerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddManagerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddManagerResult%v", string(b))
}

/*
Add new principal alias to the stageuser entry
*/
func (c *Client) StageuserAddPrincipal(
  reqArgs *StageuserAddPrincipalArgs,
  optArgs *StageuserAddPrincipalOptionalArgs, // can be nil
) (*StageuserAddPrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddPrincipalKwParams{
    StageuserAddPrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add_principal",
    Params: []interface{}{
      []interface{}{reqArgs.UID, reqArgs.Krbprincipalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddPrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddPrincipalArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type StageuserAddPrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserAddPrincipalKwParams struct {
  *StageuserAddPrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddPrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddPrincipalResult `json:"result"`
}

type StageuserAddPrincipalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserAddPrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddPrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddPrincipalResult%v", string(b))
}

/*
Delete a stage user.
*/
func (c *Client) StageuserDel(
  reqArgs *StageuserDelArgs,
  optArgs *StageuserDelOptionalArgs, // can be nil
) (*StageuserDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserDelKwParams{
    StageuserDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_del",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserDelArgs struct {
  
    /*
User login

    */
    UID []string `json:"uid,omitempty"`
  }

type StageuserDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type stageuserDelKwParams struct {
  *StageuserDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserDelResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserDelResult `json:"result"`
}

type StageuserDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Stageuser `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserDelResult%v", string(b))
}

/*
Search for stage users.
*/
func (c *Client) StageuserFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *StageuserFindArgs,
  optArgs *StageuserFindOptionalArgs, // can be nil
) (*StageuserFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserFindKwParams{
    StageuserFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserFindArgs struct {
  }

type StageuserFindOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("login")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
group
Search for stage users with these member of groups.
    */
    InGroup *[]string `json:"in_group,omitempty"`
  
    /*
group
Search for stage users without these member of groups.
    */
    NotInGroup *[]string `json:"not_in_group,omitempty"`
  
    /*
netgroup
Search for stage users with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for stage users without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
role
Search for stage users with these member of roles.
    */
    InRole *[]string `json:"in_role,omitempty"`
  
    /*
role
Search for stage users without these member of roles.
    */
    NotInRole *[]string `json:"not_in_role,omitempty"`
  
    /*
HBAC rule
Search for stage users with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for stage users without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for stage users with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for stage users without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  }

type stageuserFindKwParams struct {
  *StageuserFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserFindResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserFindResult `json:"result"`
}

type StageuserFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Stageuser `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *StageuserFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserFindResult%v", string(b))
}

/*
Modify a stage user.
*/
func (c *Client) StageuserMod(
  reqArgs *StageuserModArgs,
  optArgs *StageuserModOptionalArgs, // can be nil
) (*StageuserModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserModKwParams{
    StageuserModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_mod",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserModArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type StageuserModOptionalArgs struct {
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the stage user object
    */
    Rename *string `json:"rename,omitempty"`
  }

type stageuserModKwParams struct {
  *StageuserModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserModResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserModResult `json:"result"`
}

type StageuserModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Stageuser `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserModResult%v", string(b))
}

/*
Remove one or more certificates to the stageuser entry
*/
func (c *Client) StageuserRemoveCert(
  reqArgs *StageuserRemoveCertArgs,
  optArgs *StageuserRemoveCertOptionalArgs, // can be nil
) (*StageuserRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserRemoveCertKwParams{
    StageuserRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_remove_cert",
    Params: []interface{}{
      []interface{}{reqArgs.UID, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserRemoveCertArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type StageuserRemoveCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserRemoveCertKwParams struct {
  *StageuserRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserRemoveCertResult `json:"result"`
}

type StageuserRemoveCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserRemoveCertResult%v", string(b))
}

/*
Remove one or more certificate mappings from the stage user entry.
*/
func (c *Client) StageuserRemoveCertmapdata(
  ipacertmapdata string, // Certificate mapping data
  reqArgs *StageuserRemoveCertmapdataArgs,
  optArgs *StageuserRemoveCertmapdataOptionalArgs, // can be nil
) (*StageuserRemoveCertmapdataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserRemoveCertmapdataKwParams{
    StageuserRemoveCertmapdataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_remove_certmapdata",
    Params: []interface{}{
      []interface{}{reqArgs.UID, ipacertmapdata, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserRemoveCertmapdataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserRemoveCertmapdataArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type StageuserRemoveCertmapdataOptionalArgs struct {
  
    /*
Issuer
Issuer of the certificate
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Subject
Subject of the certificate
    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate *[]interface{} `json:"certificate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserRemoveCertmapdataKwParams struct {
  *StageuserRemoveCertmapdataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserRemoveCertmapdataResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserRemoveCertmapdataResult `json:"result"`
}

type StageuserRemoveCertmapdataResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserRemoveCertmapdataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserRemoveCertmapdataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserRemoveCertmapdataResult%v", string(b))
}

/*
Remove a manager to the stage user entry
*/
func (c *Client) StageuserRemoveManager(
  reqArgs *StageuserRemoveManagerArgs,
  optArgs *StageuserRemoveManagerOptionalArgs, // can be nil
) (*StageuserRemoveManagerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserRemoveManagerKwParams{
    StageuserRemoveManagerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_remove_manager",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserRemoveManagerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserRemoveManagerArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type StageuserRemoveManagerOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  }

type stageuserRemoveManagerKwParams struct {
  *StageuserRemoveManagerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserRemoveManagerResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserRemoveManagerResult `json:"result"`
}

type StageuserRemoveManagerResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *StageuserRemoveManagerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserRemoveManagerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserRemoveManagerResult%v", string(b))
}

/*
Remove principal alias from the stageuser entry
*/
func (c *Client) StageuserRemovePrincipal(
  reqArgs *StageuserRemovePrincipalArgs,
  optArgs *StageuserRemovePrincipalOptionalArgs, // can be nil
) (*StageuserRemovePrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserRemovePrincipalKwParams{
    StageuserRemovePrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_remove_principal",
    Params: []interface{}{
      []interface{}{reqArgs.UID, reqArgs.Krbprincipalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserRemovePrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserRemovePrincipalArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type StageuserRemovePrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserRemovePrincipalKwParams struct {
  *StageuserRemovePrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserRemovePrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserRemovePrincipalResult `json:"result"`
}

type StageuserRemovePrincipalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserRemovePrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserRemovePrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserRemovePrincipalResult%v", string(b))
}

/*
Display information about a stage user.
*/
func (c *Client) StageuserShow(
  reqArgs *StageuserShowArgs,
  optArgs *StageuserShowOptionalArgs, // can be nil
) (*StageuserShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserShowKwParams{
    StageuserShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_show",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserShowArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type StageuserShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserShowKwParams struct {
  *StageuserShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserShowResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserShowResult `json:"result"`
}

type StageuserShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Stageuser `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *StageuserShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserShowResult%v", string(b))
}

/*
Create new Sudo Command.
*/
func (c *Client) SudocmdAdd(
  reqArgs *SudocmdAddArgs,
  optArgs *SudocmdAddOptionalArgs, // can be nil
) (*SudocmdAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdAddKwParams{
    SudocmdAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_add",
    Params: []interface{}{
      []interface{}{reqArgs.Sudocmd, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdAddArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd string `json:"sudocmd,omitempty"`
  }

type SudocmdAddOptionalArgs struct {
  
    /*
Description
A description of this command
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdAddKwParams struct {
  *SudocmdAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdAddResult `json:"result"`
}

type SudocmdAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Sudocmd `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudocmdAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdAddResult%v", string(b))
}

/*
Delete Sudo Command.
*/
func (c *Client) SudocmdDel(
  reqArgs *SudocmdDelArgs,
  optArgs *SudocmdDelOptionalArgs, // can be nil
) (*SudocmdDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdDelKwParams{
    SudocmdDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_del",
    Params: []interface{}{
      []interface{}{reqArgs.Sudocmd, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdDelArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd []string `json:"sudocmd,omitempty"`
  }

type SudocmdDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type sudocmdDelKwParams struct {
  *SudocmdDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdDelResult `json:"result"`
}

type SudocmdDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Sudocmd `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudocmdDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdDelResult%v", string(b))
}

/*
Search for Sudo Commands.
*/
func (c *Client) SudocmdFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SudocmdFindArgs,
  optArgs *SudocmdFindOptionalArgs, // can be nil
) (*SudocmdFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdFindKwParams{
    SudocmdFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdFindArgs struct {
  }

type SudocmdFindOptionalArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd *string `json:"sudocmd,omitempty"`
  
    /*
Description
A description of this command
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("command")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type sudocmdFindKwParams struct {
  *SudocmdFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdFindResult `json:"result"`
}

type SudocmdFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Sudocmd `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *SudocmdFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdFindResult%v", string(b))
}

/*
Modify Sudo Command.
*/
func (c *Client) SudocmdMod(
  reqArgs *SudocmdModArgs,
  optArgs *SudocmdModOptionalArgs, // can be nil
) (*SudocmdModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdModKwParams{
    SudocmdModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Sudocmd, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdModArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd string `json:"sudocmd,omitempty"`
  }

type SudocmdModOptionalArgs struct {
  
    /*
Description
A description of this command
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdModKwParams struct {
  *SudocmdModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdModResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdModResult `json:"result"`
}

type SudocmdModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Sudocmd `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudocmdModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdModResult%v", string(b))
}

/*
Display Sudo Command.
*/
func (c *Client) SudocmdShow(
  reqArgs *SudocmdShowArgs,
  optArgs *SudocmdShowOptionalArgs, // can be nil
) (*SudocmdShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdShowKwParams{
    SudocmdShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_show",
    Params: []interface{}{
      []interface{}{reqArgs.Sudocmd, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdShowArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd string `json:"sudocmd,omitempty"`
  }

type SudocmdShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdShowKwParams struct {
  *SudocmdShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdShowResult `json:"result"`
}

type SudocmdShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Sudocmd `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudocmdShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdShowResult%v", string(b))
}

/*
Create new Sudo Command Group.
*/
func (c *Client) SudocmdgroupAdd(
  reqArgs *SudocmdgroupAddArgs,
  optArgs *SudocmdgroupAddOptionalArgs, // can be nil
) (*SudocmdgroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupAddKwParams{
    SudocmdgroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupAddArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupAddOptionalArgs struct {
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdgroupAddKwParams struct {
  *SudocmdgroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupAddResult `json:"result"`
}

type SudocmdgroupAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Sudocmdgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudocmdgroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupAddResult%v", string(b))
}

/*
Add members to Sudo Command Group.
*/
func (c *Client) SudocmdgroupAddMember(
  reqArgs *SudocmdgroupAddMemberArgs,
  optArgs *SudocmdgroupAddMemberOptionalArgs, // can be nil
) (*SudocmdgroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupAddMemberKwParams{
    SudocmdgroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupAddMemberArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to add
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  }

type sudocmdgroupAddMemberKwParams struct {
  *SudocmdgroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupAddMemberResult `json:"result"`
}

type SudocmdgroupAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudocmdgroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupAddMemberResult%v", string(b))
}

/*
Delete Sudo Command Group.
*/
func (c *Client) SudocmdgroupDel(
  reqArgs *SudocmdgroupDelArgs,
  optArgs *SudocmdgroupDelOptionalArgs, // can be nil
) (*SudocmdgroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupDelKwParams{
    SudocmdgroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupDelArgs struct {
  
    /*
Sudo Command Group

    */
    Cn []string `json:"cn,omitempty"`
  }

type SudocmdgroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type sudocmdgroupDelKwParams struct {
  *SudocmdgroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupDelResult `json:"result"`
}

type SudocmdgroupDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Sudocmdgroup `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudocmdgroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupDelResult%v", string(b))
}

/*
Search for Sudo Command Groups.
*/
func (c *Client) SudocmdgroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SudocmdgroupFindArgs,
  optArgs *SudocmdgroupFindOptionalArgs, // can be nil
) (*SudocmdgroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupFindKwParams{
    SudocmdgroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupFindArgs struct {
  }

type SudocmdgroupFindOptionalArgs struct {
  
    /*
Sudo Command Group

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("sudocmdgroup-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type sudocmdgroupFindKwParams struct {
  *SudocmdgroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupFindResult `json:"result"`
}

type SudocmdgroupFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Sudocmdgroup `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *SudocmdgroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupFindResult%v", string(b))
}

/*
Modify Sudo Command Group.
*/
func (c *Client) SudocmdgroupMod(
  reqArgs *SudocmdgroupModArgs,
  optArgs *SudocmdgroupModOptionalArgs, // can be nil
) (*SudocmdgroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupModKwParams{
    SudocmdgroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupModArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupModOptionalArgs struct {
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdgroupModKwParams struct {
  *SudocmdgroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupModResult `json:"result"`
}

type SudocmdgroupModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Sudocmdgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudocmdgroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupModResult%v", string(b))
}

/*
Remove members from Sudo Command Group.
*/
func (c *Client) SudocmdgroupRemoveMember(
  reqArgs *SudocmdgroupRemoveMemberArgs,
  optArgs *SudocmdgroupRemoveMemberOptionalArgs, // can be nil
) (*SudocmdgroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupRemoveMemberKwParams{
    SudocmdgroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupRemoveMemberArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to remove
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  }

type sudocmdgroupRemoveMemberKwParams struct {
  *SudocmdgroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupRemoveMemberResult `json:"result"`
}

type SudocmdgroupRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudocmdgroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupRemoveMemberResult%v", string(b))
}

/*
Display Sudo Command Group.
*/
func (c *Client) SudocmdgroupShow(
  reqArgs *SudocmdgroupShowArgs,
  optArgs *SudocmdgroupShowOptionalArgs, // can be nil
) (*SudocmdgroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupShowKwParams{
    SudocmdgroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupShowArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdgroupShowKwParams struct {
  *SudocmdgroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupShowResult `json:"result"`
}

type SudocmdgroupShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Sudocmdgroup `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudocmdgroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupShowResult%v", string(b))
}

/*
Create new Sudo Rule.
*/
func (c *Client) SudoruleAdd(
  reqArgs *SudoruleAddArgs,
  optArgs *SudoruleAddOptionalArgs, // can be nil
) (*SudoruleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddKwParams{
    SudoruleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Command category
Command category the rule applies to
    */
    Cmdcategory *string `json:"cmdcategory,omitempty"`
  
    /*
RunAs User category
RunAs User category the rule applies to
    */
    Ipasudorunasusercategory *string `json:"ipasudorunasusercategory,omitempty"`
  
    /*
RunAs Group category
RunAs Group category the rule applies to
    */
    Ipasudorunasgroupcategory *string `json:"ipasudorunasgroupcategory,omitempty"`
  
    /*
Sudo order
integer to order the Sudo rules
    */
    Sudoorder *int `json:"sudoorder,omitempty"`
  
    /*
External User
External User the rule applies to (sudorule-find only)
    */
    Externaluser *string `json:"externaluser,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
RunAs External User
External User the commands can run as (sudorule-find only)
    */
    Ipasudorunasextuser *string `json:"ipasudorunasextuser,omitempty"`
  
    /*
RunAs External Group
External Group the commands can run as (sudorule-find only)
    */
    Ipasudorunasextgroup *string `json:"ipasudorunasextgroup,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudoruleAddKwParams struct {
  *SudoruleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddResult `json:"result"`
}

type SudoruleAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Sudorule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudoruleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddResult%v", string(b))
}

/*
Add commands and sudo command groups affected by Sudo Rule.
*/
func (c *Client) SudoruleAddAllowCommand(
  reqArgs *SudoruleAddAllowCommandArgs,
  optArgs *SudoruleAddAllowCommandOptionalArgs, // can be nil
) (*SudoruleAddAllowCommandResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddAllowCommandKwParams{
    SudoruleAddAllowCommandOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_allow_command",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddAllowCommandResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddAllowCommandArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddAllowCommandOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to add
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  
    /*
member sudo command group
sudo command groups to add
    */
    Sudocmdgroup *[]string `json:"sudocmdgroup,omitempty"`
  }

type sudoruleAddAllowCommandKwParams struct {
  *SudoruleAddAllowCommandOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddAllowCommandResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddAllowCommandResult `json:"result"`
}

type SudoruleAddAllowCommandResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleAddAllowCommandResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddAllowCommandResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddAllowCommandResult%v", string(b))
}

/*
Add commands and sudo command groups affected by Sudo Rule.
*/
func (c *Client) SudoruleAddDenyCommand(
  reqArgs *SudoruleAddDenyCommandArgs,
  optArgs *SudoruleAddDenyCommandOptionalArgs, // can be nil
) (*SudoruleAddDenyCommandResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddDenyCommandKwParams{
    SudoruleAddDenyCommandOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_deny_command",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddDenyCommandResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddDenyCommandArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddDenyCommandOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to add
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  
    /*
member sudo command group
sudo command groups to add
    */
    Sudocmdgroup *[]string `json:"sudocmdgroup,omitempty"`
  }

type sudoruleAddDenyCommandKwParams struct {
  *SudoruleAddDenyCommandOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddDenyCommandResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddDenyCommandResult `json:"result"`
}

type SudoruleAddDenyCommandResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleAddDenyCommandResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddDenyCommandResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddDenyCommandResult%v", string(b))
}

/*
Add hosts and hostgroups affected by Sudo Rule.
*/
func (c *Client) SudoruleAddHost(
  reqArgs *SudoruleAddHostArgs,
  optArgs *SudoruleAddHostOptionalArgs, // can be nil
) (*SudoruleAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddHostKwParams{
    SudoruleAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_host",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
host masks of allowed hosts

    */
    Hostmask *[]string `json:"hostmask,omitempty"`
  }

type sudoruleAddHostKwParams struct {
  *SudoruleAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddHostResult `json:"result"`
}

type SudoruleAddHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddHostResult%v", string(b))
}

/*
Add an option to the Sudo Rule.
*/
func (c *Client) SudoruleAddOption(
  reqArgs *SudoruleAddOptionArgs,
  optArgs *SudoruleAddOptionOptionalArgs, // can be nil
) (*SudoruleAddOptionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddOptionKwParams{
    SudoruleAddOptionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_option",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Ipasudoopt, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddOptionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddOptionArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Sudo Option

    */
    Ipasudoopt string `json:"ipasudoopt,omitempty"`
  }

type SudoruleAddOptionOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudoruleAddOptionKwParams struct {
  *SudoruleAddOptionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddOptionResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddOptionResult `json:"result"`
}

type SudoruleAddOptionResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudoruleAddOptionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddOptionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddOptionResult%v", string(b))
}

/*
Add group for Sudo to execute as.
*/
func (c *Client) SudoruleAddRunasgroup(
  reqArgs *SudoruleAddRunasgroupArgs,
  optArgs *SudoruleAddRunasgroupOptionalArgs, // can be nil
) (*SudoruleAddRunasgroupResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddRunasgroupKwParams{
    SudoruleAddRunasgroupOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_runasgroup",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddRunasgroupResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddRunasgroupArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddRunasgroupOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleAddRunasgroupKwParams struct {
  *SudoruleAddRunasgroupOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddRunasgroupResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddRunasgroupResult `json:"result"`
}

type SudoruleAddRunasgroupResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleAddRunasgroupResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddRunasgroupResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddRunasgroupResult%v", string(b))
}

/*
Add users and groups for Sudo to execute as.
*/
func (c *Client) SudoruleAddRunasuser(
  reqArgs *SudoruleAddRunasuserArgs,
  optArgs *SudoruleAddRunasuserOptionalArgs, // can be nil
) (*SudoruleAddRunasuserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddRunasuserKwParams{
    SudoruleAddRunasuserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_runasuser",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddRunasuserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddRunasuserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddRunasuserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleAddRunasuserKwParams struct {
  *SudoruleAddRunasuserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddRunasuserResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddRunasuserResult `json:"result"`
}

type SudoruleAddRunasuserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleAddRunasuserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddRunasuserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddRunasuserResult%v", string(b))
}

/*
Add users and groups affected by Sudo Rule.
*/
func (c *Client) SudoruleAddUser(
  reqArgs *SudoruleAddUserArgs,
  optArgs *SudoruleAddUserOptionalArgs, // can be nil
) (*SudoruleAddUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddUserKwParams{
    SudoruleAddUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_user",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleAddUserKwParams struct {
  *SudoruleAddUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddUserResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddUserResult `json:"result"`
}

type SudoruleAddUserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleAddUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddUserResult%v", string(b))
}

/*
Delete Sudo Rule.
*/
func (c *Client) SudoruleDel(
  reqArgs *SudoruleDelArgs,
  optArgs *SudoruleDelOptionalArgs, // can be nil
) (*SudoruleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleDelKwParams{
    SudoruleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleDelArgs struct {
  
    /*
Rule name

    */
    Cn []string `json:"cn,omitempty"`
  }

type SudoruleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type sudoruleDelKwParams struct {
  *SudoruleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleDelResult `json:"result"`
}

type SudoruleDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Sudorule `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudoruleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleDelResult%v", string(b))
}

/*
Disable a Sudo Rule.
*/
func (c *Client) SudoruleDisable(
  reqArgs *SudoruleDisableArgs,
  optArgs *SudoruleDisableOptionalArgs, // can be nil
) (*SudoruleDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleDisableKwParams{
    SudoruleDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleDisableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleDisableOptionalArgs struct {
  }

type sudoruleDisableKwParams struct {
  *SudoruleDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleDisableResult `json:"result"`
}

type SudoruleDisableResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *SudoruleDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleDisableResult%v", string(b))
}

/*
Enable a Sudo Rule.
*/
func (c *Client) SudoruleEnable(
  reqArgs *SudoruleEnableArgs,
  optArgs *SudoruleEnableOptionalArgs, // can be nil
) (*SudoruleEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleEnableKwParams{
    SudoruleEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_enable",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleEnableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleEnableOptionalArgs struct {
  }

type sudoruleEnableKwParams struct {
  *SudoruleEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleEnableResult `json:"result"`
}

type SudoruleEnableResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *SudoruleEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleEnableResult%v", string(b))
}

/*
Search for Sudo Rule.
*/
func (c *Client) SudoruleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SudoruleFindArgs,
  optArgs *SudoruleFindOptionalArgs, // can be nil
) (*SudoruleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleFindKwParams{
    SudoruleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleFindArgs struct {
  }

type SudoruleFindOptionalArgs struct {
  
    /*
Rule name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Command category
Command category the rule applies to
    */
    Cmdcategory *string `json:"cmdcategory,omitempty"`
  
    /*
RunAs User category
RunAs User category the rule applies to
    */
    Ipasudorunasusercategory *string `json:"ipasudorunasusercategory,omitempty"`
  
    /*
RunAs Group category
RunAs Group category the rule applies to
    */
    Ipasudorunasgroupcategory *string `json:"ipasudorunasgroupcategory,omitempty"`
  
    /*
Sudo order
integer to order the Sudo rules
    */
    Sudoorder *int `json:"sudoorder,omitempty"`
  
    /*
External User
External User the rule applies to (sudorule-find only)
    */
    Externaluser *string `json:"externaluser,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
RunAs External User
External User the commands can run as (sudorule-find only)
    */
    Ipasudorunasextuser *string `json:"ipasudorunasextuser,omitempty"`
  
    /*
RunAs External Group
External Group the commands can run as (sudorule-find only)
    */
    Ipasudorunasextgroup *string `json:"ipasudorunasextgroup,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("sudorule-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type sudoruleFindKwParams struct {
  *SudoruleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleFindResult `json:"result"`
}

type SudoruleFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Sudorule `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *SudoruleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleFindResult%v", string(b))
}

/*
Modify Sudo Rule.
*/
func (c *Client) SudoruleMod(
  reqArgs *SudoruleModArgs,
  optArgs *SudoruleModOptionalArgs, // can be nil
) (*SudoruleModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleModKwParams{
    SudoruleModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleModArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Command category
Command category the rule applies to
    */
    Cmdcategory *string `json:"cmdcategory,omitempty"`
  
    /*
RunAs User category
RunAs User category the rule applies to
    */
    Ipasudorunasusercategory *string `json:"ipasudorunasusercategory,omitempty"`
  
    /*
RunAs Group category
RunAs Group category the rule applies to
    */
    Ipasudorunasgroupcategory *string `json:"ipasudorunasgroupcategory,omitempty"`
  
    /*
Sudo order
integer to order the Sudo rules
    */
    Sudoorder *int `json:"sudoorder,omitempty"`
  
    /*
External User
External User the rule applies to (sudorule-find only)
    */
    Externaluser *string `json:"externaluser,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
RunAs External User
External User the commands can run as (sudorule-find only)
    */
    Ipasudorunasextuser *string `json:"ipasudorunasextuser,omitempty"`
  
    /*
RunAs External Group
External Group the commands can run as (sudorule-find only)
    */
    Ipasudorunasextgroup *string `json:"ipasudorunasextgroup,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the sudo rule object
    */
    Rename *string `json:"rename,omitempty"`
  }

type sudoruleModKwParams struct {
  *SudoruleModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleModResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleModResult `json:"result"`
}

type SudoruleModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Sudorule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudoruleModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleModResult%v", string(b))
}

/*
Remove commands and sudo command groups affected by Sudo Rule.
*/
func (c *Client) SudoruleRemoveAllowCommand(
  reqArgs *SudoruleRemoveAllowCommandArgs,
  optArgs *SudoruleRemoveAllowCommandOptionalArgs, // can be nil
) (*SudoruleRemoveAllowCommandResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveAllowCommandKwParams{
    SudoruleRemoveAllowCommandOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_allow_command",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveAllowCommandResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveAllowCommandArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveAllowCommandOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to remove
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  
    /*
member sudo command group
sudo command groups to remove
    */
    Sudocmdgroup *[]string `json:"sudocmdgroup,omitempty"`
  }

type sudoruleRemoveAllowCommandKwParams struct {
  *SudoruleRemoveAllowCommandOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveAllowCommandResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveAllowCommandResult `json:"result"`
}

type SudoruleRemoveAllowCommandResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleRemoveAllowCommandResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveAllowCommandResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveAllowCommandResult%v", string(b))
}

/*
Remove commands and sudo command groups affected by Sudo Rule.
*/
func (c *Client) SudoruleRemoveDenyCommand(
  reqArgs *SudoruleRemoveDenyCommandArgs,
  optArgs *SudoruleRemoveDenyCommandOptionalArgs, // can be nil
) (*SudoruleRemoveDenyCommandResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveDenyCommandKwParams{
    SudoruleRemoveDenyCommandOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_deny_command",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveDenyCommandResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveDenyCommandArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveDenyCommandOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to remove
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  
    /*
member sudo command group
sudo command groups to remove
    */
    Sudocmdgroup *[]string `json:"sudocmdgroup,omitempty"`
  }

type sudoruleRemoveDenyCommandKwParams struct {
  *SudoruleRemoveDenyCommandOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveDenyCommandResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveDenyCommandResult `json:"result"`
}

type SudoruleRemoveDenyCommandResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleRemoveDenyCommandResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveDenyCommandResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveDenyCommandResult%v", string(b))
}

/*
Remove hosts and hostgroups affected by Sudo Rule.
*/
func (c *Client) SudoruleRemoveHost(
  reqArgs *SudoruleRemoveHostArgs,
  optArgs *SudoruleRemoveHostOptionalArgs, // can be nil
) (*SudoruleRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveHostKwParams{
    SudoruleRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_host",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
host masks of allowed hosts

    */
    Hostmask *[]string `json:"hostmask,omitempty"`
  }

type sudoruleRemoveHostKwParams struct {
  *SudoruleRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveHostResult `json:"result"`
}

type SudoruleRemoveHostResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveHostResult%v", string(b))
}

/*
Remove an option from Sudo Rule.
*/
func (c *Client) SudoruleRemoveOption(
  reqArgs *SudoruleRemoveOptionArgs,
  optArgs *SudoruleRemoveOptionOptionalArgs, // can be nil
) (*SudoruleRemoveOptionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveOptionKwParams{
    SudoruleRemoveOptionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_option",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Ipasudoopt, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveOptionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveOptionArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Sudo Option

    */
    Ipasudoopt string `json:"ipasudoopt,omitempty"`
  }

type SudoruleRemoveOptionOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudoruleRemoveOptionKwParams struct {
  *SudoruleRemoveOptionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveOptionResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveOptionResult `json:"result"`
}

type SudoruleRemoveOptionResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudoruleRemoveOptionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveOptionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveOptionResult%v", string(b))
}

/*
Remove group for Sudo to execute as.
*/
func (c *Client) SudoruleRemoveRunasgroup(
  reqArgs *SudoruleRemoveRunasgroupArgs,
  optArgs *SudoruleRemoveRunasgroupOptionalArgs, // can be nil
) (*SudoruleRemoveRunasgroupResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveRunasgroupKwParams{
    SudoruleRemoveRunasgroupOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_runasgroup",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveRunasgroupResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveRunasgroupArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveRunasgroupOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleRemoveRunasgroupKwParams struct {
  *SudoruleRemoveRunasgroupOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveRunasgroupResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveRunasgroupResult `json:"result"`
}

type SudoruleRemoveRunasgroupResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleRemoveRunasgroupResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveRunasgroupResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveRunasgroupResult%v", string(b))
}

/*
Remove users and groups for Sudo to execute as.
*/
func (c *Client) SudoruleRemoveRunasuser(
  reqArgs *SudoruleRemoveRunasuserArgs,
  optArgs *SudoruleRemoveRunasuserOptionalArgs, // can be nil
) (*SudoruleRemoveRunasuserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveRunasuserKwParams{
    SudoruleRemoveRunasuserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_runasuser",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveRunasuserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveRunasuserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveRunasuserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleRemoveRunasuserKwParams struct {
  *SudoruleRemoveRunasuserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveRunasuserResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveRunasuserResult `json:"result"`
}

type SudoruleRemoveRunasuserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleRemoveRunasuserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveRunasuserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveRunasuserResult%v", string(b))
}

/*
Remove users and groups affected by Sudo Rule.
*/
func (c *Client) SudoruleRemoveUser(
  reqArgs *SudoruleRemoveUserArgs,
  optArgs *SudoruleRemoveUserOptionalArgs, // can be nil
) (*SudoruleRemoveUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveUserKwParams{
    SudoruleRemoveUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_user",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleRemoveUserKwParams struct {
  *SudoruleRemoveUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveUserResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveUserResult `json:"result"`
}

type SudoruleRemoveUserResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *SudoruleRemoveUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveUserResult%v", string(b))
}

/*
Display Sudo Rule.
*/
func (c *Client) SudoruleShow(
  reqArgs *SudoruleShowArgs,
  optArgs *SudoruleShowOptionalArgs, // can be nil
) (*SudoruleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleShowKwParams{
    SudoruleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleShowArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudoruleShowKwParams struct {
  *SudoruleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleShowResult `json:"result"`
}

type SudoruleShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Sudorule `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *SudoruleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleShowResult%v", string(b))
}

/*
Search for help topics.
*/
func (c *Client) TopicFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TopicFindArgs,
  optArgs *TopicFindOptionalArgs, // can be nil
) (*TopicFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topicFindKwParams{
    TopicFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topic_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topicFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopicFindArgs struct {
  }

type TopicFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type topicFindKwParams struct {
  *TopicFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topicFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TopicFindResult `json:"result"`
}

type TopicFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Topic `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *TopicFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopicFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopicFindResult%v", string(b))
}

/*
Display information about a help topic.
*/
func (c *Client) TopicShow(
  reqArgs *TopicShowArgs,
  optArgs *TopicShowOptionalArgs, // can be nil
) (*TopicShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topicShowKwParams{
    TopicShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topic_show",
    Params: []interface{}{
      []interface{}{reqArgs.FullName, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topicShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopicShowArgs struct {
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  }

type TopicShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topicShowKwParams struct {
  *TopicShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topicShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TopicShowResult `json:"result"`
}

type TopicShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Topic `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopicShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopicShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopicShowResult%v", string(b))
}

/*
Add a new segment.
*/
func (c *Client) TopologysegmentAdd(
  reqArgs *TopologysegmentAddArgs,
  optArgs *TopologysegmentAddOptionalArgs, // can be nil
) (*TopologysegmentAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentAddKwParams{
    TopologysegmentAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_add",
    Params: []interface{}{
      []interface{}{reqArgs.Topologysuffixcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentAddArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysegmentAddOptionalArgs struct {
  
    /*
Left node
Left replication node - an IPA server
    */
    Iparepltoposegmentleftnode *string `json:"iparepltoposegmentleftnode,omitempty"`
  
    /*
Right node
Right replication node - an IPA server
    */
    Iparepltoposegmentrightnode *string `json:"iparepltoposegmentrightnode,omitempty"`
  
    /*
Connectivity
Direction of replication between left and right replication node
    */
    Iparepltoposegmentdirection *string `json:"iparepltoposegmentdirection,omitempty"`
  
    /*
Attributes to strip
A space separated list of attributes which are removed from replication updates.
    */
    Nsds5replicastripattrs *string `json:"nsds5replicastripattrs,omitempty"`
  
    /*
Attributes to replicate
Attributes that are not replicated to a consumer server during a fractional update. E.g., `(objectclass=*) $ EXCLUDE accountlockout memberof
    */
    Nsds5replicatedattributelist *string `json:"nsds5replicatedattributelist,omitempty"`
  
    /*
Attributes for total update
Attributes that are not replicated to a consumer server during a total update. E.g. (objectclass=*) $ EXCLUDE accountlockout
    */
    Nsds5replicatedattributelisttotal *string `json:"nsds5replicatedattributelisttotal,omitempty"`
  
    /*
Session timeout
Number of seconds outbound LDAP operations waits for a response from the remote replica before timing out and failing
    */
    Nsds5replicatimeout *int `json:"nsds5replicatimeout,omitempty"`
  
    /*
Replication agreement enabled
Whether a replication agreement is active, meaning whether replication is occurring per that agreement
    */
    Nsds5replicaenabled *string `json:"nsds5replicaenabled,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysegmentAddKwParams struct {
  *TopologysegmentAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentAddResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentAddResult `json:"result"`
}

type TopologysegmentAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Topologysegment `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopologysegmentAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentAddResult%v", string(b))
}

/*
Delete a segment.
*/
func (c *Client) TopologysegmentDel(
  reqArgs *TopologysegmentDelArgs,
  optArgs *TopologysegmentDelOptionalArgs, // can be nil
) (*TopologysegmentDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentDelKwParams{
    TopologysegmentDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_del",
    Params: []interface{}{
      []interface{}{reqArgs.Topologysuffixcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentDelArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn []string `json:"cn,omitempty"`
  }

type TopologysegmentDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type topologysegmentDelKwParams struct {
  *TopologysegmentDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentDelResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentDelResult `json:"result"`
}

type TopologysegmentDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Topologysegment `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopologysegmentDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentDelResult%v", string(b))
}

/*
Search for topology segments.
*/
func (c *Client) TopologysegmentFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TopologysegmentFindArgs,
  optArgs *TopologysegmentFindOptionalArgs, // can be nil
) (*TopologysegmentFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentFindKwParams{
    TopologysegmentFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_find",
    Params: []interface{}{
      []interface{}{reqArgs.Topologysuffixcn, criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentFindArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  }

type TopologysegmentFindOptionalArgs struct {
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Left node
Left replication node - an IPA server
    */
    Iparepltoposegmentleftnode *string `json:"iparepltoposegmentleftnode,omitempty"`
  
    /*
Right node
Right replication node - an IPA server
    */
    Iparepltoposegmentrightnode *string `json:"iparepltoposegmentrightnode,omitempty"`
  
    /*
Connectivity
Direction of replication between left and right replication node
    */
    Iparepltoposegmentdirection *string `json:"iparepltoposegmentdirection,omitempty"`
  
    /*
Attributes to strip
A space separated list of attributes which are removed from replication updates.
    */
    Nsds5replicastripattrs *string `json:"nsds5replicastripattrs,omitempty"`
  
    /*
Attributes to replicate
Attributes that are not replicated to a consumer server during a fractional update. E.g., `(objectclass=*) $ EXCLUDE accountlockout memberof
    */
    Nsds5replicatedattributelist *string `json:"nsds5replicatedattributelist,omitempty"`
  
    /*
Attributes for total update
Attributes that are not replicated to a consumer server during a total update. E.g. (objectclass=*) $ EXCLUDE accountlockout
    */
    Nsds5replicatedattributelisttotal *string `json:"nsds5replicatedattributelisttotal,omitempty"`
  
    /*
Session timeout
Number of seconds outbound LDAP operations waits for a response from the remote replica before timing out and failing
    */
    Nsds5replicatimeout *int `json:"nsds5replicatimeout,omitempty"`
  
    /*
Replication agreement enabled
Whether a replication agreement is active, meaning whether replication is occurring per that agreement
    */
    Nsds5replicaenabled *string `json:"nsds5replicaenabled,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type topologysegmentFindKwParams struct {
  *TopologysegmentFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentFindResult `json:"result"`
}

type TopologysegmentFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Topologysegment `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *TopologysegmentFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentFindResult%v", string(b))
}

/*
Modify a segment.
*/
func (c *Client) TopologysegmentMod(
  reqArgs *TopologysegmentModArgs,
  optArgs *TopologysegmentModOptionalArgs, // can be nil
) (*TopologysegmentModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentModKwParams{
    TopologysegmentModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Topologysuffixcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentModArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysegmentModOptionalArgs struct {
  
    /*
Attributes to strip
A space separated list of attributes which are removed from replication updates.
    */
    Nsds5replicastripattrs *string `json:"nsds5replicastripattrs,omitempty"`
  
    /*
Attributes to replicate
Attributes that are not replicated to a consumer server during a fractional update. E.g., `(objectclass=*) $ EXCLUDE accountlockout memberof
    */
    Nsds5replicatedattributelist *string `json:"nsds5replicatedattributelist,omitempty"`
  
    /*
Attributes for total update
Attributes that are not replicated to a consumer server during a total update. E.g. (objectclass=*) $ EXCLUDE accountlockout
    */
    Nsds5replicatedattributelisttotal *string `json:"nsds5replicatedattributelisttotal,omitempty"`
  
    /*
Session timeout
Number of seconds outbound LDAP operations waits for a response from the remote replica before timing out and failing
    */
    Nsds5replicatimeout *int `json:"nsds5replicatimeout,omitempty"`
  
    /*
Replication agreement enabled
Whether a replication agreement is active, meaning whether replication is occurring per that agreement
    */
    Nsds5replicaenabled *string `json:"nsds5replicaenabled,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysegmentModKwParams struct {
  *TopologysegmentModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentModResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentModResult `json:"result"`
}

type TopologysegmentModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Topologysegment `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopologysegmentModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentModResult%v", string(b))
}

/*
Request a full re-initialization of the node retrieving data from the other node.
*/
func (c *Client) TopologysegmentReinitialize(
  reqArgs *TopologysegmentReinitializeArgs,
  optArgs *TopologysegmentReinitializeOptionalArgs, // can be nil
) (*TopologysegmentReinitializeResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentReinitializeKwParams{
    TopologysegmentReinitializeOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_reinitialize",
    Params: []interface{}{
      []interface{}{reqArgs.Topologysuffixcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentReinitializeResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentReinitializeArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysegmentReinitializeOptionalArgs struct {
  
    /*

Initialize left node
    */
    Left *bool `json:"left,omitempty"`
  
    /*

Initialize right node
    */
    Right *bool `json:"right,omitempty"`
  
    /*

Stop already started refresh of chosen node(s)
    */
    Stop *bool `json:"stop,omitempty"`
  }

type topologysegmentReinitializeKwParams struct {
  *TopologysegmentReinitializeOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentReinitializeResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentReinitializeResult `json:"result"`
}

type TopologysegmentReinitializeResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopologysegmentReinitializeResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentReinitializeResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentReinitializeResult%v", string(b))
}

/*
Display a segment.
*/
func (c *Client) TopologysegmentShow(
  reqArgs *TopologysegmentShowArgs,
  optArgs *TopologysegmentShowOptionalArgs, // can be nil
) (*TopologysegmentShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentShowKwParams{
    TopologysegmentShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_show",
    Params: []interface{}{
      []interface{}{reqArgs.Topologysuffixcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentShowArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysegmentShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysegmentShowKwParams struct {
  *TopologysegmentShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentShowResult `json:"result"`
}

type TopologysegmentShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Topologysegment `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopologysegmentShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentShowResult%v", string(b))
}

/*
Add a new topology suffix to be managed.
*/
func (c *Client) TopologysuffixAdd(
  reqArgs *TopologysuffixAddArgs,
  optArgs *TopologysuffixAddOptionalArgs, // can be nil
) (*TopologysuffixAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixAddKwParams{
    TopologysuffixAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, reqArgs.Iparepltopoconfroot, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixAddArgs struct {
  
    /*
Suffix name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Managed LDAP suffix DN

    */
    Iparepltopoconfroot string `json:"iparepltopoconfroot,omitempty"`
  }

type TopologysuffixAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysuffixAddKwParams struct {
  *TopologysuffixAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixAddResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixAddResult `json:"result"`
}

type TopologysuffixAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Topologysuffix `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopologysuffixAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixAddResult%v", string(b))
}

/*
Delete a topology suffix.
*/
func (c *Client) TopologysuffixDel(
  reqArgs *TopologysuffixDelArgs,
  optArgs *TopologysuffixDelOptionalArgs, // can be nil
) (*TopologysuffixDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixDelKwParams{
    TopologysuffixDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixDelArgs struct {
  
    /*
Suffix name

    */
    Cn []string `json:"cn,omitempty"`
  }

type TopologysuffixDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type topologysuffixDelKwParams struct {
  *TopologysuffixDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixDelResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixDelResult `json:"result"`
}

type TopologysuffixDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Topologysuffix `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopologysuffixDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixDelResult%v", string(b))
}

/*
Search for topology suffixes.
*/
func (c *Client) TopologysuffixFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TopologysuffixFindArgs,
  optArgs *TopologysuffixFindOptionalArgs, // can be nil
) (*TopologysuffixFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixFindKwParams{
    TopologysuffixFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixFindArgs struct {
  }

type TopologysuffixFindOptionalArgs struct {
  
    /*
Suffix name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Managed LDAP suffix DN

    */
    Iparepltopoconfroot *string `json:"iparepltopoconfroot,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type topologysuffixFindKwParams struct {
  *TopologysuffixFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixFindResult `json:"result"`
}

type TopologysuffixFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Topologysuffix `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *TopologysuffixFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixFindResult%v", string(b))
}

/*
Modify a topology suffix.
*/
func (c *Client) TopologysuffixMod(
  reqArgs *TopologysuffixModArgs,
  optArgs *TopologysuffixModOptionalArgs, // can be nil
) (*TopologysuffixModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixModKwParams{
    TopologysuffixModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixModArgs struct {
  
    /*
Suffix name

    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysuffixModOptionalArgs struct {
  
    /*
Managed LDAP suffix DN

    */
    Iparepltopoconfroot *string `json:"iparepltopoconfroot,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysuffixModKwParams struct {
  *TopologysuffixModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixModResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixModResult `json:"result"`
}

type TopologysuffixModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Topologysuffix `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopologysuffixModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixModResult%v", string(b))
}

/*
Show managed suffix.
*/
func (c *Client) TopologysuffixShow(
  reqArgs *TopologysuffixShowArgs,
  optArgs *TopologysuffixShowOptionalArgs, // can be nil
) (*TopologysuffixShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixShowKwParams{
    TopologysuffixShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixShowArgs struct {
  
    /*
Suffix name

    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysuffixShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysuffixShowKwParams struct {
  *TopologysuffixShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixShowResult `json:"result"`
}

type TopologysuffixShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Topologysuffix `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TopologysuffixShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixShowResult%v", string(b))
}

/*
Verify replication topology for suffix.

Checks done:
  1. check if a topology is not disconnected. In other words if there are
     replication paths between all servers.
  2. check if servers don't have more than the recommended number of
     replication agreements
*/
func (c *Client) TopologysuffixVerify(
  reqArgs *TopologysuffixVerifyArgs,
  optArgs *TopologysuffixVerifyOptionalArgs, // can be nil
) (*TopologysuffixVerifyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixVerifyKwParams{
    TopologysuffixVerifyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_verify",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixVerifyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixVerifyArgs struct {
  
    /*
Suffix name

    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysuffixVerifyOptionalArgs struct {
  }

type topologysuffixVerifyKwParams struct {
  *TopologysuffixVerifyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixVerifyResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixVerifyResult `json:"result"`
}

type TopologysuffixVerifyResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  }

func (t *TopologysuffixVerifyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixVerifyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixVerifyResult%v", string(b))
}

/*
Add new trust to use.

This command establishes trust relationship to another domain
which becomes 'trusted'. As result, users of the trusted domain
may access resources of this domain.

Only trusts to Active Directory domains are supported right now.

The command can be safely run multiple times against the same domain,
this will cause change to trust relationship credentials on both
sides.

Note that if the command was previously run with a specific range type,
or with automatic detection of the range type, and you want to configure a
different range type, you may need to delete first the ID range using
ipa idrange-del before retrying the command with the desired range type.
*/
func (c *Client) TrustAdd(
  reqArgs *TrustAddArgs,
  optArgs *TrustAddOptionalArgs, // can be nil
) (*TrustAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustAddKwParams{
    TrustAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_add",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustAddArgs struct {
  
    /*
Realm name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*
Active Directory domain administrator

    */
    RealmAdmin *string `json:"realm_admin,omitempty"`
  
    /*
Active Directory domain administrator's password

    */
    RealmPasswd *string `json:"realm_passwd,omitempty"`
  
    /*
Domain controller for the Active Directory domain (optional)

    */
    RealmServer *string `json:"realm_server,omitempty"`
  
    /*
Shared secret for the trust

    */
    TrustSecret *string `json:"trust_secret,omitempty"`
  
    /*
First Posix ID of the range reserved for the trusted domain

    */
    BaseID *int `json:"base_id,omitempty"`
  
    /*
Size of the ID range reserved for the trusted domain

    */
    RangeSize *int `json:"range_size,omitempty"`
  
    /*
Range type
Type of trusted domain ID range, one of ipa-ad-trust, ipa-ad-trust-posix
    */
    RangeType *string `json:"range_type,omitempty"`
  
    /*
Two-way trust
Establish bi-directional trust. By default trust is inbound one-way only.
    */
    Bidirectional *bool `json:"bidirectional,omitempty"`
  
    /*
External trust
Establish external trust to a domain in another forest. The trust is not transitive beyond the domain.
    */
    External *bool `json:"external,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustAddKwParams struct {
  *TrustAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustAddResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustAddResult `json:"result"`
}

type TrustAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Trust `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustAddResult%v", string(b))
}

/*
Delete a trust.
*/
func (c *Client) TrustDel(
  reqArgs *TrustDelArgs,
  optArgs *TrustDelOptionalArgs, // can be nil
) (*TrustDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustDelKwParams{
    TrustDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustDelArgs struct {
  
    /*
Realm name

    */
    Cn []string `json:"cn,omitempty"`
  }

type TrustDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type trustDelKwParams struct {
  *TrustDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustDelResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustDelResult `json:"result"`
}

type TrustDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Trust `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustDelResult%v", string(b))
}

/*
Configure this server as a trust agent.
*/
func (c *Client) TrustEnableAgent(
  reqArgs *TrustEnableAgentArgs,
  optArgs *TrustEnableAgentOptionalArgs, // can be nil
) (*TrustEnableAgentResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustEnableAgentKwParams{
    TrustEnableAgentOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_enable_agent",
    Params: []interface{}{
      []interface{}{reqArgs.RemoteCn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustEnableAgentResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustEnableAgentArgs struct {
  
    /*
Remote server name
Remote IPA server hostname
    */
    RemoteCn string `json:"remote_cn,omitempty"`
  }

type TrustEnableAgentOptionalArgs struct {
  
    /*

Enable support for trusted domains for old clients
    */
    EnableCompat *bool `json:"enable_compat,omitempty"`
  }

type trustEnableAgentKwParams struct {
  *TrustEnableAgentOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustEnableAgentResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustEnableAgentResult `json:"result"`
}

type TrustEnableAgentResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *TrustEnableAgentResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustEnableAgentResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustEnableAgentResult%v", string(b))
}

/*
Refresh list of the domains associated with the trust
*/
func (c *Client) TrustFetchDomains(
  reqArgs *TrustFetchDomainsArgs,
  optArgs *TrustFetchDomainsOptionalArgs, // can be nil
) (*TrustFetchDomainsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustFetchDomainsKwParams{
    TrustFetchDomainsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_fetch_domains",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustFetchDomainsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustFetchDomainsArgs struct {
  
    /*
Realm name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustFetchDomainsOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Active Directory domain administrator

    */
    RealmAdmin *string `json:"realm_admin,omitempty"`
  
    /*
Active Directory domain administrator's password

    */
    RealmPasswd *string `json:"realm_passwd,omitempty"`
  
    /*
Domain controller for the Active Directory domain (optional)

    */
    RealmServer *string `json:"realm_server,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustFetchDomainsKwParams struct {
  *TrustFetchDomainsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustFetchDomainsResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustFetchDomainsResult `json:"result"`
}

type TrustFetchDomainsResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []interface{} `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *TrustFetchDomainsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustFetchDomainsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustFetchDomainsResult%v", string(b))
}

/*
Search for trusts.
*/
func (c *Client) TrustFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TrustFindArgs,
  optArgs *TrustFindOptionalArgs, // can be nil
) (*TrustFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustFindKwParams{
    TrustFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustFindArgs struct {
  }

type TrustFindOptionalArgs struct {
  
    /*
Realm name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
SID blacklist incoming

    */
    Ipantsidblacklistincoming *[]string `json:"ipantsidblacklistincoming,omitempty"`
  
    /*
SID blacklist outgoing

    */
    Ipantsidblacklistoutgoing *[]string `json:"ipantsidblacklistoutgoing,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("realm")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type trustFindKwParams struct {
  *TrustFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustFindResult `json:"result"`
}

type TrustFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Trust `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *TrustFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustFindResult%v", string(b))
}

/*
Modify a trust (for future use).

    Currently only the default option to modify the LDAP attributes is
    available. More specific options will be added in coming releases.
*/
func (c *Client) TrustMod(
  reqArgs *TrustModArgs,
  optArgs *TrustModOptionalArgs, // can be nil
) (*TrustModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustModKwParams{
    TrustModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustModArgs struct {
  
    /*
Realm name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustModOptionalArgs struct {
  
    /*
SID blacklist incoming

    */
    Ipantsidblacklistincoming *[]string `json:"ipantsidblacklistincoming,omitempty"`
  
    /*
SID blacklist outgoing

    */
    Ipantsidblacklistoutgoing *[]string `json:"ipantsidblacklistoutgoing,omitempty"`
  
    /*
UPN suffixes

    */
    Ipantadditionalsuffixes *[]string `json:"ipantadditionalsuffixes,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustModKwParams struct {
  *TrustModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustModResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustModResult `json:"result"`
}

type TrustModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Trust `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustModResult%v", string(b))
}

/*
Resolve security identifiers of users and groups in trusted domains
*/
func (c *Client) TrustResolve(
  reqArgs *TrustResolveArgs,
  optArgs *TrustResolveOptionalArgs, // can be nil
) (*TrustResolveResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustResolveKwParams{
    TrustResolveOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_resolve",
    Params: []interface{}{
      []interface{}{reqArgs.Sids, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustResolveResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustResolveArgs struct {
  
    /*
Security Identifiers (SIDs)

    */
    Sids []string `json:"sids,omitempty"`
  }

type TrustResolveOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustResolveKwParams struct {
  *TrustResolveOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustResolveResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustResolveResult `json:"result"`
}

type TrustResolveResult struct {
  
  
    /*

    (required)
    */
    Result []interface{} `json:"result,omitempty"`
  }

func (t *TrustResolveResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustResolveResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustResolveResult%v", string(b))
}

/*
Display information about a trust.
*/
func (c *Client) TrustShow(
  reqArgs *TrustShowArgs,
  optArgs *TrustShowOptionalArgs, // can be nil
) (*TrustShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustShowKwParams{
    TrustShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustShowArgs struct {
  
    /*
Realm name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustShowKwParams struct {
  *TrustShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustShowResult `json:"result"`
}

type TrustShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Trust `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustShowResult%v", string(b))
}

/*
Modify global trust configuration.
*/
func (c *Client) TrustconfigMod(
  reqArgs *TrustconfigModArgs,
  optArgs *TrustconfigModOptionalArgs, // can be nil
) (*TrustconfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustconfigModKwParams{
    TrustconfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustconfig_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustconfigModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustconfigModArgs struct {
  }

type TrustconfigModOptionalArgs struct {
  
    /*
Fallback primary group

    */
    Ipantfallbackprimarygroup *string `json:"ipantfallbackprimarygroup,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustconfigModKwParams struct {
  *TrustconfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustconfigModResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustconfigModResult `json:"result"`
}

type TrustconfigModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Trustconfig `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustconfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustconfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustconfigModResult%v", string(b))
}

/*
Show global trust configuration.
*/
func (c *Client) TrustconfigShow(
  reqArgs *TrustconfigShowArgs,
  optArgs *TrustconfigShowOptionalArgs, // can be nil
) (*TrustconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustconfigShowKwParams{
    TrustconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustconfigShowArgs struct {
  }

type TrustconfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustconfigShowKwParams struct {
  *TrustconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustconfigShowResult `json:"result"`
}

type TrustconfigShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Trustconfig `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustconfigShowResult%v", string(b))
}

/*
Allow access from the trusted domain
*/
func (c *Client) TrustdomainAdd(
  reqArgs *TrustdomainAddArgs,
  optArgs *TrustdomainAddOptionalArgs, // can be nil
) (*TrustdomainAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainAddKwParams{
    TrustdomainAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_add",
    Params: []interface{}{
      []interface{}{reqArgs.Trustcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainAddArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustdomainAddOptionalArgs struct {
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustdomainAddKwParams struct {
  *TrustdomainAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainAddResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainAddResult `json:"result"`
}

type TrustdomainAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Trustdomain `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustdomainAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainAddResult%v", string(b))
}

/*
Remove information about the domain associated with the trust.
*/
func (c *Client) TrustdomainDel(
  reqArgs *TrustdomainDelArgs,
  optArgs *TrustdomainDelOptionalArgs, // can be nil
) (*TrustdomainDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainDelKwParams{
    TrustdomainDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_del",
    Params: []interface{}{
      []interface{}{reqArgs.Trustcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainDelArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn []string `json:"cn,omitempty"`
  }

type TrustdomainDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type trustdomainDelKwParams struct {
  *TrustdomainDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainDelResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainDelResult `json:"result"`
}

type TrustdomainDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Trustdomain `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustdomainDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainDelResult%v", string(b))
}

/*
Disable use of IPA resources by the domain of the trust
*/
func (c *Client) TrustdomainDisable(
  reqArgs *TrustdomainDisableArgs,
  optArgs *TrustdomainDisableOptionalArgs, // can be nil
) (*TrustdomainDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainDisableKwParams{
    TrustdomainDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_disable",
    Params: []interface{}{
      []interface{}{reqArgs.Trustcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainDisableArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustdomainDisableOptionalArgs struct {
  }

type trustdomainDisableKwParams struct {
  *TrustdomainDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainDisableResult `json:"result"`
}

type TrustdomainDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustdomainDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainDisableResult%v", string(b))
}

/*
Allow use of IPA resources by the domain of the trust
*/
func (c *Client) TrustdomainEnable(
  reqArgs *TrustdomainEnableArgs,
  optArgs *TrustdomainEnableOptionalArgs, // can be nil
) (*TrustdomainEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainEnableKwParams{
    TrustdomainEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_enable",
    Params: []interface{}{
      []interface{}{reqArgs.Trustcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainEnableArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustdomainEnableOptionalArgs struct {
  }

type trustdomainEnableKwParams struct {
  *TrustdomainEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainEnableResult `json:"result"`
}

type TrustdomainEnableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustdomainEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainEnableResult%v", string(b))
}

/*
Search domains of the trust
*/
func (c *Client) TrustdomainFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TrustdomainFindArgs,
  optArgs *TrustdomainFindOptionalArgs, // can be nil
) (*TrustdomainFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainFindKwParams{
    TrustdomainFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_find",
    Params: []interface{}{
      []interface{}{reqArgs.Trustcn, criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainFindArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  }

type TrustdomainFindOptionalArgs struct {
  
    /*
Domain name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("domain")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type trustdomainFindKwParams struct {
  *TrustdomainFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainFindResult `json:"result"`
}

type TrustdomainFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Trustdomain `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *TrustdomainFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainFindResult%v", string(b))
}

/*
Modify trustdomain of the trust
*/
func (c *Client) TrustdomainMod(
  reqArgs *TrustdomainModArgs,
  optArgs *TrustdomainModOptionalArgs, // can be nil
) (*TrustdomainModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainModKwParams{
    TrustdomainModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_mod",
    Params: []interface{}{
      []interface{}{reqArgs.Trustcn, reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainModArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustdomainModOptionalArgs struct {
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustdomainModKwParams struct {
  *TrustdomainModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainModResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainModResult `json:"result"`
}

type TrustdomainModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Trustdomain `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *TrustdomainModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainModResult%v", string(b))
}

/*
Add a new user.
*/
func (c *Client) UserAdd(
  reqArgs *UserAddArgs,
  optArgs *UserAddOptionalArgs, // can be nil
) (*UserAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddKwParams{
    UserAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserAddOptionalArgs struct {
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Account disabled

    */
    Nsaccountlock *bool `json:"nsaccountlock,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Don't create user private group
    */
    Noprivate *bool `json:"noprivate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userAddKwParams struct {
  *UserAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddResult `json:"result"`
}

type UserAddResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result User `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddResult%v", string(b))
}

/*
Add one or more certificates to the user entry
*/
func (c *Client) UserAddCert(
  reqArgs *UserAddCertArgs,
  optArgs *UserAddCertOptionalArgs, // can be nil
) (*UserAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddCertKwParams{
    UserAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add_cert",
    Params: []interface{}{
      []interface{}{reqArgs.UID, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddCertArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type UserAddCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userAddCertKwParams struct {
  *UserAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddCertResult `json:"result"`
}

type UserAddCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddCertResult%v", string(b))
}

/*
Add one or more certificate mappings to the user entry.
*/
func (c *Client) UserAddCertmapdata(
  ipacertmapdata string, // Certificate mapping data
  reqArgs *UserAddCertmapdataArgs,
  optArgs *UserAddCertmapdataOptionalArgs, // can be nil
) (*UserAddCertmapdataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddCertmapdataKwParams{
    UserAddCertmapdataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add_certmapdata",
    Params: []interface{}{
      []interface{}{reqArgs.UID, ipacertmapdata, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddCertmapdataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddCertmapdataArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserAddCertmapdataOptionalArgs struct {
  
    /*
Issuer
Issuer of the certificate
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Subject
Subject of the certificate
    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate *[]interface{} `json:"certificate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userAddCertmapdataKwParams struct {
  *UserAddCertmapdataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddCertmapdataResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddCertmapdataResult `json:"result"`
}

type UserAddCertmapdataResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserAddCertmapdataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddCertmapdataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddCertmapdataResult%v", string(b))
}

/*
Add a manager to the user entry
*/
func (c *Client) UserAddManager(
  reqArgs *UserAddManagerArgs,
  optArgs *UserAddManagerOptionalArgs, // can be nil
) (*UserAddManagerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddManagerKwParams{
    UserAddManagerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add_manager",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddManagerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddManagerArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserAddManagerOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  }

type userAddManagerKwParams struct {
  *UserAddManagerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddManagerResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddManagerResult `json:"result"`
}

type UserAddManagerResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *UserAddManagerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddManagerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddManagerResult%v", string(b))
}

/*
Add new principal alias to the user entry
*/
func (c *Client) UserAddPrincipal(
  reqArgs *UserAddPrincipalArgs,
  optArgs *UserAddPrincipalOptionalArgs, // can be nil
) (*UserAddPrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddPrincipalKwParams{
    UserAddPrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add_principal",
    Params: []interface{}{
      []interface{}{reqArgs.UID, reqArgs.Krbprincipalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddPrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddPrincipalArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type UserAddPrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userAddPrincipalKwParams struct {
  *UserAddPrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddPrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddPrincipalResult `json:"result"`
}

type UserAddPrincipalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserAddPrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddPrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddPrincipalResult%v", string(b))
}

/*
Delete a user.
*/
func (c *Client) UserDel(
  reqArgs *UserDelArgs,
  optArgs *UserDelOptionalArgs, // can be nil
) (*UserDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userDelKwParams{
    UserDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_del",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserDelArgs struct {
  
    /*
User login

    */
    UID []string `json:"uid,omitempty"`
  }

type UserDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*


    */
    Preserve *bool `json:"preserve,omitempty"`
  }

type userDelKwParams struct {
  *UserDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userDelResponse struct {
	Error  *Error      `json:"error"`
	Result *UserDelResult `json:"result"`
}

type UserDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result User `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserDelResult%v", string(b))
}

/*
Disable a user account.
*/
func (c *Client) UserDisable(
  reqArgs *UserDisableArgs,
  optArgs *UserDisableOptionalArgs, // can be nil
) (*UserDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userDisableKwParams{
    UserDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_disable",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserDisableArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserDisableOptionalArgs struct {
  }

type userDisableKwParams struct {
  *UserDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *UserDisableResult `json:"result"`
}

type UserDisableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserDisableResult%v", string(b))
}

/*
Enable a user account.
*/
func (c *Client) UserEnable(
  reqArgs *UserEnableArgs,
  optArgs *UserEnableOptionalArgs, // can be nil
) (*UserEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userEnableKwParams{
    UserEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_enable",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserEnableArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserEnableOptionalArgs struct {
  }

type userEnableKwParams struct {
  *UserEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *UserEnableResult `json:"result"`
}

type UserEnableResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserEnableResult%v", string(b))
}

/*
Search for users.
*/
func (c *Client) UserFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *UserFindArgs,
  optArgs *UserFindOptionalArgs, // can be nil
) (*UserFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userFindKwParams{
    UserFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserFindArgs struct {
  }

type UserFindOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Account disabled

    */
    Nsaccountlock *bool `json:"nsaccountlock,omitempty"`
  
    /*
Preserved user

    */
    Preserved *bool `json:"preserved,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Self
Display user record for current Kerberos principal
    */
    Whoami *bool `json:"whoami,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("login")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
group
Search for users with these member of groups.
    */
    InGroup *[]string `json:"in_group,omitempty"`
  
    /*
group
Search for users without these member of groups.
    */
    NotInGroup *[]string `json:"not_in_group,omitempty"`
  
    /*
netgroup
Search for users with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for users without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
role
Search for users with these member of roles.
    */
    InRole *[]string `json:"in_role,omitempty"`
  
    /*
role
Search for users without these member of roles.
    */
    NotInRole *[]string `json:"not_in_role,omitempty"`
  
    /*
HBAC rule
Search for users with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for users without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for users with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for users without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  }

type userFindKwParams struct {
  *UserFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userFindResponse struct {
	Error  *Error      `json:"error"`
	Result *UserFindResult `json:"result"`
}

type UserFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []User `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *UserFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserFindResult%v", string(b))
}

/*
Modify a user.
*/
func (c *Client) UserMod(
  reqArgs *UserModArgs,
  optArgs *UserModOptionalArgs, // can be nil
) (*UserModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userModKwParams{
    UserModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_mod",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserModArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserModOptionalArgs struct {
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Account disabled

    */
    Nsaccountlock *bool `json:"nsaccountlock,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the user object
    */
    Rename *string `json:"rename,omitempty"`
  }

type userModKwParams struct {
  *UserModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userModResponse struct {
	Error  *Error      `json:"error"`
	Result *UserModResult `json:"result"`
}

type UserModResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result User `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserModResult%v", string(b))
}

/*
Remove one or more certificates to the user entry
*/
func (c *Client) UserRemoveCert(
  reqArgs *UserRemoveCertArgs,
  optArgs *UserRemoveCertOptionalArgs, // can be nil
) (*UserRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userRemoveCertKwParams{
    UserRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_remove_cert",
    Params: []interface{}{
      []interface{}{reqArgs.UID, reqArgs.Usercertificate, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserRemoveCertArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type UserRemoveCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userRemoveCertKwParams struct {
  *UserRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *UserRemoveCertResult `json:"result"`
}

type UserRemoveCertResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserRemoveCertResult%v", string(b))
}

/*
Remove one or more certificate mappings from the user entry.
*/
func (c *Client) UserRemoveCertmapdata(
  ipacertmapdata string, // Certificate mapping data
  reqArgs *UserRemoveCertmapdataArgs,
  optArgs *UserRemoveCertmapdataOptionalArgs, // can be nil
) (*UserRemoveCertmapdataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userRemoveCertmapdataKwParams{
    UserRemoveCertmapdataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_remove_certmapdata",
    Params: []interface{}{
      []interface{}{reqArgs.UID, ipacertmapdata, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userRemoveCertmapdataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserRemoveCertmapdataArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserRemoveCertmapdataOptionalArgs struct {
  
    /*
Issuer
Issuer of the certificate
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Subject
Subject of the certificate
    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate *[]interface{} `json:"certificate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userRemoveCertmapdataKwParams struct {
  *UserRemoveCertmapdataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userRemoveCertmapdataResponse struct {
	Error  *Error      `json:"error"`
	Result *UserRemoveCertmapdataResult `json:"result"`
}

type UserRemoveCertmapdataResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserRemoveCertmapdataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserRemoveCertmapdataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserRemoveCertmapdataResult%v", string(b))
}

/*
Remove a manager to the user entry
*/
func (c *Client) UserRemoveManager(
  reqArgs *UserRemoveManagerArgs,
  optArgs *UserRemoveManagerOptionalArgs, // can be nil
) (*UserRemoveManagerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userRemoveManagerKwParams{
    UserRemoveManagerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_remove_manager",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userRemoveManagerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserRemoveManagerArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserRemoveManagerOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  }

type userRemoveManagerKwParams struct {
  *UserRemoveManagerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userRemoveManagerResponse struct {
	Error  *Error      `json:"error"`
	Result *UserRemoveManagerResult `json:"result"`
}

type UserRemoveManagerResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *UserRemoveManagerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserRemoveManagerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserRemoveManagerResult%v", string(b))
}

/*
Remove principal alias from the user entry
*/
func (c *Client) UserRemovePrincipal(
  reqArgs *UserRemovePrincipalArgs,
  optArgs *UserRemovePrincipalOptionalArgs, // can be nil
) (*UserRemovePrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userRemovePrincipalKwParams{
    UserRemovePrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_remove_principal",
    Params: []interface{}{
      []interface{}{reqArgs.UID, reqArgs.Krbprincipalname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userRemovePrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserRemovePrincipalArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type UserRemovePrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userRemovePrincipalKwParams struct {
  *UserRemovePrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userRemovePrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *UserRemovePrincipalResult `json:"result"`
}

type UserRemovePrincipalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserRemovePrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserRemovePrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserRemovePrincipalResult%v", string(b))
}

/*
Display information about a user.
*/
func (c *Client) UserShow(
  reqArgs *UserShowArgs,
  optArgs *UserShowOptionalArgs, // can be nil
) (*UserShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userShowKwParams{
    UserShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_show",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserShowArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

file to store certificate in
    */
    Out *string `json:"out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userShowKwParams struct {
  *UserShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userShowResponse struct {
	Error  *Error      `json:"error"`
	Result *UserShowResult `json:"result"`
}

type UserShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result User `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserShowResult%v", string(b))
}

/*
Move deleted user into staged area
*/
func (c *Client) UserStage(
  reqArgs *UserStageArgs,
  optArgs *UserStageOptionalArgs, // can be nil
) (*UserStageResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userStageKwParams{
    UserStageOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_stage",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userStageResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserStageArgs struct {
  
    /*
User login

    */
    UID []string `json:"uid,omitempty"`
  }

type UserStageOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type userStageKwParams struct {
  *UserStageOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userStageResponse struct {
	Error  *Error      `json:"error"`
	Result *UserStageResult `json:"result"`
}

type UserStageResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserStageResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserStageResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserStageResult%v", string(b))
}

/*
Lockout status of a user account

    An account may become locked if the password is entered incorrectly too
    many times within a specific time period as controlled by password
    policy. A locked account is a temporary condition and may be unlocked by
    an administrator.

    This connects to each IPA master and displays the lockout status on
    each one.

    To determine whether an account is locked on a given server you need
    to compare the number of failed logins and the time of the last failure.
    For an account to be locked it must exceed the maxfail failures within
    the failinterval duration as specified in the password policy associated
    with the user.

    The failed login counter is modified only when a user attempts a log in
    so it is possible that an account may appear locked but the last failed
    login attempt is older than the lockouttime of the password policy. This
    means that the user may attempt a login again.
*/
func (c *Client) UserStatus(
  reqArgs *UserStatusArgs,
  optArgs *UserStatusOptionalArgs, // can be nil
) (*UserStatusResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userStatusKwParams{
    UserStatusOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_status",
    Params: []interface{}{
      []interface{}{reqArgs.Useruid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userStatusResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserStatusArgs struct {
  
    /*
User login

    */
    Useruid string `json:"useruid,omitempty"`
  }

type UserStatusOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type userStatusKwParams struct {
  *UserStatusOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userStatusResponse struct {
	Error  *Error      `json:"error"`
	Result *UserStatusResult `json:"result"`
}

type UserStatusResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Userstatus `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *UserStatusResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserStatusResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserStatusResult%v", string(b))
}

/*
Undelete a delete user account.
*/
func (c *Client) UserUndel(
  reqArgs *UserUndelArgs,
  optArgs *UserUndelOptionalArgs, // can be nil
) (*UserUndelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userUndelKwParams{
    UserUndelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_undel",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userUndelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserUndelArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserUndelOptionalArgs struct {
  }

type userUndelKwParams struct {
  *UserUndelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userUndelResponse struct {
	Error  *Error      `json:"error"`
	Result *UserUndelResult `json:"result"`
}

type UserUndelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserUndelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserUndelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserUndelResult%v", string(b))
}

/*
Unlock a user account

    An account may become locked if the password is entered incorrectly too
    many times within a specific time period as controlled by password
    policy. A locked account is a temporary condition and may be unlocked by
    an administrator.
*/
func (c *Client) UserUnlock(
  reqArgs *UserUnlockArgs,
  optArgs *UserUnlockOptionalArgs, // can be nil
) (*UserUnlockResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userUnlockKwParams{
    UserUnlockOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_unlock",
    Params: []interface{}{
      []interface{}{reqArgs.UID, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userUnlockResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserUnlockArgs struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  }

type UserUnlockOptionalArgs struct {
  }

type userUnlockKwParams struct {
  *UserUnlockOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userUnlockResponse struct {
	Error  *Error      `json:"error"`
	Result *UserUnlockResult `json:"result"`
}

type UserUnlockResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
True means the operation was successful
    (required)
    */
    Result IPAPrim[bool] `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *UserUnlockResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserUnlockResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserUnlockResult%v", string(b))
}

/*

*/
func (c *Client) VaultAddInternal(
  reqArgs *VaultAddInternalArgs,
  optArgs *VaultAddInternalOptionalArgs, // can be nil
) (*VaultAddInternalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultAddInternalKwParams{
    VaultAddInternalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_add_internal",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultAddInternalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultAddInternalArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultAddInternalOptionalArgs struct {
  
    /*
Description
Vault description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Type
Vault type
    */
    Ipavaulttype *string `json:"ipavaulttype,omitempty"`
  
    /*
Salt
Vault salt
    */
    Ipavaultsalt *string `json:"ipavaultsalt,omitempty"`
  
    /*
Public key
Vault public key
    */
    Ipavaultpublickey *string `json:"ipavaultpublickey,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type vaultAddInternalKwParams struct {
  *VaultAddInternalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultAddInternalResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultAddInternalResult `json:"result"`
}

type VaultAddInternalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *VaultAddInternalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultAddInternalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultAddInternalResult%v", string(b))
}

/*
Add members to a vault.
*/
func (c *Client) VaultAddMember(
  reqArgs *VaultAddMemberArgs,
  optArgs *VaultAddMemberOptionalArgs, // can be nil
) (*VaultAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultAddMemberKwParams{
    VaultAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_add_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultAddMemberArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultAddMemberOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member service
services to add
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultAddMemberKwParams struct {
  *VaultAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultAddMemberResult `json:"result"`
}

type VaultAddMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *VaultAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultAddMemberResult%v", string(b))
}

/*
Add owners to a vault.
*/
func (c *Client) VaultAddOwner(
  reqArgs *VaultAddOwnerArgs,
  optArgs *VaultAddOwnerOptionalArgs, // can be nil
) (*VaultAddOwnerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultAddOwnerKwParams{
    VaultAddOwnerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_add_owner",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultAddOwnerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultAddOwnerArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultAddOwnerOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
owner user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
owner group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
owner service
services to add
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultAddOwnerKwParams struct {
  *VaultAddOwnerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultAddOwnerResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultAddOwnerResult `json:"result"`
}

type VaultAddOwnerResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Owners that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of owners added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *VaultAddOwnerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultAddOwnerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultAddOwnerResult%v", string(b))
}

/*

*/
func (c *Client) VaultArchiveInternal(
  reqArgs *VaultArchiveInternalArgs,
  optArgs *VaultArchiveInternalOptionalArgs, // can be nil
) (*VaultArchiveInternalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultArchiveInternalKwParams{
    VaultArchiveInternalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_archive_internal",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultArchiveInternalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultArchiveInternalArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultArchiveInternalOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Session key wrapped with transport certificate
    */
    SessionKey *string `json:"session_key,omitempty"`
  
    /*

Vault data encrypted with session key
    */
    VaultData *string `json:"vault_data,omitempty"`
  
    /*

Nonce
    */
    Nonce *string `json:"nonce,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type vaultArchiveInternalKwParams struct {
  *VaultArchiveInternalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultArchiveInternalResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultArchiveInternalResult `json:"result"`
}

type VaultArchiveInternalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *VaultArchiveInternalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultArchiveInternalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultArchiveInternalResult%v", string(b))
}

/*
Delete a vault.
*/
func (c *Client) VaultDel(
  reqArgs *VaultDelArgs,
  optArgs *VaultDelOptionalArgs, // can be nil
) (*VaultDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultDelKwParams{
    VaultDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_del",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultDelArgs struct {
  
    /*
Vault name

    */
    Cn []string `json:"cn,omitempty"`
  }

type VaultDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  }

type vaultDelKwParams struct {
  *VaultDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultDelResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultDelResult `json:"result"`
}

type VaultDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Vault `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []IPAPrim[string] `json:"value,omitempty"`
  }

func (t *VaultDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultDelResult%v", string(b))
}

/*
Search for vaults.
*/
func (c *Client) VaultFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *VaultFindArgs,
  optArgs *VaultFindOptionalArgs, // can be nil
) (*VaultFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultFindKwParams{
    VaultFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultFindArgs struct {
  }

type VaultFindOptionalArgs struct {
  
    /*
Vault name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Vault description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Type
Vault type
    */
    Ipavaulttype *string `json:"ipavaulttype,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

List all service vaults
    */
    Services *bool `json:"services,omitempty"`
  
    /*

List all user vaults
    */
    Users *bool `json:"users,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type vaultFindKwParams struct {
  *VaultFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultFindResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultFindResult `json:"result"`
}

type VaultFindResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result []Vault `json:"result,omitempty"`
  
    /*
Number of entries returned
    (required)
    */
    Count IPAPrim[int] `json:"count,omitempty"`
  
    /*
True if not all results were returned
    (required)
    */
    Truncated IPAPrim[bool] `json:"truncated,omitempty"`
  }

func (t *VaultFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultFindResult%v", string(b))
}

/*

*/
func (c *Client) VaultModInternal(
  reqArgs *VaultModInternalArgs,
  optArgs *VaultModInternalOptionalArgs, // can be nil
) (*VaultModInternalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultModInternalKwParams{
    VaultModInternalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_mod_internal",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultModInternalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultModInternalArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultModInternalOptionalArgs struct {
  
    /*
Description
Vault description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Type
Vault type
    */
    Ipavaulttype *string `json:"ipavaulttype,omitempty"`
  
    /*
Salt
Vault salt
    */
    Ipavaultsalt *string `json:"ipavaultsalt,omitempty"`
  
    /*
Public key
Vault public key
    */
    Ipavaultpublickey *string `json:"ipavaultpublickey,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type vaultModInternalKwParams struct {
  *VaultModInternalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultModInternalResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultModInternalResult `json:"result"`
}

type VaultModInternalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *VaultModInternalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultModInternalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultModInternalResult%v", string(b))
}

/*
Remove members from a vault.
*/
func (c *Client) VaultRemoveMember(
  reqArgs *VaultRemoveMemberArgs,
  optArgs *VaultRemoveMemberOptionalArgs, // can be nil
) (*VaultRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultRemoveMemberKwParams{
    VaultRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_remove_member",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultRemoveMemberArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultRemoveMemberOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member service
services to remove
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultRemoveMemberKwParams struct {
  *VaultRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultRemoveMemberResult `json:"result"`
}

type VaultRemoveMemberResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Members that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of members removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *VaultRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultRemoveMemberResult%v", string(b))
}

/*
Remove owners from a vault.
*/
func (c *Client) VaultRemoveOwner(
  reqArgs *VaultRemoveOwnerArgs,
  optArgs *VaultRemoveOwnerOptionalArgs, // can be nil
) (*VaultRemoveOwnerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultRemoveOwnerKwParams{
    VaultRemoveOwnerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_remove_owner",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultRemoveOwnerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultRemoveOwnerArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultRemoveOwnerOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
owner user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
owner group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
owner service
services to remove
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultRemoveOwnerKwParams struct {
  *VaultRemoveOwnerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultRemoveOwnerResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultRemoveOwnerResult `json:"result"`
}

type VaultRemoveOwnerResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Owners that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of owners removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *VaultRemoveOwnerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultRemoveOwnerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultRemoveOwnerResult%v", string(b))
}

/*

*/
func (c *Client) VaultRetrieveInternal(
  reqArgs *VaultRetrieveInternalArgs,
  optArgs *VaultRetrieveInternalOptionalArgs, // can be nil
) (*VaultRetrieveInternalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultRetrieveInternalKwParams{
    VaultRetrieveInternalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_retrieve_internal",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultRetrieveInternalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultRetrieveInternalArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultRetrieveInternalOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Session key wrapped with transport certificate
    */
    SessionKey *string `json:"session_key,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type vaultRetrieveInternalKwParams struct {
  *VaultRetrieveInternalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultRetrieveInternalResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultRetrieveInternalResult `json:"result"`
}

type VaultRetrieveInternalResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *VaultRetrieveInternalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultRetrieveInternalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultRetrieveInternalResult%v", string(b))
}

/*
Display information about a vault.
*/
func (c *Client) VaultShow(
  reqArgs *VaultShowArgs,
  optArgs *VaultShowOptionalArgs, // can be nil
) (*VaultShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultShowKwParams{
    VaultShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_show",
    Params: []interface{}{
      []interface{}{reqArgs.Cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultShowArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type vaultShowKwParams struct {
  *VaultShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultShowResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultShowResult `json:"result"`
}

type VaultShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Vault `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value IPAPrim[string] `json:"value,omitempty"`
  }

func (t *VaultShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultShowResult%v", string(b))
}

/*
Show vault configuration.
*/
func (c *Client) VaultconfigShow(
  reqArgs *VaultconfigShowArgs,
  optArgs *VaultconfigShowOptionalArgs, // can be nil
) (*VaultconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultconfigShowKwParams{
    VaultconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultconfigShowArgs struct {
  }

type VaultconfigShowOptionalArgs struct {
  
    /*

Output file to store the transport certificate
    */
    TransportOut *string `json:"transport_out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type vaultconfigShowKwParams struct {
  *VaultconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultconfigShowResult `json:"result"`
}

type VaultconfigShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Vaultconfig `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *VaultconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultconfigShowResult%v", string(b))
}

/*
Add owners to a vault container.
*/
func (c *Client) VaultcontainerAddOwner(
  reqArgs *VaultcontainerAddOwnerArgs,
  optArgs *VaultcontainerAddOwnerOptionalArgs, // can be nil
) (*VaultcontainerAddOwnerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultcontainerAddOwnerKwParams{
    VaultcontainerAddOwnerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultcontainer_add_owner",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultcontainerAddOwnerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultcontainerAddOwnerArgs struct {
  }

type VaultcontainerAddOwnerOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
owner user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
owner group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
owner service
services to add
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultcontainerAddOwnerKwParams struct {
  *VaultcontainerAddOwnerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultcontainerAddOwnerResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultcontainerAddOwnerResult `json:"result"`
}

type VaultcontainerAddOwnerResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Owners that could not be added
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of owners added
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *VaultcontainerAddOwnerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultcontainerAddOwnerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultcontainerAddOwnerResult%v", string(b))
}

/*
Delete a vault container.
*/
func (c *Client) VaultcontainerDel(
  reqArgs *VaultcontainerDelArgs,
  optArgs *VaultcontainerDelOptionalArgs, // can be nil
) (*VaultcontainerDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultcontainerDelKwParams{
    VaultcontainerDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultcontainer_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultcontainerDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultcontainerDelArgs struct {
  }

type VaultcontainerDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  }

type vaultcontainerDelKwParams struct {
  *VaultcontainerDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultcontainerDelResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultcontainerDelResult `json:"result"`
}

type VaultcontainerDelResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*
List of deletions that failed
    (required)
    */
    Result Vaultcontainer `json:"result,omitempty"`
  
    /*

    (required)
    */
    Value []interface{} `json:"value,omitempty"`
  }

func (t *VaultcontainerDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultcontainerDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultcontainerDelResult%v", string(b))
}

/*
Remove owners from a vault container.
*/
func (c *Client) VaultcontainerRemoveOwner(
  reqArgs *VaultcontainerRemoveOwnerArgs,
  optArgs *VaultcontainerRemoveOwnerOptionalArgs, // can be nil
) (*VaultcontainerRemoveOwnerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultcontainerRemoveOwnerKwParams{
    VaultcontainerRemoveOwnerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultcontainer_remove_owner",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultcontainerRemoveOwnerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultcontainerRemoveOwnerArgs struct {
  }

type VaultcontainerRemoveOwnerOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
owner user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
owner group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
owner service
services to remove
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultcontainerRemoveOwnerKwParams struct {
  *VaultcontainerRemoveOwnerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultcontainerRemoveOwnerResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultcontainerRemoveOwnerResult `json:"result"`
}

type VaultcontainerRemoveOwnerResult struct {
  
  
    /*

    (required)
    */
    Result interface{} `json:"result,omitempty"`
  
    /*
Owners that could not be removed
    (required)
    */
    Failed interface{} `json:"failed,omitempty"`
  
    /*
Number of owners removed
    (required)
    */
    Completed IPAPrim[int] `json:"completed,omitempty"`
  }

func (t *VaultcontainerRemoveOwnerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultcontainerRemoveOwnerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultcontainerRemoveOwnerResult%v", string(b))
}

/*
Display information about a vault container.
*/
func (c *Client) VaultcontainerShow(
  reqArgs *VaultcontainerShowArgs,
  optArgs *VaultcontainerShowOptionalArgs, // can be nil
) (*VaultcontainerShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultcontainerShowKwParams{
    VaultcontainerShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultcontainer_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultcontainerShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultcontainerShowArgs struct {
  }

type VaultcontainerShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type vaultcontainerShowKwParams struct {
  *VaultcontainerShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultcontainerShowResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultcontainerShowResult `json:"result"`
}

type VaultcontainerShowResult struct {
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    Summary *IPAPrim[string] `json:"summary,omitempty"`
  
    /*

    (required)
    */
    Result Vaultcontainer `json:"result,omitempty"`
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    Value interface{} `json:"value,omitempty"`
  }

func (t *VaultcontainerShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultcontainerShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultcontainerShowResult%v", string(b))
}

/*
Describe currently authenticated identity.
*/
func (c *Client) Whoami(
  reqArgs *WhoamiArgs,
  optArgs *WhoamiOptionalArgs, // can be nil
) (*WhoamiResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := whoamiKwParams{
    WhoamiOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "whoami",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res whoamiResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type WhoamiArgs struct {
  }

type WhoamiOptionalArgs struct {
  }

type whoamiKwParams struct {
  *WhoamiOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type whoamiResponse struct {
	Error  *Error      `json:"error"`
	Result *WhoamiResult `json:"result"`
}

type WhoamiResult struct {
  
  
    /*
Object class name
    (required)
    */
    Object IPAPrim[string] `json:"object,omitempty"`
  
    /*
Function to get details
    (required)
    */
    Command IPAPrim[string] `json:"command,omitempty"`
  
    /*
Arguments to details function
    (required)
    */
    Arguments []interface{} `json:"arguments,omitempty"`
  }

func (t *WhoamiResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("WhoamiResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("WhoamiResult%v", string(b))
}



type Aci struct {
  
    /*
ACI name

    */
    Aciname IPAPrim[string] `json:"aciname,omitempty"`
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *IPAPrim[string] `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *IPAPrim[string] `json:"group,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions *[]IPAPrim[string] `json:"permissions,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]IPAPrim[string] `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *IPAPrim[string] `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *IPAPrim[string] `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *IPAPrim[string] `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *IPAPrim[string] `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *IPAPrim[string] `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *IPAPrim[bool] `json:"selfaci,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix *IPAPrim[string] `json:"aciprefix,omitempty"`
  
    /*
ACI

    */
    Aci *IPAPrim[string] `json:"aci,omitempty"`
  }

func (t *Aci) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Aci[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Aci%v", string(b))
}



type Automember struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
A description of this auto member rule
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Default (fallback) Group
Default group for entries to land
    */
    Automemberdefaultgroup *IPAPrim[string] `json:"automemberdefaultgroup,omitempty"`
  
    /*
Inclusive Regex
Inclusive Regex
    */
    Automemberinclusiveregex *[]IPAPrim[string] `json:"automemberinclusiveregex,omitempty"`
  
    /*
Exclusive Regex
Exclusive Regex
    */
    Automemberexclusiveregex *[]IPAPrim[string] `json:"automemberexclusiveregex,omitempty"`
  }

func (t *Automember) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Automember[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Automember%v", string(b))
}



type AutomemberDefaultGroup struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Default (fallback) Group
Default group for entries to land
    */
    Automemberdefaultgroup *IPAPrim[string] `json:"automemberdefaultgroup,omitempty"`
  
    /*
Inclusive Regex
Inclusive Regex
    */
    Automemberinclusiveregex *[]IPAPrim[string] `json:"automemberinclusiveregex,omitempty"`
  
    /*
Exclusive Regex
Exclusive Regex
    */
    Automemberexclusiveregex *[]IPAPrim[string] `json:"automemberexclusiveregex,omitempty"`
  }

func (t *AutomemberDefaultGroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDefaultGroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDefaultGroup%v", string(b))
}



type AutomemberTask struct {
  
    /*
Task DN
DN of the started task
    */
    Dn string `json:"dn,omitempty"`
  }

func (t *AutomemberTask) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberTask[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberTask%v", string(b))
}



type Automountkey struct {
  
    /*
Key
Automount key name.
    */
    Automountkey IPAPrim[string] `json:"automountkey,omitempty"`
  
    /*
Mount information

    */
    Automountinformation IPAPrim[string] `json:"automountinformation,omitempty"`
  
    /*
description

    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  }

func (t *Automountkey) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Automountkey[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Automountkey%v", string(b))
}



type Automountlocation struct {
  
    /*
Location
Automount location name.
    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  }

func (t *Automountlocation) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Automountlocation[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Automountlocation%v", string(b))
}



type Automountmap struct {
  
    /*
Map
Automount map name.
    */
    Automountmapname IPAPrim[string] `json:"automountmapname,omitempty"`
  
    /*
Description

    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  }

func (t *Automountmap) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Automountmap[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Automountmap%v", string(b))
}



type Ca struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
Description of the purpose of the CA
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Authority ID
Dogtag Authority ID
    */
    Ipacaid *IPAPrim[string] `json:"ipacaid,omitempty"`
  
    /*
Subject DN
Subject Distinguished Name
    */
    Ipacasubjectdn *string `json:"ipacasubjectdn,omitempty"`
  
    /*
Issuer DN
Issuer Distinguished Name
    */
    Ipacaissuerdn *string `json:"ipacaissuerdn,omitempty"`
  
    /*
Certificate
Base-64 encoded certificate.
    */
    Certificate *string `json:"certificate,omitempty"`
  
    /*
Certificate chain
X.509 certificate chain
    */
    CertificateChain *[]string `json:"certificate_chain,omitempty"`
  }

func (t *Ca) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Ca[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Ca%v", string(b))
}



type Caacl struct {
  
    /*
ACL name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *IPAPrim[bool] `json:"ipaenabledflag,omitempty"`
  
    /*
CA category
CA category the ACL applies to
    */
    Ipacacategory *IPAPrim[string] `json:"ipacacategory,omitempty"`
  
    /*
Profile category
Profile category the ACL applies to
    */
    Ipacertprofilecategory *IPAPrim[string] `json:"ipacertprofilecategory,omitempty"`
  
    /*
User category
User category the ACL applies to
    */
    Usercategory *IPAPrim[string] `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the ACL applies to
    */
    Hostcategory *IPAPrim[string] `json:"hostcategory,omitempty"`
  
    /*
Service category
Service category the ACL applies to
    */
    Servicecategory *IPAPrim[string] `json:"servicecategory,omitempty"`
  
    /*
CAs

    */
    IpamembercaCa *IPAPrim[string] `json:"ipamemberca_ca,omitempty"`
  
    /*
Profiles

    */
    IpamembercertprofileCertprofile *IPAPrim[string] `json:"ipamembercertprofile_certprofile,omitempty"`
  
    /*
Users

    */
    MemberuserUser *IPAPrim[string] `json:"memberuser_user,omitempty"`
  
    /*
User Groups

    */
    MemberuserGroup *IPAPrim[string] `json:"memberuser_group,omitempty"`
  
    /*
Hosts

    */
    MemberhostHost *IPAPrim[string] `json:"memberhost_host,omitempty"`
  
    /*
Host Groups

    */
    MemberhostHostgroup *IPAPrim[string] `json:"memberhost_hostgroup,omitempty"`
  
    /*
Services

    */
    MemberserviceService *IPAPrim[string] `json:"memberservice_service,omitempty"`
  }

func (t *Caacl) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Caacl[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Caacl%v", string(b))
}



type Cert struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *IPAPrim[string] `json:"cacn,omitempty"`
  
    /*
Certificate
Base-64 encoded certificate.
    */
    Certificate *interface{} `json:"certificate,omitempty"`
  
    /*
Certificate chain
X.509 certificate chain
    */
    CertificateChain *[]string `json:"certificate_chain,omitempty"`
  
    /*
Subject

    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Subject email address

    */
    SanRfc822name *[]IPAPrim[string] `json:"san_rfc822name,omitempty"`
  
    /*
Subject DNS name

    */
    SanDnsname *[]DNSName `json:"san_dnsname,omitempty"`
  
    /*
Subject X.400 address

    */
    SanX400address *[]IPAPrim[string] `json:"san_x400address,omitempty"`
  
    /*
Subject directory name

    */
    SanDirectoryname *[]string `json:"san_directoryname,omitempty"`
  
    /*
Subject EDI Party name

    */
    SanEdipartyname *[]IPAPrim[string] `json:"san_edipartyname,omitempty"`
  
    /*
Subject URI

    */
    SanURI *[]IPAPrim[string] `json:"san_uri,omitempty"`
  
    /*
Subject IP Address

    */
    SanIpaddress *[]IPAPrim[string] `json:"san_ipaddress,omitempty"`
  
    /*
Subject OID

    */
    SanOid *[]IPAPrim[string] `json:"san_oid,omitempty"`
  
    /*
Subject UPN

    */
    SanOtherUpn *[]IPAPrim[string] `json:"san_other_upn,omitempty"`
  
    /*
Subject Kerberos principal name

    */
    SanOtherKpn *[]IPAPrim[string] `json:"san_other_kpn,omitempty"`
  
    /*
Subject Other Name

    */
    SanOther *[]IPAPrim[string] `json:"san_other,omitempty"`
  
    /*
Issuer
Issuer DN
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Not Before

    */
    ValidNotBefore *IPATime `json:"valid_not_before,omitempty"`
  
    /*
Not After

    */
    ValidNotAfter *IPATime `json:"valid_not_after,omitempty"`
  
    /*
Fingerprint (SHA1)

    */
    Sha1Fingerprint *IPAPrim[string] `json:"sha1_fingerprint,omitempty"`
  
    /*
Fingerprint (SHA256)

    */
    Sha256Fingerprint *IPAPrim[string] `json:"sha256_fingerprint,omitempty"`
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber *IPAPrim[int] `json:"serial_number,omitempty"`
  
    /*
Serial number (hex)

    */
    SerialNumberHex *IPAPrim[string] `json:"serial_number_hex,omitempty"`
  
    /*
Status

    */
    Status *IPAPrim[string] `json:"status,omitempty"`
  
    /*
Revoked

    */
    Revoked *IPAPrim[bool] `json:"revoked,omitempty"`
  
    /*
Revocation reason
Reason for revoking the certificate (0-10). Type "ipa help cert" for revocation reason details. 
    */
    RevocationReason *IPAPrim[int] `json:"revocation_reason,omitempty"`
  
    /*
Owner user

    */
    OwnerUser *[]IPAPrim[string] `json:"owner_user,omitempty"`
  
    /*
Owner host

    */
    OwnerHost *[]IPAPrim[string] `json:"owner_host,omitempty"`
  
    /*
Owner service
Service principal alias
    */
    OwnerService *[]IPAPrim[string] `json:"owner_service,omitempty"`
  }

func (t *Cert) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Cert[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Cert%v", string(b))
}



type Certmap struct {
  
    /*
Domain

    */
    Domain DNSName `json:"domain,omitempty"`
  
    /*
User logins

    */
    UID *[]IPAPrim[string] `json:"uid,omitempty"`
  }

func (t *Certmap) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certmap[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certmap%v", string(b))
}



type Certmapconfig struct {
  
    /*
Prompt for the username
Prompt for the username when multiple identities are mapped to a certificate
    */
    Ipacertmappromptusername *IPAPrim[bool] `json:"ipacertmappromptusername,omitempty"`
  }

func (t *Certmapconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certmapconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certmapconfig%v", string(b))
}



type Certmaprule struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
Certificate Identity Mapping Rule description
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Mapping rule
Rule used to map the certificate with a user entry
    */
    Ipacertmapmaprule *IPAPrim[string] `json:"ipacertmapmaprule,omitempty"`
  
    /*
Matching rule
Rule used to check if a certificate can be used for authentication
    */
    Ipacertmapmatchrule *IPAPrim[string] `json:"ipacertmapmatchrule,omitempty"`
  
    /*
Domain name
Domain where the user entry will be searched
    */
    Associateddomain *[]DNSName `json:"associateddomain,omitempty"`
  
    /*
Priority
Priority of the rule (higher number means lower priority
    */
    Ipacertmappriority *IPAPrim[int] `json:"ipacertmappriority,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *IPAPrim[bool] `json:"ipaenabledflag,omitempty"`
  }

func (t *Certmaprule) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certmaprule[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certmaprule%v", string(b))
}



type Certprofile struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Profile configuration

    */
    Config IPAPrim[string] `json:"config,omitempty"`
  
    /*
Profile description
Brief description of this profile
    */
    Description IPAPrim[string] `json:"description,omitempty"`
  
    /*
Store issued certificates
Whether to store certs issued using this profile
    */
    Ipacertprofilestoreissued *IPAPrim[bool] `json:"ipacertprofilestoreissued,omitempty"`
  }

func (t *Certprofile) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certprofile[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certprofile%v", string(b))
}



type Certreq struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *IPAPrim[string] `json:"cacn,omitempty"`
  
    /*
Certificate
Base-64 encoded certificate.
    */
    Certificate *interface{} `json:"certificate,omitempty"`
  
    /*
Certificate chain
X.509 certificate chain
    */
    CertificateChain *[]string `json:"certificate_chain,omitempty"`
  
    /*
Subject

    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Subject email address

    */
    SanRfc822name *[]IPAPrim[string] `json:"san_rfc822name,omitempty"`
  
    /*
Subject DNS name

    */
    SanDnsname *[]DNSName `json:"san_dnsname,omitempty"`
  
    /*
Subject X.400 address

    */
    SanX400address *[]IPAPrim[string] `json:"san_x400address,omitempty"`
  
    /*
Subject directory name

    */
    SanDirectoryname *[]string `json:"san_directoryname,omitempty"`
  
    /*
Subject EDI Party name

    */
    SanEdipartyname *[]IPAPrim[string] `json:"san_edipartyname,omitempty"`
  
    /*
Subject URI

    */
    SanURI *[]IPAPrim[string] `json:"san_uri,omitempty"`
  
    /*
Subject IP Address

    */
    SanIpaddress *[]IPAPrim[string] `json:"san_ipaddress,omitempty"`
  
    /*
Subject OID

    */
    SanOid *[]IPAPrim[string] `json:"san_oid,omitempty"`
  
    /*
Subject UPN

    */
    SanOtherUpn *[]IPAPrim[string] `json:"san_other_upn,omitempty"`
  
    /*
Subject Kerberos principal name

    */
    SanOtherKpn *[]IPAPrim[string] `json:"san_other_kpn,omitempty"`
  
    /*
Subject Other Name

    */
    SanOther *[]IPAPrim[string] `json:"san_other,omitempty"`
  
    /*
Issuer
Issuer DN
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Not Before

    */
    ValidNotBefore *IPATime `json:"valid_not_before,omitempty"`
  
    /*
Not After

    */
    ValidNotAfter *IPATime `json:"valid_not_after,omitempty"`
  
    /*
Fingerprint (SHA1)

    */
    Sha1Fingerprint *IPAPrim[string] `json:"sha1_fingerprint,omitempty"`
  
    /*
Fingerprint (SHA256)

    */
    Sha256Fingerprint *IPAPrim[string] `json:"sha256_fingerprint,omitempty"`
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber *IPAPrim[int] `json:"serial_number,omitempty"`
  
    /*
Serial number (hex)

    */
    SerialNumberHex *IPAPrim[string] `json:"serial_number_hex,omitempty"`
  
    /*


    */
    RequestType *IPAPrim[string] `json:"request_type,omitempty"`
  
    /*
Profile ID
Certificate Profile to use
    */
    ProfileID *IPAPrim[string] `json:"profile_id,omitempty"`
  
    /*
Request status

    */
    CertRequestStatus *IPAPrim[string] `json:"cert_request_status,omitempty"`
  
    /*
Request id

    */
    RequestID *IPAPrim[int] `json:"request_id,omitempty"`
  }

func (t *Certreq) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certreq[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certreq%v", string(b))
}



type Class struct {
  
    /*
Name

    */
    Name IPAPrim[string] `json:"name,omitempty"`
  
    /*
Version

    */
    Version IPAPrim[string] `json:"version,omitempty"`
  
    /*
Full name

    */
    FullName IPAPrim[string] `json:"full_name,omitempty"`
  
    /*
Documentation

    */
    Doc *IPAPrim[string] `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]IPAPrim[string] `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]IPAPrim[string] `json:"include,omitempty"`
  
    /*
Help topic

    */
    TopicTopic *IPAPrim[string] `json:"topic_topic,omitempty"`
  
    /*
Parameters

    */
    ParamsParam *[]IPAPrim[string] `json:"params_param,omitempty"`
  }

func (t *Class) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Class[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Class%v", string(b))
}



type Command struct {
  
    /*
Name

    */
    Name IPAPrim[string] `json:"name,omitempty"`
  
    /*
Version

    */
    Version IPAPrim[string] `json:"version,omitempty"`
  
    /*
Full name

    */
    FullName IPAPrim[string] `json:"full_name,omitempty"`
  
    /*
Documentation

    */
    Doc *IPAPrim[string] `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]IPAPrim[string] `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]IPAPrim[string] `json:"include,omitempty"`
  
    /*
Help topic

    */
    TopicTopic *IPAPrim[string] `json:"topic_topic,omitempty"`
  
    /*
Parameters

    */
    ParamsParam *[]IPAPrim[string] `json:"params_param,omitempty"`
  
    /*
Method of

    */
    ObjClass *IPAPrim[string] `json:"obj_class,omitempty"`
  
    /*
Method name

    */
    AttrName *IPAPrim[string] `json:"attr_name,omitempty"`
  }

func (t *Command) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Command[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Command%v", string(b))
}



type Config struct {
  
    /*
Maximum username length

    */
    Ipamaxusernamelength IPAPrim[int] `json:"ipamaxusernamelength,omitempty"`
  
    /*
Home directory base
Default location of home directories
    */
    Ipahomesrootdir IPAPrim[string] `json:"ipahomesrootdir,omitempty"`
  
    /*
Default shell
Default shell for new users
    */
    Ipadefaultloginshell IPAPrim[string] `json:"ipadefaultloginshell,omitempty"`
  
    /*
Default users group
Default group for new users
    */
    Ipadefaultprimarygroup IPAPrim[string] `json:"ipadefaultprimarygroup,omitempty"`
  
    /*
Default e-mail domain
Default e-mail domain
    */
    Ipadefaultemaildomain *IPAPrim[string] `json:"ipadefaultemaildomain,omitempty"`
  
    /*
Search time limit
Maximum amount of time (seconds) for a search (-1 or 0 is unlimited)
    */
    Ipasearchtimelimit *IPAPrim[int] `json:"ipasearchtimelimit,omitempty"`
  
    /*
Search size limit
Maximum number of records to search (-1 or 0 is unlimited)
    */
    Ipasearchrecordslimit *IPAPrim[int] `json:"ipasearchrecordslimit,omitempty"`
  
    /*
User search fields
A comma-separated list of fields to search in when searching for users
    */
    Ipausersearchfields *IPAPrim[string] `json:"ipausersearchfields,omitempty"`
  
    /*
Group search fields
A comma-separated list of fields to search in when searching for groups
    */
    Ipagroupsearchfields *IPAPrim[string] `json:"ipagroupsearchfields,omitempty"`
  
    /*
Enable migration mode
Enable migration mode
    */
    Ipamigrationenabled *IPAPrim[bool] `json:"ipamigrationenabled,omitempty"`
  
    /*
Certificate Subject base
Base for certificate subjects (OU=Test,O=Example)
    */
    Ipacertificatesubjectbase *string `json:"ipacertificatesubjectbase,omitempty"`
  
    /*
Default group objectclasses
Default group objectclasses (comma-separated list)
    */
    Ipagroupobjectclasses *[]IPAPrim[string] `json:"ipagroupobjectclasses,omitempty"`
  
    /*
Default user objectclasses
Default user objectclasses (comma-separated list)
    */
    Ipauserobjectclasses *[]IPAPrim[string] `json:"ipauserobjectclasses,omitempty"`
  
    /*
Password Expiration Notification (days)
Number of days's notice of impending password expiration
    */
    Ipapwdexpadvnotify *IPAPrim[int] `json:"ipapwdexpadvnotify,omitempty"`
  
    /*
Password plugin features
Extra hashes to generate in password plug-in
    */
    Ipaconfigstring *[]IPAPrim[string] `json:"ipaconfigstring,omitempty"`
  
    /*
SELinux user map order
Order in increasing priority of SELinux users, delimited by $
    */
    Ipaselinuxusermaporder *IPAPrim[string] `json:"ipaselinuxusermaporder,omitempty"`
  
    /*
Default SELinux user
Default SELinux user when no match is found in SELinux map rule
    */
    Ipaselinuxusermapdefault *IPAPrim[string] `json:"ipaselinuxusermapdefault,omitempty"`
  
    /*
Default PAC types
Default types of PAC supported for services
    */
    Ipakrbauthzdata *[]IPAPrim[string] `json:"ipakrbauthzdata,omitempty"`
  
    /*
Default user authentication types
Default types of supported user authentication
    */
    Ipauserauthtype *[]IPAPrim[string] `json:"ipauserauthtype,omitempty"`
  
    /*
IPA masters
List of all IPA masters
    */
    IpaMasterServer *[]IPAPrim[string] `json:"ipa_master_server,omitempty"`
  
    /*
Hidden IPA masters
List of all hidden IPA masters
    */
    IpaMasterHiddenServer *[]IPAPrim[string] `json:"ipa_master_hidden_server,omitempty"`
  
    /*
IPA master capable of PKINIT
IPA master which can process PKINIT requests
    */
    PkinitServerServer *[]IPAPrim[string] `json:"pkinit_server_server,omitempty"`
  
    /*
IPA CA servers
IPA servers configured as certificate authority
    */
    CaServerServer *[]IPAPrim[string] `json:"ca_server_server,omitempty"`
  
    /*
IPA NTP servers
IPA servers with enabled NTP
    */
    NtpServerServer *[]IPAPrim[string] `json:"ntp_server_server,omitempty"`
  
    /*
Hidden IPA CA servers
Hidden IPA servers configured as certificate authority
    */
    CaServerHiddenServer *[]IPAPrim[string] `json:"ca_server_hidden_server,omitempty"`
  
    /*
IPA CA renewal master
Renewal master for IPA certificate authority
    */
    CaRenewalMasterServer *IPAPrim[string] `json:"ca_renewal_master_server,omitempty"`
  
    /*
IPA KRA servers
IPA servers configured as key recovery agent
    */
    KraServerServer *[]IPAPrim[string] `json:"kra_server_server,omitempty"`
  
    /*
Hidden IPA KRA servers
Hidden IPA servers configured as key recovery agent
    */
    KraServerHiddenServer *[]IPAPrim[string] `json:"kra_server_hidden_server,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *IPAPrim[string] `json:"ipadomainresolutionorder,omitempty"`
  
    /*
IPA DNS servers
IPA servers configured as domain name server
    */
    DNSServerServer *[]IPAPrim[string] `json:"dns_server_server,omitempty"`
  
    /*
Hidden IPA DNS servers
Hidden IPA servers configured as domain name server
    */
    DNSServerHiddenServer *[]IPAPrim[string] `json:"dns_server_hidden_server,omitempty"`
  
    /*
IPA DNSSec key master
DNSec key master
    */
    DnssecKeyMasterServer *IPAPrim[string] `json:"dnssec_key_master_server,omitempty"`
  }

func (t *Config) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Config[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Config%v", string(b))
}



type Cosentry struct {
  
    /*


    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*


    */
    Krbpwdpolicyreference string `json:"krbpwdpolicyreference,omitempty"`
  
    /*


    */
    Cospriority IPAPrim[int] `json:"cospriority,omitempty"`
  }

func (t *Cosentry) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Cosentry[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Cosentry%v", string(b))
}



type Delegation struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname IPAPrim[string] `json:"aciname,omitempty"`
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]IPAPrim[string] `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the delegation applies
    */
    Attrs *[]IPAPrim[string] `json:"attrs,omitempty"`
  
    /*
Member user group
User group to apply delegation to
    */
    Memberof *IPAPrim[string] `json:"memberof,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *IPAPrim[string] `json:"group,omitempty"`
  
    /*
ACI

    */
    Aci *IPAPrim[string] `json:"aci,omitempty"`
  }

func (t *Delegation) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Delegation[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Delegation%v", string(b))
}



type DNSSystemRecords struct {
  
    /*
IPA DNS records

    */
    IpaRecords *[]IPAPrim[string] `json:"ipa_records,omitempty"`
  
    /*
IPA location records

    */
    LocationRecords *[]IPAPrim[string] `json:"location_records,omitempty"`
  }

func (t *DNSSystemRecords) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DNSSystemRecords[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DNSSystemRecords%v", string(b))
}



type Dnsa6record struct {
  
    /*
Record data

    */
    Data IPAPrim[string] `json:"data,omitempty"`
  }

func (t *Dnsa6record) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsa6record[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsa6record%v", string(b))
}



type Dnsaaaarecord struct {
  
    /*
IP Address

    */
    IPAddress IPAPrim[string] `json:"ip_address,omitempty"`
  }

func (t *Dnsaaaarecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsaaaarecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsaaaarecord%v", string(b))
}



type Dnsafsdbrecord struct {
  
    /*
Subtype

    */
    Subtype *IPAPrim[int] `json:"subtype,omitempty"`
  
    /*
Hostname

    */
    Hostname *DNSName `json:"hostname,omitempty"`
  }

func (t *Dnsafsdbrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsafsdbrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsafsdbrecord%v", string(b))
}



type Dnsaplrecord struct {
  }

func (t *Dnsaplrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsaplrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsaplrecord%v", string(b))
}



type Dnsarecord struct {
  
    /*
IP Address

    */
    IPAddress IPAPrim[string] `json:"ip_address,omitempty"`
  }

func (t *Dnsarecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsarecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsarecord%v", string(b))
}



type Dnscertrecord struct {
  
    /*
Certificate Type

    */
    Type IPAPrim[int] `json:"type,omitempty"`
  
    /*
Key Tag

    */
    KeyTag IPAPrim[int] `json:"key_tag,omitempty"`
  
    /*
Algorithm

    */
    Algorithm IPAPrim[int] `json:"algorithm,omitempty"`
  
    /*
Certificate/CRL

    */
    CertificateOrCrl IPAPrim[string] `json:"certificate_or_crl,omitempty"`
  }

func (t *Dnscertrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnscertrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnscertrecord%v", string(b))
}



type Dnscnamerecord struct {
  
    /*
Hostname
A hostname which this alias hostname points to
    */
    Hostname DNSName `json:"hostname,omitempty"`
  }

func (t *Dnscnamerecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnscnamerecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnscnamerecord%v", string(b))
}



type Dnsconfig struct {
  
    /*
Global forwarders
Global forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]IPAPrim[string] `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Global forwarding policy. Set to "none" to disable any configured global forwarders.
    */
    Idnsforwardpolicy *IPAPrim[string] `json:"idnsforwardpolicy,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records
    */
    Idnsallowsyncptr *IPAPrim[bool] `json:"idnsallowsyncptr,omitempty"`
  
    /*
Zone refresh interval
An interval between regular polls of the name server for new DNS zones
    */
    Idnszonerefresh *IPAPrim[int] `json:"idnszonerefresh,omitempty"`
  
    /*
IPA DNS version

    */
    Ipadnsversion *IPAPrim[int] `json:"ipadnsversion,omitempty"`
  
    /*
IPA DNS servers
List of IPA masters configured as DNS servers
    */
    DNSServerServer *[]IPAPrim[string] `json:"dns_server_server,omitempty"`
  
    /*
IPA DNSSec key master
IPA server configured as DNSSec key master
    */
    DnssecKeyMasterServer *IPAPrim[string] `json:"dnssec_key_master_server,omitempty"`
  }

func (t *Dnsconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsconfig%v", string(b))
}



type Dnsdhcidrecord struct {
  }

func (t *Dnsdhcidrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsdhcidrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsdhcidrecord%v", string(b))
}



type Dnsdlvrecord struct {
  
    /*
Key Tag

    */
    KeyTag IPAPrim[int] `json:"key_tag,omitempty"`
  
    /*
Algorithm

    */
    Algorithm IPAPrim[int] `json:"algorithm,omitempty"`
  
    /*
Digest Type

    */
    DigestType IPAPrim[int] `json:"digest_type,omitempty"`
  
    /*
Digest

    */
    Digest IPAPrim[string] `json:"digest,omitempty"`
  }

func (t *Dnsdlvrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsdlvrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsdlvrecord%v", string(b))
}



type Dnsdnamerecord struct {
  
    /*
Target

    */
    Target DNSName `json:"target,omitempty"`
  }

func (t *Dnsdnamerecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsdnamerecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsdnamerecord%v", string(b))
}



type Dnsdsrecord struct {
  
    /*
Key Tag

    */
    KeyTag IPAPrim[int] `json:"key_tag,omitempty"`
  
    /*
Algorithm

    */
    Algorithm IPAPrim[int] `json:"algorithm,omitempty"`
  
    /*
Digest Type

    */
    DigestType IPAPrim[int] `json:"digest_type,omitempty"`
  
    /*
Digest

    */
    Digest IPAPrim[string] `json:"digest,omitempty"`
  }

func (t *Dnsdsrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsdsrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsdsrecord%v", string(b))
}



type Dnsforwardzone struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname DNSName `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *IPAPrim[string] `json:"name_from_ip,omitempty"`
  
    /*
Active zone
Is zone active?
    */
    Idnszoneactive *IPAPrim[bool] `json:"idnszoneactive,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]IPAPrim[string] `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *IPAPrim[string] `json:"idnsforwardpolicy,omitempty"`
  
    /*
Managedby permission

    */
    Managedby *IPAPrim[string] `json:"managedby,omitempty"`
  }

func (t *Dnsforwardzone) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsforwardzone[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsforwardzone%v", string(b))
}



type Dnshiprecord struct {
  }

func (t *Dnshiprecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnshiprecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnshiprecord%v", string(b))
}



type Dnsipseckeyrecord struct {
  }

func (t *Dnsipseckeyrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsipseckeyrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsipseckeyrecord%v", string(b))
}



type Dnskeyrecord struct {
  }

func (t *Dnskeyrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnskeyrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnskeyrecord%v", string(b))
}



type Dnskxrecord struct {
  
    /*
Preference
Preference given to this exchanger. Lower values are more preferred
    */
    Preference IPAPrim[int] `json:"preference,omitempty"`
  
    /*
Exchanger
A host willing to act as a key exchanger
    */
    Exchanger DNSName `json:"exchanger,omitempty"`
  }

func (t *Dnskxrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnskxrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnskxrecord%v", string(b))
}



type Dnslocrecord struct {
  
    /*
Degrees Latitude

    */
    LatDeg IPAPrim[int] `json:"lat_deg,omitempty"`
  
    /*
Minutes Latitude

    */
    LatMin *IPAPrim[int] `json:"lat_min,omitempty"`
  
    /*
Seconds Latitude

    */
    LatSec *float64 `json:"lat_sec,omitempty"`
  
    /*
Direction Latitude

    */
    LatDir *IPAPrim[string] `json:"lat_dir,omitempty"`
  
    /*
Degrees Longitude

    */
    LonDeg *IPAPrim[int] `json:"lon_deg,omitempty"`
  
    /*
Minutes Longitude

    */
    LonMin *IPAPrim[int] `json:"lon_min,omitempty"`
  
    /*
Seconds Longitude

    */
    LonSec *float64 `json:"lon_sec,omitempty"`
  
    /*
Direction Longitude

    */
    LonDir *IPAPrim[string] `json:"lon_dir,omitempty"`
  
    /*
Altitude

    */
    Altitude *float64 `json:"altitude,omitempty"`
  
    /*
Size

    */
    Size *float64 `json:"size,omitempty"`
  
    /*
Horizontal Precision

    */
    HPrecision *float64 `json:"h_precision,omitempty"`
  
    /*
Vertical Precision

    */
    VPrecision *float64 `json:"v_precision,omitempty"`
  }

func (t *Dnslocrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnslocrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnslocrecord%v", string(b))
}



type Dnsmxrecord struct {
  
    /*
Preference
Preference given to this exchanger. Lower values are more preferred
    */
    Preference IPAPrim[int] `json:"preference,omitempty"`
  
    /*
Exchanger
A host willing to act as a mail exchanger
    */
    Exchanger DNSName `json:"exchanger,omitempty"`
  }

func (t *Dnsmxrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsmxrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsmxrecord%v", string(b))
}



type Dnsnaptrrecord struct {
  
    /*
Order

    */
    Order IPAPrim[int] `json:"order,omitempty"`
  
    /*
Preference

    */
    Preference IPAPrim[int] `json:"preference,omitempty"`
  
    /*
Flags

    */
    Flags IPAPrim[string] `json:"flags,omitempty"`
  
    /*
Service

    */
    Service IPAPrim[string] `json:"service,omitempty"`
  
    /*
Regular Expression

    */
    Regexp IPAPrim[string] `json:"regexp,omitempty"`
  
    /*
Replacement

    */
    Replacement IPAPrim[string] `json:"replacement,omitempty"`
  }

func (t *Dnsnaptrrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsnaptrrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsnaptrrecord%v", string(b))
}



type Dnsnsecrecord struct {
  }

func (t *Dnsnsecrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsnsecrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsnsecrecord%v", string(b))
}



type Dnsnsrecord struct {
  
    /*
Hostname

    */
    Hostname DNSName `json:"hostname,omitempty"`
  }

func (t *Dnsnsrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsnsrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsnsrecord%v", string(b))
}



type Dnsptrrecord struct {
  
    /*
Hostname
The hostname this reverse record points to
    */
    Hostname DNSName `json:"hostname,omitempty"`
  }

func (t *Dnsptrrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsptrrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsptrrecord%v", string(b))
}



type Dnsrecord struct {
  
    /*
Record name
Record name
    */
    Idnsname DNSName `json:"idnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *IPAPrim[int] `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *IPAPrim[string] `json:"dnsclass,omitempty"`
  
    /*
Records

    */
    Dnsrecords *interface{} `json:"dnsrecords,omitempty"`
  
    /*
Record type

    */
    Dnstype *IPAPrim[string] `json:"dnstype,omitempty"`
  
    /*
Record data

    */
    Dnsdata *IPAPrim[string] `json:"dnsdata,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]IPAPrim[string] `json:"arecord,omitempty"`
  
    /*
A IP Address

    */
    APartIPAddress *IPAPrim[string] `json:"a_part_ip_address,omitempty"`
  
    /*
A Create reverse
Create reverse record for this IP Address
    */
    AExtraCreateReverse *IPAPrim[bool] `json:"a_extra_create_reverse,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]IPAPrim[string] `json:"aaaarecord,omitempty"`
  
    /*
AAAA IP Address

    */
    AaaaPartIPAddress *IPAPrim[string] `json:"aaaa_part_ip_address,omitempty"`
  
    /*
AAAA Create reverse
Create reverse record for this IP Address
    */
    AaaaExtraCreateReverse *IPAPrim[bool] `json:"aaaa_extra_create_reverse,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]IPAPrim[string] `json:"a6record,omitempty"`
  
    /*
A6 Record data

    */
    A6PartData *IPAPrim[string] `json:"a6_part_data,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]IPAPrim[string] `json:"afsdbrecord,omitempty"`
  
    /*
AFSDB Subtype

    */
    AfsdbPartSubtype *IPAPrim[int] `json:"afsdb_part_subtype,omitempty"`
  
    /*
AFSDB Hostname

    */
    AfsdbPartHostname *DNSName `json:"afsdb_part_hostname,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]IPAPrim[string] `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]IPAPrim[string] `json:"certrecord,omitempty"`
  
    /*
CERT Certificate Type

    */
    CertPartType *IPAPrim[int] `json:"cert_part_type,omitempty"`
  
    /*
CERT Key Tag

    */
    CertPartKeyTag *IPAPrim[int] `json:"cert_part_key_tag,omitempty"`
  
    /*
CERT Algorithm

    */
    CertPartAlgorithm *IPAPrim[int] `json:"cert_part_algorithm,omitempty"`
  
    /*
CERT Certificate/CRL

    */
    CertPartCertificateOrCrl *IPAPrim[string] `json:"cert_part_certificate_or_crl,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]IPAPrim[string] `json:"cnamerecord,omitempty"`
  
    /*
CNAME Hostname
A hostname which this alias hostname points to
    */
    CnamePartHostname *DNSName `json:"cname_part_hostname,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]IPAPrim[string] `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]IPAPrim[string] `json:"dlvrecord,omitempty"`
  
    /*
DLV Key Tag

    */
    DlvPartKeyTag *IPAPrim[int] `json:"dlv_part_key_tag,omitempty"`
  
    /*
DLV Algorithm

    */
    DlvPartAlgorithm *IPAPrim[int] `json:"dlv_part_algorithm,omitempty"`
  
    /*
DLV Digest Type

    */
    DlvPartDigestType *IPAPrim[int] `json:"dlv_part_digest_type,omitempty"`
  
    /*
DLV Digest

    */
    DlvPartDigest *IPAPrim[string] `json:"dlv_part_digest,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]IPAPrim[string] `json:"dnamerecord,omitempty"`
  
    /*
DNAME Target

    */
    DnamePartTarget *DNSName `json:"dname_part_target,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]IPAPrim[string] `json:"dsrecord,omitempty"`
  
    /*
DS Key Tag

    */
    DsPartKeyTag *IPAPrim[int] `json:"ds_part_key_tag,omitempty"`
  
    /*
DS Algorithm

    */
    DsPartAlgorithm *IPAPrim[int] `json:"ds_part_algorithm,omitempty"`
  
    /*
DS Digest Type

    */
    DsPartDigestType *IPAPrim[int] `json:"ds_part_digest_type,omitempty"`
  
    /*
DS Digest

    */
    DsPartDigest *IPAPrim[string] `json:"ds_part_digest,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]IPAPrim[string] `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]IPAPrim[string] `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]IPAPrim[string] `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]IPAPrim[string] `json:"kxrecord,omitempty"`
  
    /*
KX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    KxPartPreference *IPAPrim[int] `json:"kx_part_preference,omitempty"`
  
    /*
KX Exchanger
A host willing to act as a key exchanger
    */
    KxPartExchanger *DNSName `json:"kx_part_exchanger,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]IPAPrim[string] `json:"locrecord,omitempty"`
  
    /*
LOC Degrees Latitude

    */
    LocPartLatDeg *IPAPrim[int] `json:"loc_part_lat_deg,omitempty"`
  
    /*
LOC Minutes Latitude

    */
    LocPartLatMin *IPAPrim[int] `json:"loc_part_lat_min,omitempty"`
  
    /*
LOC Seconds Latitude

    */
    LocPartLatSec *float64 `json:"loc_part_lat_sec,omitempty"`
  
    /*
LOC Direction Latitude

    */
    LocPartLatDir *IPAPrim[string] `json:"loc_part_lat_dir,omitempty"`
  
    /*
LOC Degrees Longitude

    */
    LocPartLonDeg *IPAPrim[int] `json:"loc_part_lon_deg,omitempty"`
  
    /*
LOC Minutes Longitude

    */
    LocPartLonMin *IPAPrim[int] `json:"loc_part_lon_min,omitempty"`
  
    /*
LOC Seconds Longitude

    */
    LocPartLonSec *float64 `json:"loc_part_lon_sec,omitempty"`
  
    /*
LOC Direction Longitude

    */
    LocPartLonDir *IPAPrim[string] `json:"loc_part_lon_dir,omitempty"`
  
    /*
LOC Altitude

    */
    LocPartAltitude *float64 `json:"loc_part_altitude,omitempty"`
  
    /*
LOC Size

    */
    LocPartSize *float64 `json:"loc_part_size,omitempty"`
  
    /*
LOC Horizontal Precision

    */
    LocPartHPrecision *float64 `json:"loc_part_h_precision,omitempty"`
  
    /*
LOC Vertical Precision

    */
    LocPartVPrecision *float64 `json:"loc_part_v_precision,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]IPAPrim[string] `json:"mxrecord,omitempty"`
  
    /*
MX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    MxPartPreference *IPAPrim[int] `json:"mx_part_preference,omitempty"`
  
    /*
MX Exchanger
A host willing to act as a mail exchanger
    */
    MxPartExchanger *DNSName `json:"mx_part_exchanger,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]IPAPrim[string] `json:"naptrrecord,omitempty"`
  
    /*
NAPTR Order

    */
    NaptrPartOrder *IPAPrim[int] `json:"naptr_part_order,omitempty"`
  
    /*
NAPTR Preference

    */
    NaptrPartPreference *IPAPrim[int] `json:"naptr_part_preference,omitempty"`
  
    /*
NAPTR Flags

    */
    NaptrPartFlags *IPAPrim[string] `json:"naptr_part_flags,omitempty"`
  
    /*
NAPTR Service

    */
    NaptrPartService *IPAPrim[string] `json:"naptr_part_service,omitempty"`
  
    /*
NAPTR Regular Expression

    */
    NaptrPartRegexp *IPAPrim[string] `json:"naptr_part_regexp,omitempty"`
  
    /*
NAPTR Replacement

    */
    NaptrPartReplacement *IPAPrim[string] `json:"naptr_part_replacement,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]IPAPrim[string] `json:"nsrecord,omitempty"`
  
    /*
NS Hostname

    */
    NsPartHostname *DNSName `json:"ns_part_hostname,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]IPAPrim[string] `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]IPAPrim[string] `json:"ptrrecord,omitempty"`
  
    /*
PTR Hostname
The hostname this reverse record points to
    */
    PtrPartHostname *DNSName `json:"ptr_part_hostname,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]IPAPrim[string] `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]IPAPrim[string] `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]IPAPrim[string] `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]IPAPrim[string] `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]IPAPrim[string] `json:"srvrecord,omitempty"`
  
    /*
SRV Priority (order)
Lower number means higher priority. Clients will attempt to contact the server with the lowest-numbered priority they can reach.
    */
    SrvPartPriority *IPAPrim[int] `json:"srv_part_priority,omitempty"`
  
    /*
SRV Weight
Relative weight for entries with the same priority.
    */
    SrvPartWeight *IPAPrim[int] `json:"srv_part_weight,omitempty"`
  
    /*
SRV Port

    */
    SrvPartPort *IPAPrim[int] `json:"srv_part_port,omitempty"`
  
    /*
SRV Target
The domain name of the target host or '.' if the service is decidedly not available at this domain
    */
    SrvPartTarget *DNSName `json:"srv_part_target,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]IPAPrim[string] `json:"sshfprecord,omitempty"`
  
    /*
SSHFP Algorithm

    */
    SshfpPartAlgorithm *IPAPrim[int] `json:"sshfp_part_algorithm,omitempty"`
  
    /*
SSHFP Fingerprint Type

    */
    SshfpPartFpType *IPAPrim[int] `json:"sshfp_part_fp_type,omitempty"`
  
    /*
SSHFP Fingerprint

    */
    SshfpPartFingerprint *IPAPrim[string] `json:"sshfp_part_fingerprint,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]IPAPrim[string] `json:"tlsarecord,omitempty"`
  
    /*
TLSA Certificate Usage

    */
    TlsaPartCertUsage *IPAPrim[int] `json:"tlsa_part_cert_usage,omitempty"`
  
    /*
TLSA Selector

    */
    TlsaPartSelector *IPAPrim[int] `json:"tlsa_part_selector,omitempty"`
  
    /*
TLSA Matching Type

    */
    TlsaPartMatchingType *IPAPrim[int] `json:"tlsa_part_matching_type,omitempty"`
  
    /*
TLSA Certificate Association Data

    */
    TlsaPartCertAssociationData *IPAPrim[string] `json:"tlsa_part_cert_association_data,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]IPAPrim[string] `json:"txtrecord,omitempty"`
  
    /*
TXT Text Data

    */
    TxtPartData *IPAPrim[string] `json:"txt_part_data,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]IPAPrim[string] `json:"urirecord,omitempty"`
  
    /*
URI Priority (order)
Lower number means higher priority. Clients will attempt to contact the URI with the lowest-numbered priority they can reach.
    */
    URIPartPriority *IPAPrim[int] `json:"uri_part_priority,omitempty"`
  
    /*
URI Weight
Relative weight for entries with the same priority.
    */
    URIPartWeight *IPAPrim[int] `json:"uri_part_weight,omitempty"`
  
    /*
URI Target Uniform Resource Identifier
Target Uniform Resource Identifier according to RFC 3986
    */
    URIPartTarget *IPAPrim[string] `json:"uri_part_target,omitempty"`
  }

func (t *Dnsrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsrecord%v", string(b))
}



type Dnsrprecord struct {
  }

func (t *Dnsrprecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsrprecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsrprecord%v", string(b))
}



type Dnsrrsigrecord struct {
  }

func (t *Dnsrrsigrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsrrsigrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsrrsigrecord%v", string(b))
}



type Dnsserver struct {
  
    /*
Server name
DNS Server name
    */
    Idnsserverid IPAPrim[string] `json:"idnsserverid,omitempty"`
  
    /*
SOA mname override
SOA mname (authoritative server) override
    */
    Idnssoamname *DNSName `json:"idnssoamname,omitempty"`
  
    /*
Forwarders
Per-server forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]IPAPrim[string] `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-server conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *IPAPrim[string] `json:"idnsforwardpolicy,omitempty"`
  }

func (t *Dnsserver) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsserver[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsserver%v", string(b))
}



type Dnssigrecord struct {
  }

func (t *Dnssigrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnssigrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnssigrecord%v", string(b))
}



type Dnsspfrecord struct {
  }

func (t *Dnsspfrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsspfrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsspfrecord%v", string(b))
}



type Dnssrvrecord struct {
  
    /*
Priority (order)
Lower number means higher priority. Clients will attempt to contact the server with the lowest-numbered priority they can reach.
    */
    Priority IPAPrim[int] `json:"priority,omitempty"`
  
    /*
Weight
Relative weight for entries with the same priority.
    */
    Weight IPAPrim[int] `json:"weight,omitempty"`
  
    /*
Port

    */
    Port IPAPrim[int] `json:"port,omitempty"`
  
    /*
Target
The domain name of the target host or '.' if the service is decidedly not available at this domain
    */
    Target DNSName `json:"target,omitempty"`
  }

func (t *Dnssrvrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnssrvrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnssrvrecord%v", string(b))
}



type Dnssshfprecord struct {
  
    /*
Algorithm

    */
    Algorithm IPAPrim[int] `json:"algorithm,omitempty"`
  
    /*
Fingerprint Type

    */
    FpType IPAPrim[int] `json:"fp_type,omitempty"`
  
    /*
Fingerprint

    */
    Fingerprint IPAPrim[string] `json:"fingerprint,omitempty"`
  }

func (t *Dnssshfprecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnssshfprecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnssshfprecord%v", string(b))
}



type Dnstlsarecord struct {
  
    /*
Certificate Usage

    */
    CertUsage IPAPrim[int] `json:"cert_usage,omitempty"`
  
    /*
Selector

    */
    Selector IPAPrim[int] `json:"selector,omitempty"`
  
    /*
Matching Type

    */
    MatchingType IPAPrim[int] `json:"matching_type,omitempty"`
  
    /*
Certificate Association Data

    */
    CertAssociationData IPAPrim[string] `json:"cert_association_data,omitempty"`
  }

func (t *Dnstlsarecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnstlsarecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnstlsarecord%v", string(b))
}



type Dnstxtrecord struct {
  
    /*
Text Data

    */
    Data IPAPrim[string] `json:"data,omitempty"`
  }

func (t *Dnstxtrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnstxtrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnstxtrecord%v", string(b))
}



type Dnsurirecord struct {
  
    /*
Priority (order)
Lower number means higher priority. Clients will attempt to contact the URI with the lowest-numbered priority they can reach.
    */
    Priority IPAPrim[int] `json:"priority,omitempty"`
  
    /*
Weight
Relative weight for entries with the same priority.
    */
    Weight IPAPrim[int] `json:"weight,omitempty"`
  
    /*
Target Uniform Resource Identifier
Target Uniform Resource Identifier according to RFC 3986
    */
    Target IPAPrim[string] `json:"target,omitempty"`
  }

func (t *Dnsurirecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsurirecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsurirecord%v", string(b))
}



type Dnszone struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname DNSName `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *IPAPrim[string] `json:"name_from_ip,omitempty"`
  
    /*
Active zone
Is zone active?
    */
    Idnszoneactive *IPAPrim[bool] `json:"idnszoneactive,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]IPAPrim[string] `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *IPAPrim[string] `json:"idnsforwardpolicy,omitempty"`
  
    /*
Managedby permission

    */
    Managedby *IPAPrim[string] `json:"managedby,omitempty"`
  
    /*
Authoritative nameserver
Authoritative nameserver domain name
    */
    Idnssoamname *DNSName `json:"idnssoamname,omitempty"`
  
    /*
Administrator e-mail address
Administrator e-mail address
    */
    Idnssoarname *DNSName `json:"idnssoarname,omitempty"`
  
    /*
SOA serial
SOA record serial number
    */
    Idnssoaserial *IPAPrim[int] `json:"idnssoaserial,omitempty"`
  
    /*
SOA refresh
SOA record refresh time
    */
    Idnssoarefresh *IPAPrim[int] `json:"idnssoarefresh,omitempty"`
  
    /*
SOA retry
SOA record retry time
    */
    Idnssoaretry *IPAPrim[int] `json:"idnssoaretry,omitempty"`
  
    /*
SOA expire
SOA record expire time
    */
    Idnssoaexpire *IPAPrim[int] `json:"idnssoaexpire,omitempty"`
  
    /*
SOA minimum
How long should negative responses be cached
    */
    Idnssoaminimum *IPAPrim[int] `json:"idnssoaminimum,omitempty"`
  
    /*
Time to live
Time to live for records at zone apex
    */
    Dnsttl *IPAPrim[int] `json:"dnsttl,omitempty"`
  
    /*
Default time to live
Time to live for records without explicit TTL definition
    */
    Dnsdefaultttl *IPAPrim[int] `json:"dnsdefaultttl,omitempty"`
  
    /*


    */
    Dnsclass *IPAPrim[string] `json:"dnsclass,omitempty"`
  
    /*
BIND update policy
BIND update policy
    */
    Idnsupdatepolicy *IPAPrim[string] `json:"idnsupdatepolicy,omitempty"`
  
    /*
Dynamic update
Allow dynamic updates.
    */
    Idnsallowdynupdate *IPAPrim[bool] `json:"idnsallowdynupdate,omitempty"`
  
    /*
Allow query
Semicolon separated list of IP addresses or networks which are allowed to issue queries
    */
    Idnsallowquery *IPAPrim[string] `json:"idnsallowquery,omitempty"`
  
    /*
Allow transfer
Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
    */
    Idnsallowtransfer *IPAPrim[string] `json:"idnsallowtransfer,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
    */
    Idnsallowsyncptr *IPAPrim[bool] `json:"idnsallowsyncptr,omitempty"`
  
    /*
Allow in-line DNSSEC signing
Allow inline DNSSEC signing of records in the zone
    */
    Idnssecinlinesigning *IPAPrim[bool] `json:"idnssecinlinesigning,omitempty"`
  
    /*
NSEC3PARAM record
NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
    */
    Nsec3paramrecord *IPAPrim[string] `json:"nsec3paramrecord,omitempty"`
  }

func (t *Dnszone) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnszone[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnszone%v", string(b))
}



type Group struct {
  
    /*
Group name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
Group description
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
GID
GID (use this option to set it manually)
    */
    Gidnumber *IPAPrim[int] `json:"gidnumber,omitempty"`
  
    /*
External member
Members of a trusted domain in DOM\name or name@domain form
    */
    Ipaexternalmember *[]IPAPrim[string] `json:"ipaexternalmember,omitempty"`
  
    /*
Member users

    */
    MemberUser *[]IPAPrim[string] `json:"member_user,omitempty"`
  
    /*
Member groups

    */
    MemberGroup *[]IPAPrim[string] `json:"member_group,omitempty"`
  
    /*
Member of groups

    */
    MemberofGroup *[]IPAPrim[string] `json:"memberof_group,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]IPAPrim[string] `json:"memberof_role,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]IPAPrim[string] `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]IPAPrim[string] `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]IPAPrim[string] `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member users

    */
    MemberindirectUser *IPAPrim[string] `json:"memberindirect_user,omitempty"`
  
    /*
Indirect Member groups

    */
    MemberindirectGroup *IPAPrim[string] `json:"memberindirect_group,omitempty"`
  
    /*
Indirect Member of group

    */
    MemberofindirectGroup *IPAPrim[string] `json:"memberofindirect_group,omitempty"`
  
    /*
Indirect Member of netgroup

    */
    MemberofindirectNetgroup *IPAPrim[string] `json:"memberofindirect_netgroup,omitempty"`
  
    /*
Indirect Member of role

    */
    MemberofindirectRole *IPAPrim[string] `json:"memberofindirect_role,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *IPAPrim[string] `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *IPAPrim[string] `json:"memberofindirect_hbacrule,omitempty"`
  }

func (t *Group) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Group[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Group%v", string(b))
}



type Hbacrule struct {
  
    /*
Rule name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Rule type
Rule type (allow)
    */
    Accessruletype IPAPrim[string] `json:"accessruletype,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *IPAPrim[string] `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *IPAPrim[string] `json:"hostcategory,omitempty"`
  
    /*
Source host category
Source host category the rule applies to
    */
    Sourcehostcategory *IPAPrim[string] `json:"sourcehostcategory,omitempty"`
  
    /*
Service category
Service category the rule applies to
    */
    Servicecategory *IPAPrim[string] `json:"servicecategory,omitempty"`
  
    /*
Description

    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *IPAPrim[bool] `json:"ipaenabledflag,omitempty"`
  
    /*
Users

    */
    MemberuserUser *IPAPrim[string] `json:"memberuser_user,omitempty"`
  
    /*
User Groups

    */
    MemberuserGroup *IPAPrim[string] `json:"memberuser_group,omitempty"`
  
    /*
Hosts

    */
    MemberhostHost *IPAPrim[string] `json:"memberhost_host,omitempty"`
  
    /*
Host Groups

    */
    MemberhostHostgroup *IPAPrim[string] `json:"memberhost_hostgroup,omitempty"`
  
    /*
Source Hosts

    */
    SourcehostHost *IPAPrim[string] `json:"sourcehost_host,omitempty"`
  
    /*
Source Host Groups

    */
    SourcehostHostgroup *IPAPrim[string] `json:"sourcehost_hostgroup,omitempty"`
  
    /*
Services

    */
    MemberserviceHbacsvc *IPAPrim[string] `json:"memberservice_hbacsvc,omitempty"`
  
    /*
Service Groups

    */
    MemberserviceHbacsvcgroup *IPAPrim[string] `json:"memberservice_hbacsvcgroup,omitempty"`
  
    /*
External host

    */
    Externalhost *[]IPAPrim[string] `json:"externalhost,omitempty"`
  }

func (t *Hbacrule) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Hbacrule[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Hbacrule%v", string(b))
}



type Hbacsvc struct {
  
    /*
Service name
HBAC service
    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
HBAC service description
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Member of HBAC service groups

    */
    MemberofHbacsvcgroup *[]IPAPrim[string] `json:"memberof_hbacsvcgroup,omitempty"`
  }

func (t *Hbacsvc) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Hbacsvc[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Hbacsvc%v", string(b))
}



type Hbacsvcgroup struct {
  
    /*
Service group name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
HBAC service group description
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Member HBAC service

    */
    MemberHbacsvc *[]IPAPrim[string] `json:"member_hbacsvc,omitempty"`
  }

func (t *Hbacsvcgroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Hbacsvcgroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Hbacsvcgroup%v", string(b))
}



type Host struct {
  
    /*
Host name

    */
    Fqdn IPAPrim[string] `json:"fqdn,omitempty"`
  
    /*
Description
A description of this host
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Locality
Host locality (e.g. "Baltimore, MD")
    */
    L *IPAPrim[string] `json:"l,omitempty"`
  
    /*
Location
Host location (e.g. "Lab 2")
    */
    Nshostlocation *IPAPrim[string] `json:"nshostlocation,omitempty"`
  
    /*
Platform
Host hardware platform (e.g. "Lenovo T61")
    */
    Nshardwareplatform *IPAPrim[string] `json:"nshardwareplatform,omitempty"`
  
    /*
Operating system
Host operating system and version (e.g. "Fedora 9")
    */
    Nsosversion *IPAPrim[string] `json:"nsosversion,omitempty"`
  
    /*
User password
Password used in bulk enrollment
    */
    Userpassword *IPAPrim[string] `json:"userpassword,omitempty"`
  
    /*

Generate a random password to be used in bulk enrollment
    */
    Random *IPAPrim[bool] `json:"random,omitempty"`
  
    /*
Random password

    */
    Randompassword *IPAPrim[string] `json:"randompassword,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Subject

    */
    Subject *IPAPrim[string] `json:"subject,omitempty"`
  
    /*
Serial Number

    */
    SerialNumber *IPAPrim[string] `json:"serial_number,omitempty"`
  
    /*
Serial Number (hex)

    */
    SerialNumberHex *IPAPrim[string] `json:"serial_number_hex,omitempty"`
  
    /*
Issuer

    */
    Issuer *IPAPrim[string] `json:"issuer,omitempty"`
  
    /*
Not Before

    */
    ValidNotBefore *IPAPrim[string] `json:"valid_not_before,omitempty"`
  
    /*
Not After

    */
    ValidNotAfter *IPAPrim[string] `json:"valid_not_after,omitempty"`
  
    /*
Fingerprint (SHA1)

    */
    Sha1Fingerprint *IPAPrim[string] `json:"sha1_fingerprint,omitempty"`
  
    /*
Fingerprint (SHA256)

    */
    Sha256Fingerprint *IPAPrim[string] `json:"sha256_fingerprint,omitempty"`
  
    /*
Revocation reason

    */
    RevocationReason *IPAPrim[string] `json:"revocation_reason,omitempty"`
  
    /*
Principal name

    */
    Krbcanonicalname *IPAPrim[string] `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]IPAPrim[string] `json:"krbprincipalname,omitempty"`
  
    /*
MAC address
Hardware MAC address(es) on this host
    */
    Macaddress *[]IPAPrim[string] `json:"macaddress,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]IPAPrim[string] `json:"ipasshpubkey,omitempty"`
  
    /*
SSH public key fingerprint

    */
    Sshpubkeyfp *[]IPAPrim[string] `json:"sshpubkeyfp,omitempty"`
  
    /*
Class
Host category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]IPAPrim[string] `json:"userclass,omitempty"`
  
    /*
Assigned ID View

    */
    Ipaassignedidview *IPAPrim[string] `json:"ipaassignedidview,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]IPAPrim[string] `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *IPAPrim[bool] `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *IPAPrim[bool] `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *IPAPrim[bool] `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*
Password

    */
    HasPassword *IPAPrim[bool] `json:"has_password,omitempty"`
  
    /*
Member of host-groups

    */
    MemberofHostgroup *[]IPAPrim[string] `json:"memberof_hostgroup,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]IPAPrim[string] `json:"memberof_role,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]IPAPrim[string] `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]IPAPrim[string] `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]IPAPrim[string] `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member of netgroup

    */
    MemberofindirectNetgroup *IPAPrim[string] `json:"memberofindirect_netgroup,omitempty"`
  
    /*
Indirect Member of host-group

    */
    MemberofindirectHostgroup *IPAPrim[string] `json:"memberofindirect_hostgroup,omitempty"`
  
    /*
Indirect Member of role

    */
    MemberofindirectRole *IPAPrim[string] `json:"memberofindirect_role,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *IPAPrim[string] `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *IPAPrim[string] `json:"memberofindirect_hbacrule,omitempty"`
  
    /*
Keytab

    */
    HasKeytab *IPAPrim[bool] `json:"has_keytab,omitempty"`
  
    /*
Managed by

    */
    ManagedbyHost *IPAPrim[string] `json:"managedby_host,omitempty"`
  
    /*
Server host name

    */
    Serverhostname *IPAPrim[string] `json:"serverhostname,omitempty"`
  
    /*
Managing

    */
    ManagingHost *IPAPrim[string] `json:"managing_host,omitempty"`
  
    /*
Users allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysUser *IPAPrim[string] `json:"ipaallowedtoperform_read_keys_user,omitempty"`
  
    /*
Groups allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysGroup *IPAPrim[string] `json:"ipaallowedtoperform_read_keys_group,omitempty"`
  
    /*
Hosts allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysHost *IPAPrim[string] `json:"ipaallowedtoperform_read_keys_host,omitempty"`
  
    /*
Host Groups allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysHostgroup *IPAPrim[string] `json:"ipaallowedtoperform_read_keys_hostgroup,omitempty"`
  
    /*
Users allowed to create keytab

    */
    IpaallowedtoperformWriteKeysUser *IPAPrim[string] `json:"ipaallowedtoperform_write_keys_user,omitempty"`
  
    /*
Groups allowed to create keytab

    */
    IpaallowedtoperformWriteKeysGroup *IPAPrim[string] `json:"ipaallowedtoperform_write_keys_group,omitempty"`
  
    /*
Hosts allowed to create keytab

    */
    IpaallowedtoperformWriteKeysHost *IPAPrim[string] `json:"ipaallowedtoperform_write_keys_host,omitempty"`
  
    /*
Host Groups allowed to create keytab

    */
    IpaallowedtoperformWriteKeysHostgroup *IPAPrim[string] `json:"ipaallowedtoperform_write_keys_hostgroup,omitempty"`
  }

func (t *Host) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Host[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Host%v", string(b))
}



type Hostgroup struct {
  
    /*
Host-group
Name of host-group
    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
A description of this host-group
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Member hosts

    */
    MemberHost *[]IPAPrim[string] `json:"member_host,omitempty"`
  
    /*
Member host-groups

    */
    MemberHostgroup *[]IPAPrim[string] `json:"member_hostgroup,omitempty"`
  
    /*
Member of host-groups

    */
    MemberofHostgroup *[]IPAPrim[string] `json:"memberof_hostgroup,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]IPAPrim[string] `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]IPAPrim[string] `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]IPAPrim[string] `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member hosts

    */
    MemberindirectHost *IPAPrim[string] `json:"memberindirect_host,omitempty"`
  
    /*
Indirect Member host-groups

    */
    MemberindirectHostgroup *IPAPrim[string] `json:"memberindirect_hostgroup,omitempty"`
  
    /*
Indirect Member of host-group

    */
    MemberofindirectHostgroup *IPAPrim[string] `json:"memberofindirect_hostgroup,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *IPAPrim[string] `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *IPAPrim[string] `json:"memberofindirect_hbacrule,omitempty"`
  }

func (t *Hostgroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Hostgroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Hostgroup%v", string(b))
}



type Idoverridegroup struct {
  
    /*
Anchor to override

    */
    Ipaanchoruuid IPAPrim[string] `json:"ipaanchoruuid,omitempty"`
  
    /*
Description

    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Group name

    */
    Cn *IPAPrim[string] `json:"cn,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *IPAPrim[int] `json:"gidnumber,omitempty"`
  }

func (t *Idoverridegroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Idoverridegroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Idoverridegroup%v", string(b))
}



type Idoverrideuser struct {
  
    /*
Anchor to override

    */
    Ipaanchoruuid IPAPrim[string] `json:"ipaanchoruuid,omitempty"`
  
    /*
Description

    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
User login

    */
    UID *IPAPrim[string] `json:"uid,omitempty"`
  
    /*
UID
User ID Number
    */
    Uidnumber *IPAPrim[int] `json:"uidnumber,omitempty"`
  
    /*
GECOS

    */
    Gecos *IPAPrim[string] `json:"gecos,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *IPAPrim[int] `json:"gidnumber,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *IPAPrim[string] `json:"homedirectory,omitempty"`
  
    /*
Login shell

    */
    Loginshell *IPAPrim[string] `json:"loginshell,omitempty"`
  
    /*


    */
    Ipaoriginaluid *IPAPrim[string] `json:"ipaoriginaluid,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]IPAPrim[string] `json:"ipasshpubkey,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  }

func (t *Idoverrideuser) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Idoverrideuser[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Idoverrideuser%v", string(b))
}



type Idrange struct {
  
    /*
Range name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
First Posix ID of the range

    */
    Ipabaseid IPAPrim[int] `json:"ipabaseid,omitempty"`
  
    /*
Number of IDs in the range

    */
    Ipaidrangesize IPAPrim[int] `json:"ipaidrangesize,omitempty"`
  
    /*
First RID of the corresponding RID range

    */
    Ipabaserid *IPAPrim[int] `json:"ipabaserid,omitempty"`
  
    /*
First RID of the secondary RID range

    */
    Ipasecondarybaserid *IPAPrim[int] `json:"ipasecondarybaserid,omitempty"`
  
    /*
Domain SID of the trusted domain

    */
    Ipanttrusteddomainsid *IPAPrim[string] `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Name of the trusted domain

    */
    Ipanttrusteddomainname *IPAPrim[string] `json:"ipanttrusteddomainname,omitempty"`
  
    /*
Range type
ID range type, one of ipa-ad-trust, ipa-ad-trust-posix, ipa-local
    */
    Iparangetype *IPAPrim[string] `json:"iparangetype,omitempty"`
  }

func (t *Idrange) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Idrange[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Idrange%v", string(b))
}



type Idview struct {
  
    /*
ID View Name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
User object overrides

    */
    Useroverrides *IPAPrim[string] `json:"useroverrides,omitempty"`
  
    /*
Group object overrides

    */
    Groupoverrides *IPAPrim[string] `json:"groupoverrides,omitempty"`
  
    /*
Hosts the view applies to

    */
    Appliedtohosts *IPAPrim[string] `json:"appliedtohosts,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *IPAPrim[string] `json:"ipadomainresolutionorder,omitempty"`
  }

func (t *Idview) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Idview[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Idview%v", string(b))
}



type Krbtpolicy struct {
  
    /*
User name
Manage ticket policy for specific user
    */
    UID *IPAPrim[string] `json:"uid,omitempty"`
  
    /*
Max life
Maximum ticket life (seconds)
    */
    Krbmaxticketlife *IPAPrim[int] `json:"krbmaxticketlife,omitempty"`
  
    /*
Max renew
Maximum renewable age (seconds)
    */
    Krbmaxrenewableage *IPAPrim[int] `json:"krbmaxrenewableage,omitempty"`
  }

func (t *Krbtpolicy) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Krbtpolicy[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Krbtpolicy%v", string(b))
}



type Location struct {
  
    /*
Location name
IPA location name
    */
    Idnsname DNSName `json:"idnsname,omitempty"`
  
    /*
Description
IPA Location description
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Servers
Servers that belongs to the IPA location
    */
    ServersServer *[]IPAPrim[string] `json:"servers_server,omitempty"`
  
    /*
Advertised by servers
List of servers which advertise the given location
    */
    DNSServer *[]IPAPrim[string] `json:"dns_server,omitempty"`
  }

func (t *Location) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Location[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Location%v", string(b))
}



type Metaobject struct {
  
    /*
Name

    */
    Name IPAPrim[string] `json:"name,omitempty"`
  
    /*
Version

    */
    Version IPAPrim[string] `json:"version,omitempty"`
  
    /*
Full name

    */
    FullName IPAPrim[string] `json:"full_name,omitempty"`
  
    /*
Documentation

    */
    Doc *IPAPrim[string] `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]IPAPrim[string] `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]IPAPrim[string] `json:"include,omitempty"`
  
    /*
Help topic

    */
    TopicTopic *IPAPrim[string] `json:"topic_topic,omitempty"`
  
    /*
Parameters

    */
    ParamsParam *[]IPAPrim[string] `json:"params_param,omitempty"`
  }

func (t *Metaobject) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Metaobject[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Metaobject%v", string(b))
}



type Netgroup struct {
  
    /*
Netgroup name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
Netgroup description
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
NIS domain name

    */
    Nisdomainname *IPAPrim[string] `json:"nisdomainname,omitempty"`
  
    /*
IPA unique ID
IPA unique ID
    */
    Ipauniqueid *IPAPrim[string] `json:"ipauniqueid,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *IPAPrim[string] `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *IPAPrim[string] `json:"hostcategory,omitempty"`
  
    /*
External host

    */
    Externalhost *[]IPAPrim[string] `json:"externalhost,omitempty"`
  
    /*
Member netgroups

    */
    MemberNetgroup *[]IPAPrim[string] `json:"member_netgroup,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]IPAPrim[string] `json:"memberof_netgroup,omitempty"`
  
    /*
Indirect Member netgroups

    */
    MemberindirectNetgroup *IPAPrim[string] `json:"memberindirect_netgroup,omitempty"`
  
    /*
Member User

    */
    MemberuserUser *IPAPrim[string] `json:"memberuser_user,omitempty"`
  
    /*
Member Group

    */
    MemberuserGroup *IPAPrim[string] `json:"memberuser_group,omitempty"`
  
    /*
Member Host

    */
    MemberhostHost *IPAPrim[string] `json:"memberhost_host,omitempty"`
  
    /*
Member Hostgroup

    */
    MemberhostHostgroup *IPAPrim[string] `json:"memberhost_hostgroup,omitempty"`
  }

func (t *Netgroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Netgroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Netgroup%v", string(b))
}



type Otpconfig struct {
  
    /*
TOTP authentication Window
TOTP authentication time variance (seconds)
    */
    Ipatokentotpauthwindow IPAPrim[int] `json:"ipatokentotpauthwindow,omitempty"`
  
    /*
TOTP Synchronization Window
TOTP synchronization time variance (seconds)
    */
    Ipatokentotpsyncwindow IPAPrim[int] `json:"ipatokentotpsyncwindow,omitempty"`
  
    /*
HOTP Authentication Window
HOTP authentication skip-ahead
    */
    Ipatokenhotpauthwindow IPAPrim[int] `json:"ipatokenhotpauthwindow,omitempty"`
  
    /*
HOTP Synchronization Window
HOTP synchronization skip-ahead
    */
    Ipatokenhotpsyncwindow IPAPrim[int] `json:"ipatokenhotpsyncwindow,omitempty"`
  }

func (t *Otpconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Otpconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Otpconfig%v", string(b))
}



type Otptoken struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid IPAPrim[string] `json:"ipatokenuniqueid,omitempty"`
  
    /*
Type
Type of the token
    */
    Type *IPAPrim[string] `json:"type,omitempty"`
  
    /*
Description
Token description (informational only)
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Owner
Assigned user of the token (default: self)
    */
    Ipatokenowner *IPAPrim[string] `json:"ipatokenowner,omitempty"`
  
    /*
Manager
Assigned manager of the token (default: self)
    */
    ManagedbyUser *IPAPrim[string] `json:"managedby_user,omitempty"`
  
    /*
Disabled
Mark the token as disabled (default: false)
    */
    Ipatokendisabled *IPAPrim[bool] `json:"ipatokendisabled,omitempty"`
  
    /*
Validity start
First date/time the token can be used
    */
    Ipatokennotbefore *IPATime `json:"ipatokennotbefore,omitempty"`
  
    /*
Validity end
Last date/time the token can be used
    */
    Ipatokennotafter *IPATime `json:"ipatokennotafter,omitempty"`
  
    /*
Vendor
Token vendor name (informational only)
    */
    Ipatokenvendor *IPAPrim[string] `json:"ipatokenvendor,omitempty"`
  
    /*
Model
Token model (informational only)
    */
    Ipatokenmodel *IPAPrim[string] `json:"ipatokenmodel,omitempty"`
  
    /*
Serial
Token serial (informational only)
    */
    Ipatokenserial *IPAPrim[string] `json:"ipatokenserial,omitempty"`
  
    /*
Key
Token secret (Base32; default: random)
    */
    Ipatokenotpkey *string `json:"ipatokenotpkey,omitempty"`
  
    /*
Algorithm
Token hash algorithm
    */
    Ipatokenotpalgorithm *IPAPrim[string] `json:"ipatokenotpalgorithm,omitempty"`
  
    /*
Digits
Number of digits each token code will have
    */
    Ipatokenotpdigits *IPAPrim[int] `json:"ipatokenotpdigits,omitempty"`
  
    /*
Clock offset
TOTP token / FreeIPA server time difference
    */
    Ipatokentotpclockoffset *IPAPrim[int] `json:"ipatokentotpclockoffset,omitempty"`
  
    /*
Clock interval
Length of TOTP token code validity
    */
    Ipatokentotptimestep *IPAPrim[int] `json:"ipatokentotptimestep,omitempty"`
  
    /*
Counter
Initial counter for the HOTP token
    */
    Ipatokenhotpcounter *IPAPrim[int] `json:"ipatokenhotpcounter,omitempty"`
  
    /*
URI

    */
    URI *IPAPrim[string] `json:"uri,omitempty"`
  }

func (t *Otptoken) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Otptoken[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Otptoken%v", string(b))
}



type Output struct {
  
    /*
Name

    */
    Name IPAPrim[string] `json:"name,omitempty"`
  
    /*
Documentation

    */
    Doc *IPAPrim[string] `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]IPAPrim[string] `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]IPAPrim[string] `json:"include,omitempty"`
  
    /*
Type

    */
    Type *IPAPrim[string] `json:"type,omitempty"`
  
    /*
Required

    */
    Required *IPAPrim[bool] `json:"required,omitempty"`
  
    /*
Multi-value

    */
    Multivalue *IPAPrim[bool] `json:"multivalue,omitempty"`
  }

func (t *Output) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Output[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Output%v", string(b))
}



type Param struct {
  
    /*
Name

    */
    Name IPAPrim[string] `json:"name,omitempty"`
  
    /*
Documentation

    */
    Doc *IPAPrim[string] `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]IPAPrim[string] `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]IPAPrim[string] `json:"include,omitempty"`
  
    /*
Type

    */
    Type *IPAPrim[string] `json:"type,omitempty"`
  
    /*
Required

    */
    Required *IPAPrim[bool] `json:"required,omitempty"`
  
    /*
Multi-value

    */
    Multivalue *IPAPrim[bool] `json:"multivalue,omitempty"`
  
    /*
Always ask

    */
    Alwaysask *IPAPrim[bool] `json:"alwaysask,omitempty"`
  
    /*
CLI metavar

    */
    CliMetavar *IPAPrim[string] `json:"cli_metavar,omitempty"`
  
    /*
CLI name

    */
    CliName *IPAPrim[string] `json:"cli_name,omitempty"`
  
    /*
Confirm (password)

    */
    Confirm *IPAPrim[bool] `json:"confirm,omitempty"`
  
    /*
Default

    */
    Default *[]IPAPrim[string] `json:"default,omitempty"`
  
    /*
Default from

    */
    DefaultFromParam *[]IPAPrim[string] `json:"default_from_param,omitempty"`
  
    /*
Label

    */
    Label *IPAPrim[string] `json:"label,omitempty"`
  
    /*
Convert on server

    */
    NoConvert *IPAPrim[bool] `json:"no_convert,omitempty"`
  
    /*
Option group

    */
    OptionGroup *IPAPrim[string] `json:"option_group,omitempty"`
  
    /*
Sensitive

    */
    Sensitive *IPAPrim[bool] `json:"sensitive,omitempty"`
  
    /*
Positional argument

    */
    Positional *IPAPrim[bool] `json:"positional,omitempty"`
  }

func (t *Param) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Param[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Param%v", string(b))
}



type Permission struct {
  
    /*
Permission name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Granted rights
Rights to grant (read, search, compare, write, add, delete, all)
    */
    Ipapermright *[]IPAPrim[string] `json:"ipapermright,omitempty"`
  
    /*
Effective attributes
All attributes to which the permission applies
    */
    Attrs *[]IPAPrim[string] `json:"attrs,omitempty"`
  
    /*
Included attributes
User-specified attributes to which the permission applies
    */
    Ipapermincludedattr *[]IPAPrim[string] `json:"ipapermincludedattr,omitempty"`
  
    /*
Excluded attributes
User-specified attributes to which the permission explicitly does not apply
    */
    Ipapermexcludedattr *[]IPAPrim[string] `json:"ipapermexcludedattr,omitempty"`
  
    /*
Default attributes
Attributes to which the permission applies by default
    */
    Ipapermdefaultattr *[]IPAPrim[string] `json:"ipapermdefaultattr,omitempty"`
  
    /*
Bind rule type
Bind rule type
    */
    Ipapermbindruletype *IPAPrim[string] `json:"ipapermbindruletype,omitempty"`
  
    /*
Subtree
Subtree to apply permissions to
    */
    Ipapermlocation *string `json:"ipapermlocation,omitempty"`
  
    /*
Extra target filter
Extra target filter
    */
    Extratargetfilter *[]IPAPrim[string] `json:"extratargetfilter,omitempty"`
  
    /*
Raw target filter
All target filters, including those implied by type and memberof
    */
    Ipapermtargetfilter *[]IPAPrim[string] `json:"ipapermtargetfilter,omitempty"`
  
    /*
Target DN
Optional DN to apply the permission to (must be in the subtree, but may not yet exist)
    */
    Ipapermtarget *string `json:"ipapermtarget,omitempty"`
  
    /*
Target DN subtree
Optional DN subtree where an entry can be moved to (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetto *string `json:"ipapermtargetto,omitempty"`
  
    /*
Origin DN subtree
Optional DN subtree from where an entry can be moved (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetfrom *string `json:"ipapermtargetfrom,omitempty"`
  
    /*
Member of group
Target members of a group (sets memberOf targetfilter)
    */
    Memberof *[]IPAPrim[string] `json:"memberof,omitempty"`
  
    /*
Target group
User group to apply permissions to (sets target)
    */
    Targetgroup *IPAPrim[string] `json:"targetgroup,omitempty"`
  
    /*
Type
Type of IPA object (sets subtree and objectClass targetfilter)
    */
    Type *IPAPrim[string] `json:"type,omitempty"`
  
    /*

Deprecated; use extratargetfilter
    */
    Filter *[]IPAPrim[string] `json:"filter,omitempty"`
  
    /*

Deprecated; use ipapermlocation
    */
    Subtree *[]IPAPrim[string] `json:"subtree,omitempty"`
  
    /*

Deprecated; use ipapermright
    */
    Permissions *[]IPAPrim[string] `json:"permissions,omitempty"`
  
    /*
Permission flags

    */
    Ipapermissiontype *[]IPAPrim[string] `json:"ipapermissiontype,omitempty"`
  
    /*
ACI

    */
    Aci *IPAPrim[string] `json:"aci,omitempty"`
  
    /*
Granted to Privilege

    */
    MemberPrivilege *[]IPAPrim[string] `json:"member_privilege,omitempty"`
  
    /*
Indirect Member of roles

    */
    MemberindirectRole *IPAPrim[string] `json:"memberindirect_role,omitempty"`
  }

func (t *Permission) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Permission[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Permission%v", string(b))
}



type Pkinit struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer *IPAPrim[string] `json:"server_server,omitempty"`
  
    /*
PKINIT status
Whether PKINIT is enabled or disabled
    */
    Status *IPAPrim[string] `json:"status,omitempty"`
  }

func (t *Pkinit) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Pkinit[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Pkinit%v", string(b))
}



type Privilege struct {
  
    /*
Privilege name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
Privilege description
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Permissions

    */
    MemberofPermission *[]IPAPrim[string] `json:"memberof_permission,omitempty"`
  
    /*
Granting privilege to roles

    */
    MemberRole *[]IPAPrim[string] `json:"member_role,omitempty"`
  }

func (t *Privilege) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Privilege[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Privilege%v", string(b))
}



type Pwpolicy struct {
  
    /*
Group
Manage password policy for specific group
    */
    Cn *IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Max lifetime (days)
Maximum password lifetime (in days)
    */
    Krbmaxpwdlife *IPAPrim[int] `json:"krbmaxpwdlife,omitempty"`
  
    /*
Min lifetime (hours)
Minimum password lifetime (in hours)
    */
    Krbminpwdlife *IPAPrim[int] `json:"krbminpwdlife,omitempty"`
  
    /*
History size
Password history size
    */
    Krbpwdhistorylength *IPAPrim[int] `json:"krbpwdhistorylength,omitempty"`
  
    /*
Character classes
Minimum number of character classes
    */
    Krbpwdmindiffchars *IPAPrim[int] `json:"krbpwdmindiffchars,omitempty"`
  
    /*
Min length
Minimum length of password
    */
    Krbpwdminlength *IPAPrim[int] `json:"krbpwdminlength,omitempty"`
  
    /*
Priority
Priority of the policy (higher number means lower priority
    */
    Cospriority *IPAPrim[int] `json:"cospriority,omitempty"`
  
    /*
Max failures
Consecutive failures before lockout
    */
    Krbpwdmaxfailure *IPAPrim[int] `json:"krbpwdmaxfailure,omitempty"`
  
    /*
Failure reset interval
Period after which failure count will be reset (seconds)
    */
    Krbpwdfailurecountinterval *IPAPrim[int] `json:"krbpwdfailurecountinterval,omitempty"`
  
    /*
Lockout duration
Period for which lockout is enforced (seconds)
    */
    Krbpwdlockoutduration *IPAPrim[int] `json:"krbpwdlockoutduration,omitempty"`
  }

func (t *Pwpolicy) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Pwpolicy[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Pwpolicy%v", string(b))
}



type Radiusproxy struct {
  
    /*
RADIUS proxy server name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
A description of this RADIUS proxy server
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Server
The hostname or IP (with or without port)
    */
    Ipatokenradiusserver *IPAPrim[string] `json:"ipatokenradiusserver,omitempty"`
  
    /*
Secret
The secret used to encrypt data
    */
    Ipatokenradiussecret *IPAPrim[string] `json:"ipatokenradiussecret,omitempty"`
  
    /*
Timeout
The total timeout across all retries (in seconds)
    */
    Ipatokenradiustimeout *IPAPrim[int] `json:"ipatokenradiustimeout,omitempty"`
  
    /*
Retries
The number of times to retry authentication
    */
    Ipatokenradiusretries *IPAPrim[int] `json:"ipatokenradiusretries,omitempty"`
  
    /*
User attribute
The username attribute on the user object
    */
    Ipatokenusermapattribute *IPAPrim[string] `json:"ipatokenusermapattribute,omitempty"`
  }

func (t *Radiusproxy) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Radiusproxy[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Radiusproxy%v", string(b))
}



type Realmdomains struct {
  
    /*
Domain

    */
    Associateddomain []IPAPrim[string] `json:"associateddomain,omitempty"`
  
    /*
Add domain

    */
    AddDomain *IPAPrim[string] `json:"add_domain,omitempty"`
  
    /*
Delete domain

    */
    DelDomain *IPAPrim[string] `json:"del_domain,omitempty"`
  }

func (t *Realmdomains) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Realmdomains[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Realmdomains%v", string(b))
}



type Role struct {
  
    /*
Role name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
A description of this role-group
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Member users

    */
    MemberUser *[]IPAPrim[string] `json:"member_user,omitempty"`
  
    /*
Member groups

    */
    MemberGroup *[]IPAPrim[string] `json:"member_group,omitempty"`
  
    /*
Member hosts

    */
    MemberHost *[]IPAPrim[string] `json:"member_host,omitempty"`
  
    /*
Member host-groups

    */
    MemberHostgroup *[]IPAPrim[string] `json:"member_hostgroup,omitempty"`
  
    /*
Privileges

    */
    MemberofPrivilege *[]IPAPrim[string] `json:"memberof_privilege,omitempty"`
  
    /*
Member services

    */
    MemberService *[]IPAPrim[string] `json:"member_service,omitempty"`
  }

func (t *Role) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Role[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Role%v", string(b))
}



type Selfservice struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname IPAPrim[string] `json:"aciname,omitempty"`
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]IPAPrim[string] `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the permission applies.
    */
    Attrs *[]IPAPrim[string] `json:"attrs,omitempty"`
  
    /*
ACI

    */
    Aci *IPAPrim[string] `json:"aci,omitempty"`
  }

func (t *Selfservice) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Selfservice[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Selfservice%v", string(b))
}



type Selinuxusermap struct {
  
    /*
Rule name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
SELinux User

    */
    Ipaselinuxuser IPAPrim[string] `json:"ipaselinuxuser,omitempty"`
  
    /*
HBAC Rule
HBAC Rule that defines the users, groups and hostgroups
    */
    Seealso *IPAPrim[string] `json:"seealso,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *IPAPrim[string] `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *IPAPrim[string] `json:"hostcategory,omitempty"`
  
    /*
Description

    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *IPAPrim[bool] `json:"ipaenabledflag,omitempty"`
  
    /*
Users

    */
    MemberuserUser *IPAPrim[string] `json:"memberuser_user,omitempty"`
  
    /*
User Groups

    */
    MemberuserGroup *IPAPrim[string] `json:"memberuser_group,omitempty"`
  
    /*
Hosts

    */
    MemberhostHost *IPAPrim[string] `json:"memberhost_host,omitempty"`
  
    /*
Host Groups

    */
    MemberhostHostgroup *IPAPrim[string] `json:"memberhost_hostgroup,omitempty"`
  }

func (t *Selinuxusermap) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Selinuxusermap[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Selinuxusermap%v", string(b))
}



type Server struct {
  
    /*
Server name
IPA server hostname
    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*


    */
    Iparepltopomanagedsuffix *[]IPAPrim[string] `json:"iparepltopomanagedsuffix,omitempty"`
  
    /*
Managed suffixes

    */
    IparepltopomanagedsuffixTopologysuffix *[]IPAPrim[string] `json:"iparepltopomanagedsuffix_topologysuffix,omitempty"`
  
    /*
Min domain level
Minimum domain level
    */
    Ipamindomainlevel *IPAPrim[int] `json:"ipamindomainlevel,omitempty"`
  
    /*
Max domain level
Maximum domain level
    */
    Ipamaxdomainlevel *IPAPrim[int] `json:"ipamaxdomainlevel,omitempty"`
  
    /*
Location
Server location
    */
    IpalocationLocation *DNSName `json:"ipalocation_location,omitempty"`
  
    /*
Service weight
Weight for server services
    */
    Ipaserviceweight *IPAPrim[int] `json:"ipaserviceweight,omitempty"`
  
    /*
Service relative weight
Relative weight for server services (counts per location)
    */
    ServiceRelativeWeight *IPAPrim[string] `json:"service_relative_weight,omitempty"`
  
    /*
Enabled server roles
List of enabled roles
    */
    EnabledRoleServrole *[]IPAPrim[string] `json:"enabled_role_servrole,omitempty"`
  }

func (t *Server) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Server[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Server%v", string(b))
}



type ServerRole struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer IPAPrim[string] `json:"server_server,omitempty"`
  
    /*
Role name
IPA server role name
    */
    RoleServrole IPAPrim[string] `json:"role_servrole,omitempty"`
  
    /*
Role status
Status of the role
    */
    Status *IPAPrim[string] `json:"status,omitempty"`
  }

func (t *ServerRole) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerRole[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerRole%v", string(b))
}



type Service struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname IPAPrim[string] `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname *[]IPAPrim[string] `json:"krbprincipalname,omitempty"`
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Subject

    */
    Subject *IPAPrim[string] `json:"subject,omitempty"`
  
    /*
Serial Number

    */
    SerialNumber *IPAPrim[string] `json:"serial_number,omitempty"`
  
    /*
Serial Number (hex)

    */
    SerialNumberHex *IPAPrim[string] `json:"serial_number_hex,omitempty"`
  
    /*
Issuer

    */
    Issuer *IPAPrim[string] `json:"issuer,omitempty"`
  
    /*
Not Before

    */
    ValidNotBefore *IPAPrim[string] `json:"valid_not_before,omitempty"`
  
    /*
Not After

    */
    ValidNotAfter *IPAPrim[string] `json:"valid_not_after,omitempty"`
  
    /*
Fingerprint (SHA1)

    */
    Sha1Fingerprint *IPAPrim[string] `json:"sha1_fingerprint,omitempty"`
  
    /*
Fingerprint (SHA256)

    */
    Sha256Fingerprint *IPAPrim[string] `json:"sha256_fingerprint,omitempty"`
  
    /*
Revocation reason

    */
    RevocationReason *IPAPrim[string] `json:"revocation_reason,omitempty"`
  
    /*
PAC type
Override default list of supported PAC types. Use 'NONE' to disable PAC support for this service, e.g. this might be necessary for NFS services.
    */
    Ipakrbauthzdata *[]IPAPrim[string] `json:"ipakrbauthzdata,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]IPAPrim[string] `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *IPAPrim[bool] `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *IPAPrim[bool] `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *IPAPrim[bool] `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]IPAPrim[string] `json:"memberof_role,omitempty"`
  
    /*
Keytab

    */
    HasKeytab *IPAPrim[bool] `json:"has_keytab,omitempty"`
  
    /*
Managed by

    */
    ManagedbyHost *IPAPrim[string] `json:"managedby_host,omitempty"`
  
    /*
Users allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysUser *IPAPrim[string] `json:"ipaallowedtoperform_read_keys_user,omitempty"`
  
    /*
Groups allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysGroup *IPAPrim[string] `json:"ipaallowedtoperform_read_keys_group,omitempty"`
  
    /*
Hosts allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysHost *IPAPrim[string] `json:"ipaallowedtoperform_read_keys_host,omitempty"`
  
    /*
Host Groups allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysHostgroup *IPAPrim[string] `json:"ipaallowedtoperform_read_keys_hostgroup,omitempty"`
  
    /*
Users allowed to create keytab

    */
    IpaallowedtoperformWriteKeysUser *IPAPrim[string] `json:"ipaallowedtoperform_write_keys_user,omitempty"`
  
    /*
Groups allowed to create keytab

    */
    IpaallowedtoperformWriteKeysGroup *IPAPrim[string] `json:"ipaallowedtoperform_write_keys_group,omitempty"`
  
    /*
Hosts allowed to create keytab

    */
    IpaallowedtoperformWriteKeysHost *IPAPrim[string] `json:"ipaallowedtoperform_write_keys_host,omitempty"`
  
    /*
Host Groups allowed to create keytab

    */
    IpaallowedtoperformWriteKeysHostgroup *IPAPrim[string] `json:"ipaallowedtoperform_write_keys_hostgroup,omitempty"`
  }

func (t *Service) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Service[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Service%v", string(b))
}



type Servicedelegationrule struct {
  
    /*
Delegation name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Allowed Target

    */
    IpaallowedtargetServicedelegationtarget IPAPrim[string] `json:"ipaallowedtarget_servicedelegationtarget,omitempty"`
  
    /*
Allowed to Impersonate

    */
    Ipaallowedtoimpersonate IPAPrim[string] `json:"ipaallowedtoimpersonate,omitempty"`
  
    /*
Member principals

    */
    Memberprincipal IPAPrim[string] `json:"memberprincipal,omitempty"`
  }

func (t *Servicedelegationrule) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Servicedelegationrule[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Servicedelegationrule%v", string(b))
}



type Servicedelegationtarget struct {
  
    /*
Delegation name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Allowed Target

    */
    IpaallowedtargetServicedelegationtarget IPAPrim[string] `json:"ipaallowedtarget_servicedelegationtarget,omitempty"`
  
    /*
Allowed to Impersonate

    */
    Ipaallowedtoimpersonate IPAPrim[string] `json:"ipaallowedtoimpersonate,omitempty"`
  
    /*
Member principals

    */
    Memberprincipal IPAPrim[string] `json:"memberprincipal,omitempty"`
  }

func (t *Servicedelegationtarget) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Servicedelegationtarget[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Servicedelegationtarget%v", string(b))
}



type Servrole struct {
  
    /*
Role name
IPA role name
    */
    Name IPAPrim[string] `json:"name,omitempty"`
  }

func (t *Servrole) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Servrole[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Servrole%v", string(b))
}



type Stageuser struct {
  
    /*
User login

    */
    UID IPAPrim[string] `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname IPAPrim[string] `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn IPAPrim[string] `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *IPAPrim[string] `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *IPAPrim[string] `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *IPAPrim[string] `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *IPAPrim[string] `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *IPAPrim[string] `json:"loginshell,omitempty"`
  
    /*
Principal name

    */
    Krbcanonicalname *IPAPrim[string] `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]IPAPrim[string] `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *IPATime `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *IPATime `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]IPAPrim[string] `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *IPAPrim[string] `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *IPAPrim[bool] `json:"random,omitempty"`
  
    /*
Random password

    */
    Randompassword *IPAPrim[string] `json:"randompassword,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *IPAPrim[int] `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *IPAPrim[int] `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *IPAPrim[string] `json:"street,omitempty"`
  
    /*
City

    */
    L *IPAPrim[string] `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *IPAPrim[string] `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *IPAPrim[string] `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]IPAPrim[string] `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]IPAPrim[string] `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]IPAPrim[string] `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]IPAPrim[string] `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *IPAPrim[string] `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *IPAPrim[string] `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *IPAPrim[string] `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]IPAPrim[string] `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]IPAPrim[string] `json:"ipasshpubkey,omitempty"`
  
    /*
SSH public key fingerprint

    */
    Sshpubkeyfp *[]IPAPrim[string] `json:"sshpubkeyfp,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]IPAPrim[string] `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]IPAPrim[string] `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *IPAPrim[string] `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *IPAPrim[string] `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]IPAPrim[string] `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *IPAPrim[string] `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *IPAPrim[string] `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *IPAPrim[string] `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Certificate mapping data
Certificate mapping data
    */
    Ipacertmapdata *[]IPAPrim[string] `json:"ipacertmapdata,omitempty"`
  
    /*
Password

    */
    HasPassword *IPAPrim[bool] `json:"has_password,omitempty"`
  
    /*
Member of groups

    */
    MemberofGroup *[]IPAPrim[string] `json:"memberof_group,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]IPAPrim[string] `json:"memberof_role,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]IPAPrim[string] `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]IPAPrim[string] `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]IPAPrim[string] `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member of group

    */
    MemberofindirectGroup *IPAPrim[string] `json:"memberofindirect_group,omitempty"`
  
    /*
Indirect Member of netgroup

    */
    MemberofindirectNetgroup *IPAPrim[string] `json:"memberofindirect_netgroup,omitempty"`
  
    /*
Indirect Member of role

    */
    MemberofindirectRole *IPAPrim[string] `json:"memberofindirect_role,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *IPAPrim[string] `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *IPAPrim[string] `json:"memberofindirect_hbacrule,omitempty"`
  
    /*
Kerberos keys available

    */
    HasKeytab *IPAPrim[bool] `json:"has_keytab,omitempty"`
  }

func (t *Stageuser) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Stageuser[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Stageuser%v", string(b))
}



type Sudocmd struct {
  
    /*
Sudo Command

    */
    Sudocmd IPAPrim[string] `json:"sudocmd,omitempty"`
  
    /*
Description
A description of this command
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Sudo Command Groups

    */
    MemberofSudocmdgroup *[]IPAPrim[string] `json:"memberof_sudocmdgroup,omitempty"`
  }

func (t *Sudocmd) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Sudocmd[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Sudocmd%v", string(b))
}



type Sudocmdgroup struct {
  
    /*
Sudo Command Group

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
Group description
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Commands

    */
    MembercmdSudocmd *IPAPrim[string] `json:"membercmd_sudocmd,omitempty"`
  
    /*
Sudo Command Groups

    */
    MembercmdSudocmdgroup *IPAPrim[string] `json:"membercmd_sudocmdgroup,omitempty"`
  
    /*
Member Sudo commands

    */
    MemberSudocmd *[]IPAPrim[string] `json:"member_sudocmd,omitempty"`
  }

func (t *Sudocmdgroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Sudocmdgroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Sudocmdgroup%v", string(b))
}



type Sudorule struct {
  
    /*
Rule name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *IPAPrim[bool] `json:"ipaenabledflag,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *IPAPrim[string] `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *IPAPrim[string] `json:"hostcategory,omitempty"`
  
    /*
Command category
Command category the rule applies to
    */
    Cmdcategory *IPAPrim[string] `json:"cmdcategory,omitempty"`
  
    /*
RunAs User category
RunAs User category the rule applies to
    */
    Ipasudorunasusercategory *IPAPrim[string] `json:"ipasudorunasusercategory,omitempty"`
  
    /*
RunAs Group category
RunAs Group category the rule applies to
    */
    Ipasudorunasgroupcategory *IPAPrim[string] `json:"ipasudorunasgroupcategory,omitempty"`
  
    /*
Sudo order
integer to order the Sudo rules
    */
    Sudoorder *IPAPrim[int] `json:"sudoorder,omitempty"`
  
    /*
Users

    */
    MemberuserUser *IPAPrim[string] `json:"memberuser_user,omitempty"`
  
    /*
User Groups

    */
    MemberuserGroup *IPAPrim[string] `json:"memberuser_group,omitempty"`
  
    /*
External User
External User the rule applies to (sudorule-find only)
    */
    Externaluser *IPAPrim[string] `json:"externaluser,omitempty"`
  
    /*
Hosts

    */
    MemberhostHost *IPAPrim[string] `json:"memberhost_host,omitempty"`
  
    /*
Host Groups

    */
    MemberhostHostgroup *IPAPrim[string] `json:"memberhost_hostgroup,omitempty"`
  
    /*
Host Masks

    */
    Hostmask *[]IPAPrim[string] `json:"hostmask,omitempty"`
  
    /*
External host

    */
    Externalhost *[]IPAPrim[string] `json:"externalhost,omitempty"`
  
    /*
Sudo Allow Commands

    */
    MemberallowcmdSudocmd *IPAPrim[string] `json:"memberallowcmd_sudocmd,omitempty"`
  
    /*
Sudo Deny Commands

    */
    MemberdenycmdSudocmd *IPAPrim[string] `json:"memberdenycmd_sudocmd,omitempty"`
  
    /*
Sudo Allow Command Groups

    */
    MemberallowcmdSudocmdgroup *IPAPrim[string] `json:"memberallowcmd_sudocmdgroup,omitempty"`
  
    /*
Sudo Deny Command Groups

    */
    MemberdenycmdSudocmdgroup *IPAPrim[string] `json:"memberdenycmd_sudocmdgroup,omitempty"`
  
    /*
RunAs Users
Run as a user
    */
    IpasudorunasUser *IPAPrim[string] `json:"ipasudorunas_user,omitempty"`
  
    /*
Groups of RunAs Users
Run as any user within a specified group
    */
    IpasudorunasGroup *IPAPrim[string] `json:"ipasudorunas_group,omitempty"`
  
    /*
RunAs External User
External User the commands can run as (sudorule-find only)
    */
    Ipasudorunasextuser *IPAPrim[string] `json:"ipasudorunasextuser,omitempty"`
  
    /*
External Groups of RunAs Users
External Groups of users that the command can run as
    */
    Ipasudorunasextusergroup *IPAPrim[string] `json:"ipasudorunasextusergroup,omitempty"`
  
    /*
RunAs Groups
Run with the gid of a specified POSIX group
    */
    IpasudorunasgroupGroup *IPAPrim[string] `json:"ipasudorunasgroup_group,omitempty"`
  
    /*
RunAs External Group
External Group the commands can run as (sudorule-find only)
    */
    Ipasudorunasextgroup *IPAPrim[string] `json:"ipasudorunasextgroup,omitempty"`
  
    /*
Sudo Option

    */
    Ipasudoopt *IPAPrim[string] `json:"ipasudoopt,omitempty"`
  }

func (t *Sudorule) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Sudorule[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Sudorule%v", string(b))
}



type Topic struct {
  
    /*
Name

    */
    Name IPAPrim[string] `json:"name,omitempty"`
  
    /*
Version

    */
    Version IPAPrim[string] `json:"version,omitempty"`
  
    /*
Full name

    */
    FullName IPAPrim[string] `json:"full_name,omitempty"`
  
    /*
Documentation

    */
    Doc *IPAPrim[string] `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]IPAPrim[string] `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]IPAPrim[string] `json:"include,omitempty"`
  
    /*
Help topic

    */
    TopicTopic *IPAPrim[string] `json:"topic_topic,omitempty"`
  }

func (t *Topic) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Topic[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Topic%v", string(b))
}



type Topologysegment struct {
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Left node
Left replication node - an IPA server
    */
    Iparepltoposegmentleftnode IPAPrim[string] `json:"iparepltoposegmentleftnode,omitempty"`
  
    /*
Right node
Right replication node - an IPA server
    */
    Iparepltoposegmentrightnode IPAPrim[string] `json:"iparepltoposegmentrightnode,omitempty"`
  
    /*
Connectivity
Direction of replication between left and right replication node
    */
    Iparepltoposegmentdirection IPAPrim[string] `json:"iparepltoposegmentdirection,omitempty"`
  
    /*
Attributes to strip
A space separated list of attributes which are removed from replication updates.
    */
    Nsds5replicastripattrs *IPAPrim[string] `json:"nsds5replicastripattrs,omitempty"`
  
    /*
Attributes to replicate
Attributes that are not replicated to a consumer server during a fractional update. E.g., `(objectclass=*) $ EXCLUDE accountlockout memberof
    */
    Nsds5replicatedattributelist *IPAPrim[string] `json:"nsds5replicatedattributelist,omitempty"`
  
    /*
Attributes for total update
Attributes that are not replicated to a consumer server during a total update. E.g. (objectclass=*) $ EXCLUDE accountlockout
    */
    Nsds5replicatedattributelisttotal *IPAPrim[string] `json:"nsds5replicatedattributelisttotal,omitempty"`
  
    /*
Session timeout
Number of seconds outbound LDAP operations waits for a response from the remote replica before timing out and failing
    */
    Nsds5replicatimeout *IPAPrim[int] `json:"nsds5replicatimeout,omitempty"`
  
    /*
Replication agreement enabled
Whether a replication agreement is active, meaning whether replication is occurring per that agreement
    */
    Nsds5replicaenabled *IPAPrim[string] `json:"nsds5replicaenabled,omitempty"`
  }

func (t *Topologysegment) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Topologysegment[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Topologysegment%v", string(b))
}



type Topologysuffix struct {
  
    /*
Suffix name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Managed LDAP suffix DN

    */
    Iparepltopoconfroot string `json:"iparepltopoconfroot,omitempty"`
  }

func (t *Topologysuffix) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Topologysuffix[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Topologysuffix%v", string(b))
}



type Trust struct {
  
    /*
Realm name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Domain NetBIOS name

    */
    Ipantflatname IPAPrim[string] `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid IPAPrim[string] `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
SID blacklist incoming

    */
    Ipantsidblacklistincoming *[]IPAPrim[string] `json:"ipantsidblacklistincoming,omitempty"`
  
    /*
SID blacklist outgoing

    */
    Ipantsidblacklistoutgoing *[]IPAPrim[string] `json:"ipantsidblacklistoutgoing,omitempty"`
  
    /*
Trust direction

    */
    Trustdirection *IPAPrim[string] `json:"trustdirection,omitempty"`
  
    /*
Trust type

    */
    Trusttype *IPAPrim[string] `json:"trusttype,omitempty"`
  
    /*
Trust status

    */
    Truststatus *IPAPrim[string] `json:"truststatus,omitempty"`
  
    /*
UPN suffixes

    */
    Ipantadditionalsuffixes *[]IPAPrim[string] `json:"ipantadditionalsuffixes,omitempty"`
  }

func (t *Trust) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Trust[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Trust%v", string(b))
}



type Trustconfig struct {
  
    /*
Domain

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Security Identifier

    */
    Ipantsecurityidentifier IPAPrim[string] `json:"ipantsecurityidentifier,omitempty"`
  
    /*
NetBIOS name

    */
    Ipantflatname IPAPrim[string] `json:"ipantflatname,omitempty"`
  
    /*
Domain GUID

    */
    Ipantdomainguid IPAPrim[string] `json:"ipantdomainguid,omitempty"`
  
    /*
Fallback primary group

    */
    Ipantfallbackprimarygroup IPAPrim[string] `json:"ipantfallbackprimarygroup,omitempty"`
  
    /*
IPA AD trust agents
IPA servers configured as AD trust agents
    */
    AdTrustAgentServer *[]IPAPrim[string] `json:"ad_trust_agent_server,omitempty"`
  
    /*
IPA AD trust controllers
IPA servers configured as AD trust controllers
    */
    AdTrustControllerServer *[]IPAPrim[string] `json:"ad_trust_controller_server,omitempty"`
  }

func (t *Trustconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Trustconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Trustconfig%v", string(b))
}



type Trustdomain struct {
  
    /*
Domain name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *IPAPrim[string] `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *IPAPrim[string] `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Domain enabled

    */
    DomainEnabled *IPAPrim[bool] `json:"domain_enabled,omitempty"`
  }

func (t *Trustdomain) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Trustdomain[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Trustdomain%v", string(b))
}



type User struct {
  
    /*
User login

    */
    UID IPAPrim[string] `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname *IPAPrim[string] `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn IPAPrim[string] `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *IPAPrim[string] `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *IPAPrim[string] `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *IPAPrim[string] `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *IPAPrim[string] `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *IPAPrim[string] `json:"loginshell,omitempty"`
  
    /*
Principal name

    */
    Krbcanonicalname *IPAPrim[string] `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]IPAPrim[string] `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *IPATime `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *IPATime `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]IPAPrim[string] `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *IPAPrim[string] `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *IPAPrim[bool] `json:"random,omitempty"`
  
    /*
Random password

    */
    Randompassword *IPAPrim[string] `json:"randompassword,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *IPAPrim[int] `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *IPAPrim[int] `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *IPAPrim[string] `json:"street,omitempty"`
  
    /*
City

    */
    L *IPAPrim[string] `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *IPAPrim[string] `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *IPAPrim[string] `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]IPAPrim[string] `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]IPAPrim[string] `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]IPAPrim[string] `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]IPAPrim[string] `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *IPAPrim[string] `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *IPAPrim[string] `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *IPAPrim[string] `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]IPAPrim[string] `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]IPAPrim[string] `json:"ipasshpubkey,omitempty"`
  
    /*
SSH public key fingerprint

    */
    Sshpubkeyfp *[]IPAPrim[string] `json:"sshpubkeyfp,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]IPAPrim[string] `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]IPAPrim[string] `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *IPAPrim[string] `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *IPAPrim[string] `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]IPAPrim[string] `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *IPAPrim[string] `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *IPAPrim[string] `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *IPAPrim[string] `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Certificate mapping data
Certificate mapping data
    */
    Ipacertmapdata *[]IPAPrim[string] `json:"ipacertmapdata,omitempty"`
  
    /*
Account disabled

    */
    Nsaccountlock *IPAPrim[bool] `json:"nsaccountlock,omitempty"`
  
    /*
Preserved user

    */
    Preserved *IPAPrim[bool] `json:"preserved,omitempty"`
  
    /*
Password

    */
    HasPassword *IPAPrim[bool] `json:"has_password,omitempty"`
  
    /*
Member of groups

    */
    MemberofGroup *[]IPAPrim[string] `json:"memberof_group,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]IPAPrim[string] `json:"memberof_role,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]IPAPrim[string] `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]IPAPrim[string] `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]IPAPrim[string] `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member of group

    */
    MemberofindirectGroup *IPAPrim[string] `json:"memberofindirect_group,omitempty"`
  
    /*
Indirect Member of netgroup

    */
    MemberofindirectNetgroup *IPAPrim[string] `json:"memberofindirect_netgroup,omitempty"`
  
    /*
Indirect Member of role

    */
    MemberofindirectRole *IPAPrim[string] `json:"memberofindirect_role,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *IPAPrim[string] `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *IPAPrim[string] `json:"memberofindirect_hbacrule,omitempty"`
  
    /*
Kerberos keys available

    */
    HasKeytab *IPAPrim[bool] `json:"has_keytab,omitempty"`
  }

func (t *User) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("User[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("User%v", string(b))
}



type Userstatus struct {
  
    /*
Preserved user

    */
    Preserved *IPAPrim[bool] `json:"preserved,omitempty"`
  
    /*
Server

    */
    Server *IPAPrim[string] `json:"server,omitempty"`
  
    /*
Failed logins

    */
    Krbloginfailedcount *IPAPrim[string] `json:"krbloginfailedcount,omitempty"`
  
    /*
Last successful authentication

    */
    Krblastsuccessfulauth *IPAPrim[string] `json:"krblastsuccessfulauth,omitempty"`
  
    /*
Last failed authentication

    */
    Krblastfailedauth *IPAPrim[string] `json:"krblastfailedauth,omitempty"`
  
    /*
Time now

    */
    Now *IPAPrim[string] `json:"now,omitempty"`
  }

func (t *Userstatus) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Userstatus[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Userstatus%v", string(b))
}



type Vault struct {
  
    /*
Vault name

    */
    Cn IPAPrim[string] `json:"cn,omitempty"`
  
    /*
Description
Vault description
    */
    Description *IPAPrim[string] `json:"description,omitempty"`
  
    /*
Type
Vault type
    */
    Ipavaulttype *IPAPrim[string] `json:"ipavaulttype,omitempty"`
  
    /*
Salt
Vault salt
    */
    Ipavaultsalt *string `json:"ipavaultsalt,omitempty"`
  
    /*
Public key
Vault public key
    */
    Ipavaultpublickey *string `json:"ipavaultpublickey,omitempty"`
  
    /*
Owner users

    */
    OwnerUser *IPAPrim[string] `json:"owner_user,omitempty"`
  
    /*
Owner groups

    */
    OwnerGroup *IPAPrim[string] `json:"owner_group,omitempty"`
  
    /*
Owner services

    */
    OwnerService *IPAPrim[string] `json:"owner_service,omitempty"`
  
    /*
Failed owners

    */
    Owner *IPAPrim[string] `json:"owner,omitempty"`
  
    /*
Vault service

    */
    Service *IPAPrim[string] `json:"service,omitempty"`
  
    /*
Shared vault

    */
    Shared *IPAPrim[bool] `json:"shared,omitempty"`
  
    /*
Vault user

    */
    Username *IPAPrim[string] `json:"username,omitempty"`
  
    /*
Member users

    */
    MemberUser *[]IPAPrim[string] `json:"member_user,omitempty"`
  
    /*
Member groups

    */
    MemberGroup *[]IPAPrim[string] `json:"member_group,omitempty"`
  
    /*
Member services

    */
    MemberService *[]IPAPrim[string] `json:"member_service,omitempty"`
  }

func (t *Vault) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Vault[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Vault%v", string(b))
}



type Vaultconfig struct {
  
    /*
Transport Certificate

    */
    TransportCert string `json:"transport_cert,omitempty"`
  
    /*
IPA KRA servers
IPA servers configured as key recovery agents
    */
    KraServerServer *[]IPAPrim[string] `json:"kra_server_server,omitempty"`
  }

func (t *Vaultconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Vaultconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Vaultconfig%v", string(b))
}



type Vaultcontainer struct {
  
    /*
Owner users

    */
    OwnerUser *IPAPrim[string] `json:"owner_user,omitempty"`
  
    /*
Owner groups

    */
    OwnerGroup *IPAPrim[string] `json:"owner_group,omitempty"`
  
    /*
Owner services

    */
    OwnerService *IPAPrim[string] `json:"owner_service,omitempty"`
  
    /*
Failed owners

    */
    Owner *IPAPrim[string] `json:"owner,omitempty"`
  
    /*
Vault service

    */
    Service *IPAPrim[string] `json:"service,omitempty"`
  
    /*
Shared vault

    */
    Shared *IPAPrim[bool] `json:"shared,omitempty"`
  
    /*
Vault user

    */
    Username *IPAPrim[string] `json:"username,omitempty"`
  }

func (t *Vaultcontainer) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Vaultcontainer[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Vaultcontainer%v", string(b))
}





const PublicErrorCode = 900

const VersionErrorCode = 901

const UnknownErrorCode = 902

const InternalErrorCode = 903

const ServerInternalErrorCode = 904

const CommandErrorCode = 905

const ServerCommandErrorCode = 906

const NetworkErrorCode = 907

const ServerNetworkErrorCode = 908

const JSONErrorCode = 909

const XMLRPCMarshallErrorCode = 910

const RefererErrorCode = 911

const EnvironmentErrorCode = 912

const SystemEncodingErrorCode = 913

const AuthenticationErrorCode = 1000

const KerberosErrorCode = 1100

const CCacheErrorCode = 1101

const ServiceErrorCode = 1102

const NoCCacheErrorCode = 1103

const TicketExpiredCode = 1104

const BadCCachePermsCode = 1105

const BadCCacheFormatCode = 1106

const CannotResolveKDCCode = 1107

const SessionErrorCode = 1200

const InvalidSessionPasswordCode = 1201

const PasswordExpiredCode = 1202

const KrbPrincipalExpiredCode = 1203

const UserLockedCode = 1204

const AuthorizationErrorCode = 2000

const ACIErrorCode = 2100

const InvocationErrorCode = 3000

const EncodingErrorCode = 3001

const BinaryEncodingErrorCode = 3002

const ZeroArgumentErrorCode = 3003

const MaxArgumentErrorCode = 3004

const OptionErrorCode = 3005

const OverlapErrorCode = 3006

const RequirementErrorCode = 3007

const ConversionErrorCode = 3008

const ValidationErrorCode = 3009

const NoSuchNamespaceErrorCode = 3010

const PasswordMismatchCode = 3011

const NotImplementedErrorCode = 3012

const NotConfiguredErrorCode = 3013

const PromptFailedCode = 3014

const DeprecationErrorCode = 3015

const NotAForestRootErrorCode = 3016

const ExecutionErrorCode = 4000

const NotFoundCode = 4001

const DuplicateEntryCode = 4002

const HostServiceCode = 4003

const MalformedServicePrincipalCode = 4004

const RealmMismatchCode = 4005

const RequiresRootCode = 4006

const AlreadyPosixGroupCode = 4007

const MalformedUserPrincipalCode = 4008

const AlreadyActiveCode = 4009

const AlreadyInactiveCode = 4010

const HasNSAccountLockCode = 4011

const NotGroupMemberCode = 4012

const RecursiveGroupCode = 4013

const AlreadyGroupMemberCode = 4014

const Base64DecodeErrorCode = 4015

const RemoteRetrieveErrorCode = 4016

const SameGroupErrorCode = 4017

const DefaultGroupErrorCode = 4018

const DNSNotARecordErrorCode = 4019

const ManagedGroupErrorCode = 4020

const ManagedPolicyErrorCode = 4021

const FileErrorCode = 4022

const NoCertificateErrorCode = 4023

const ManagedGroupExistsErrorCode = 4024

const ReverseMemberErrorCode = 4025

const AttrValueNotFoundCode = 4026

const SingleMatchExpectedCode = 4027

const AlreadyExternalGroupCode = 4028

const ExternalGroupViolationCode = 4029

const PosixGroupViolationCode = 4030

const EmptyResultCode = 4031

const InvalidDomainLevelErrorCode = 4032

const ServerRemovalErrorCode = 4033

const OperationNotSupportedForPrincipalTypeCode = 4034

const HTTPRequestErrorCode = 4035

const RedundantMappingRuleCode = 4036

const CSRTemplateErrorCode = 4037

const AlreadyContainsValueErrorCode = 4038

const BuiltinErrorCode = 4100

const HelpErrorCode = 4101

const LDAPErrorCode = 4200

const MidairCollisionCode = 4201

const EmptyModlistCode = 4202

const DatabaseErrorCode = 4203

const LimitsExceededCode = 4204

const ObjectclassViolationCode = 4205

const NotAllowedOnRDNCode = 4206

const OnlyOneValueAllowedCode = 4207

const InvalidSyntaxCode = 4208

const BadSearchFilterCode = 4209

const NotAllowedOnNonLeafCode = 4210

const DatabaseTimeoutCode = 4211

const DNSDataMismatchCode = 4212

const TaskTimeoutCode = 4213

const TimeLimitExceededCode = 4214

const SizeLimitExceededCode = 4215

const AdminLimitExceededCode = 4216

const CertificateErrorCode = 4300

const CertificateOperationErrorCode = 4301

const CertificateFormatErrorCode = 4302

const MutuallyExclusiveErrorCode = 4303

const NonFatalErrorCode = 4304

const AlreadyRegisteredErrorCode = 4305

const NotRegisteredErrorCode = 4306

const DependentEntryCode = 4307

const LastMemberErrorCode = 4308

const ProtectedEntryErrorCode = 4309

const CertificateInvalidErrorCode = 4310

const SchemaUpToDateCode = 4311

const DNSErrorCode = 4400

const DNSResolverErrorCode = 4401

const TrustErrorCode = 4500

const TrustTopologyConflictErrorCode = 4501

const GenericErrorCode = 5000

